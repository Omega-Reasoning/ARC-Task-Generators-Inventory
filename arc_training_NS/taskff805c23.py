from arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from transformation_library import find_connected_objects, GridObject, GridObjects
from input_library import create_object, retry, random_cell_coloring
import numpy as np
import random
import math

class SymmetricPatternInpaintingGenerator(ARCTaskGenerator):
    
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['n']} × {vars['n']}.",
            "Each grid includes cells in two randomly selected colors, along with some empty cells (0).",
            "Each input grid presents a meticulously designed pattern that exhibits perfect 8-way symmetry: it looks identical when reflected across horizontal, vertical, and diagonal axes, and when rotated by 90°, 180°, or 270°.",
            "One m × m square of color {color('mask_color')} obscures part of the pattern, where m = {vars['n']} // 5.",
            "The two randomly selected colors and value m vary across different grids, to ensure diversity."
        ]
        
        transformation_reasoning_chain = [
            "The output grid is generated by inferring and filling in the masked region of the input grid based on the visible pattern.",
            "Only the filled m × m area is returned as the output grid."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_symmetric_pattern(self, n: int, color1: int, color2: int) -> np.ndarray:
        """Create a pattern with both reflective and radial symmetry using a simple approach."""
        grid = np.zeros((n, n), dtype=int)
        center = n // 2
        
        # Fill only the top-left quadrant, then apply symmetries
        for r in range(center + 1):
            for c in range(center + 1):
                # Simple pattern based on distance and coordinates
                dist_from_center = max(abs(r - center), abs(c - center))  # Chebyshev distance
                
                # Create rings and cross patterns
                is_ring = dist_from_center % 2 == 1
                is_cross = (r == center) or (c == center)
                
                fill_prob = 0.7 if is_ring or is_cross else 0.3
                
                if random.random() < fill_prob:
                    color = random.choice([color1, color2])
                    # Set this color at all symmetric positions
                    self.set_all_symmetric_positions(grid, r, c, color, n)
        
        return grid
    
    def set_all_symmetric_positions(self, grid, r, c, color, n):
        """Set color at all 8 symmetric positions."""
        # 4-way reflective symmetry
        positions = [
            (r, c),                    # Original
            (r, n - 1 - c),            # Horizontal reflection
            (n - 1 - r, c),            # Vertical reflection
            (n - 1 - r, n - 1 - c),    # Both reflections
        ]
        
        # Add diagonal reflections for 8-way symmetry
        positions.extend([
            (c, r),                    # Main diagonal reflection
            (c, n - 1 - r),            # Main diagonal + horizontal
            (n - 1 - c, r),            # Main diagonal + vertical
            (n - 1 - c, n - 1 - r),    # Main diagonal + both
        ])
        
        # Apply to all valid positions
        for pos_r, pos_c in positions:
            if 0 <= pos_r < n and 0 <= pos_c < n:
                grid[pos_r, pos_c] = color
    
    def create_input(self, taskvars, gridvars):
        n = taskvars['n']
        mask_color = taskvars['mask_color']
        m = n // 5
        
        # Get colors for this specific grid (these vary per grid)
        color1 = gridvars['color1']
        color2 = gridvars['color2']
        
        # Create symmetric pattern
        grid = self.create_symmetric_pattern(n, color1, color2)
        
        # Choose random position for mask (ensure it fits within grid)
        max_r = n - m
        max_c = n - m
        mask_r = random.randint(0, max_r)
        mask_c = random.randint(0, max_c)
        
        # Store mask position for transform_input
        gridvars['mask_r'] = mask_r
        gridvars['mask_c'] = mask_c
        gridvars['mask_size'] = m
        
        # Apply mask - ensure it's exactly m x m
        grid[mask_r:mask_r + m, mask_c:mask_c + m] = mask_color
        
        return grid
    
    def transform_input(self, grid, taskvars):
        n = taskvars['n']
        mask_color = taskvars['mask_color']
        m = n // 5
        
        # Find the mask region
        mask_positions = np.where(grid == mask_color)
        if len(mask_positions[0]) == 0:
            return np.zeros((m, m), dtype=int)
        
        # Find the bounding box of the mask
        min_r, max_r = mask_positions[0].min(), mask_positions[0].max()
        min_c, max_c = mask_positions[1].min(), mask_positions[1].max()
        
        # Create a copy of the grid for reconstruction
        reconstructed = grid.copy()
        
        # Reconstruct the pattern under the mask using symmetry
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if grid[r, c] == mask_color:
                    # Try to infer the color from symmetry
                    inferred_color = self.infer_color_from_symmetry(grid, r, c, n, mask_color)
                    reconstructed[r, c] = inferred_color
        
        # Extract just the masked region
        return reconstructed[min_r:max_r + 1, min_c:max_c + 1]
    
    def infer_color_from_symmetry(self, grid, r, c, n, mask_color):
        """Infer color at position (r,c) using 8-way symmetry."""
        # All 8 symmetric positions
        symmetric_positions = [
            (r, n - 1 - c),            # Horizontal reflection
            (n - 1 - r, c),            # Vertical reflection
            (n - 1 - r, n - 1 - c),    # Both reflections
            (c, r),                    # Main diagonal reflection
            (c, n - 1 - r),            # Main diagonal + horizontal
            (n - 1 - c, r),            # Main diagonal + vertical
            (n - 1 - c, n - 1 - r),    # Main diagonal + both
        ]
        
        # Check each symmetric position
        for sym_r, sym_c in symmetric_positions:
            if 0 <= sym_r < n and 0 <= sym_c < n:
                if grid[sym_r, sym_c] != mask_color:
                    return grid[sym_r, sym_c]
        
        # If no symmetric position gives us info, return background
        return 0
    
    def create_grids(self):
        num_train = random.randint(3, 6)
        
        # Create task variables - only n and mask_color are task-level constants
        taskvars = {
            'n': random.randint(10, 25),  # Grid size
            'mask_color': random.randint(1, 9),  # Mask color
        }
        
        def create_example():
            # Generate different colors for each grid
            gridvars = {}
            
            # Select two random colors different from mask_color
            available_colors = [i for i in range(1, 10) if i != taskvars['mask_color']]
            gridvars['color1'] = random.choice(available_colors)
            available_colors.remove(gridvars['color1'])
            gridvars['color2'] = random.choice(available_colors)
            
            input_grid = self.create_input(taskvars, gridvars)
            output_grid = self.transform_input(input_grid, taskvars)
            
            return {
                'input': input_grid,
                'output': output_grid
            }
        
        # Generate training examples
        train_examples = []
        for _ in range(num_train):
            train_examples.append(create_example())
        
        # Generate test example
        test_examples = [create_example()]
        
        return taskvars, {
            'train': train_examples,
            'test': test_examples
        }
