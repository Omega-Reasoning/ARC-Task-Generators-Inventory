from arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from transformation_library import find_connected_objects, GridObject
from input_library import create_object, retry, Contiguity
import numpy as np
import random
from typing import Dict, Any, Tuple, List

class Taskf25fbde4Generator(ARCTaskGenerator):
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['n']} x {vars['n']}.",
            "They only contain {color('object_color')} and empty cells.",
            "In each input grid the {color('object_color')} cells form exactly one object."
        ]
        
        transformation_reasoning_chain = [
            "The output grid is generated by identifying the object formed by the {color('object_color')} cells in the input grid.",
            "Each {color('object_color')} cell in the input grid is replaced by a 2Ã—2 block of {color('object_color')} cells in the output grid.",
            "As a result, the entire object is scaled up by a factor of 2, while preserving its shape and relative structure.",
            "The output grid includes only the bounding box of the scaled-up object, meaning it is cropped to the minimal size needed to contain the entire enlarged object."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_grids(self) -> Tuple[Dict[str, Any], TrainTestData]:
        # Initialize task variables
        taskvars = {
            'n': random.randint(5, 15),  # Keep input grids reasonable size since output will be 2x larger
            'object_color': random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9])  # Any non-background color
        }
        
        # Create training examples (3-6 examples)
        num_train = random.randint(3, 6)
        num_test = 1
        
        train_examples = []
        for _ in range(num_train):
            input_grid = self.create_input(taskvars, {})
            output_grid = self.transform_input(input_grid, taskvars)
            train_examples.append({'input': input_grid, 'output': output_grid})
        
        test_examples = []
        for _ in range(num_test):
            input_grid = self.create_input(taskvars, {})
            output_grid = self.transform_input(input_grid, taskvars)
            test_examples.append({'input': input_grid, 'output': output_grid})
        
        train_test_data = {
            'train': train_examples,
            'test': test_examples
        }
        
        return taskvars, train_test_data
    
    def create_input(self, taskvars: Dict[str, Any], gridvars: Dict[str, Any]) -> np.ndarray:
        n = taskvars['n']
        object_color = taskvars['object_color']
        
        # Create an object that forms exactly one connected component
        # Use retry to ensure we get a valid object
        def create_valid_object():
            # Create object with some randomness in size (but not too large)
            obj_size = random.randint(2, min(8, n//2))  # Reasonable object size
            obj_height = random.randint(2, min(obj_size + 2, n-1))
            obj_width = random.randint(2, min(obj_size + 2, n-1))
            
            # Create the object using create_object function
            obj_grid = create_object(obj_height, obj_width, object_color, 
                                   contiguity=Contiguity.FOUR, background=0)
            
            # Place it randomly in the full grid
            grid = np.zeros((n, n), dtype=int)
            
            # Find valid placement position
            max_start_row = n - obj_height
            max_start_col = n - obj_width
            
            if max_start_row >= 0 and max_start_col >= 0:
                start_row = random.randint(0, max_start_row)
                start_col = random.randint(0, max_start_col)
                grid[start_row:start_row+obj_height, start_col:start_col+obj_width] = obj_grid
            
            return grid
        
        # Ensure we have exactly one connected object
        def is_valid_grid(grid):
            objects = find_connected_objects(grid, diagonal_connectivity=False, 
                                           background=0, monochromatic=True)
            # Must have exactly one object with the correct color
            matching_objects = [obj for obj in objects if object_color in obj.colors]
            return len(matching_objects) == 1 and len(objects) == 1
        
        return retry(create_valid_object, is_valid_grid, max_attempts=50)
    
    def transform_input(self, grid: np.ndarray, taskvars: Dict[str, Any]) -> np.ndarray:
        object_color = taskvars['object_color']
        
        # Find the object in the input grid
        objects = find_connected_objects(grid, diagonal_connectivity=False, 
                                       background=0, monochromatic=True)
        
        # Get the object with the target color
        target_object = None
        for obj in objects:
            if object_color in obj.colors:
                target_object = obj
                break
        
        if target_object is None:
            # Fallback - shouldn't happen with valid input
            return np.array([[0]])
        
        # Get the bounding box of the object
        bbox = target_object.bounding_box
        obj_height = bbox[0].stop - bbox[0].start
        obj_width = bbox[1].stop - bbox[1].start
        
        # Create output grid that's 2x the size of the bounding box
        output_height = obj_height * 2
        output_width = obj_width * 2
        output_grid = np.zeros((output_height, output_width), dtype=int)
        
        # Scale up each cell of the object to a 2x2 block
        for r, c, color in target_object.cells:
            # Convert to relative coordinates within bounding box
            rel_r = r - bbox[0].start
            rel_c = c - bbox[1].start
            
            # Map to 2x2 block in output grid
            out_r = rel_r * 2
            out_c = rel_c * 2
            
            # Fill the 2x2 block
            output_grid[out_r:out_r+2, out_c:out_c+2] = color
        
        return output_grid

