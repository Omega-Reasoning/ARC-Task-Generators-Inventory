task_id,created_at,generator_name,input_reasoning_chain,transformation_reasoning_chain,task_variables,code,data
Ho55FGfHBWn4vZVsoGVoC7,2025-07-21T15:52:22.617659,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 9, 5, 9, 8, 7], [8, 5, 8, 5, 3, 9], [3, 4, 7, 9, 7, 5], [4, 7, 9, 4, 8, 4], [5, 3, 2, 9, 3, 5], [6, 2, 5, 4, 9, 7]], ""output"": [[7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7], [8, 5, 8, 5, 3, 9, 8, 5, 8, 5, 3, 9, 8, 5, 8, 5, 3, 9], [3, 4, 7, 9, 7, 5, 3, 4, 7, 9, 7, 5, 3, 4, 7, 9, 7, 5], [4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4], [5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5], [6, 2, 5, 4, 9, 7, 6, 2, 5, 4, 9, 7, 6, 2, 5, 4, 9, 7], [7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7], [9, 5, 8, 5, 3, 8, 9, 5, 8, 5, 3, 8, 9, 5, 8, 5, 3, 8], [5, 4, 7, 9, 7, 3, 5, 4, 7, 9, 7, 3, 5, 4, 7, 9, 7, 3], [4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4], [5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5], [7, 2, 5, 4, 9, 6, 7, 2, 5, 4, 9, 6, 7, 2, 5, 4, 9, 6], [7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7, 7, 9, 5, 9, 8, 7], [8, 5, 8, 5, 3, 9, 8, 5, 8, 5, 3, 9, 8, 5, 8, 5, 3, 9], [3, 4, 7, 9, 7, 5, 3, 4, 7, 9, 7, 5, 3, 4, 7, 9, 7, 5], [4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4, 4, 7, 9, 4, 8, 4], [5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5, 5, 3, 2, 9, 3, 5], [6, 2, 5, 4, 9, 7, 6, 2, 5, 4, 9, 7, 6, 2, 5, 4, 9, 7]]}, {""input"": [[2, 8, 2, 6, 7, 2], [8, 5, 8, 9, 6, 7], [9, 7, 3, 5, 4, 5], [8, 5, 2, 4, 2, 4], [5, 4, 6, 9, 5, 2], [6, 8, 9, 8, 7, 1]], ""output"": [[2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2], [8, 5, 8, 9, 6, 7, 8, 5, 8, 9, 6, 7, 8, 5, 8, 9, 6, 7], [9, 7, 3, 5, 4, 5, 9, 7, 3, 5, 4, 5, 9, 7, 3, 5, 4, 5], [8, 5, 2, 4, 2, 4, 8, 5, 2, 4, 2, 4, 8, 5, 2, 4, 2, 4], [5, 4, 6, 9, 5, 2, 5, 4, 6, 9, 5, 2, 5, 4, 6, 9, 5, 2], [6, 8, 9, 8, 7, 1, 6, 8, 9, 8, 7, 1, 6, 8, 9, 8, 7, 1], [2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2], [7, 5, 8, 9, 6, 8, 7, 5, 8, 9, 6, 8, 7, 5, 8, 9, 6, 8], [5, 7, 3, 5, 4, 9, 5, 7, 3, 5, 4, 9, 5, 7, 3, 5, 4, 9], [4, 5, 2, 4, 2, 8, 4, 5, 2, 4, 2, 8, 4, 5, 2, 4, 2, 8], [2, 4, 6, 9, 5, 5, 2, 4, 6, 9, 5, 5, 2, 4, 6, 9, 5, 5], [1, 8, 9, 8, 7, 6, 1, 8, 9, 8, 7, 6, 1, 8, 9, 8, 7, 6], [2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2, 2, 8, 2, 6, 7, 2], [8, 5, 8, 9, 6, 7, 8, 5, 8, 9, 6, 7, 8, 5, 8, 9, 6, 7], [9, 7, 3, 5, 4, 5, 9, 7, 3, 5, 4, 5, 9, 7, 3, 5, 4, 5], [8, 5, 2, 4, 2, 4, 8, 5, 2, 4, 2, 4, 8, 5, 2, 4, 2, 4], [5, 4, 6, 9, 5, 2, 5, 4, 6, 9, 5, 2, 5, 4, 6, 9, 5, 2], [6, 8, 9, 8, 7, 1, 6, 8, 9, 8, 7, 1, 6, 8, 9, 8, 7, 1]]}, {""input"": [[8, 2, 3, 8, 2, 5], [6, 9, 7, 4, 7, 8], [8, 6, 8, 6, 5, 9], [4, 7, 4, 8, 7, 8], [5, 9, 8, 9, 4, 7], [8, 4, 2, 8, 9, 1]], ""output"": [[8, 2, 3, 8, 2, 5, 8, 2, 3, 8, 2, 5, 8, 2, 3, 8, 2, 5], [6, 9, 7, 4, 7, 8, 6, 9, 7, 4, 7, 8, 6, 9, 7, 4, 7, 8], [8, 6, 8, 6, 5, 9, 8, 6, 8, 6, 5, 9, 8, 6, 8, 6, 5, 9], [4, 7, 4, 8, 7, 8, 4, 7, 4, 8, 7, 8, 4, 7, 4, 8, 7, 8], [5, 9, 8, 9, 4, 7, 5, 9, 8, 9, 4, 7, 5, 9, 8, 9, 4, 7], [8, 4, 2, 8, 9, 1, 8, 4, 2, 8, 9, 1, 8, 4, 2, 8, 9, 1], [5, 2, 3, 8, 2, 8, 5, 2, 3, 8, 2, 8, 5, 2, 3, 8, 2, 8], [8, 9, 7, 4, 7, 6, 8, 9, 7, 4, 7, 6, 8, 9, 7, 4, 7, 6], [9, 6, 8, 6, 5, 8, 9, 6, 8, 6, 5, 8, 9, 6, 8, 6, 5, 8], [8, 7, 4, 8, 7, 4, 8, 7, 4, 8, 7, 4, 8, 7, 4, 8, 7, 4], [7, 9, 8, 9, 4, 5, 7, 9, 8, 9, 4, 5, 7, 9, 8, 9, 4, 5], [1, 4, 2, 8, 9, 8, 1, 4, 2, 8, 9, 8, 1, 4, 2, 8, 9, 8], [8, 2, 3, 8, 2, 5, 8, 2, 3, 8, 2, 5, 8, 2, 3, 8, 2, 5], [6, 9, 7, 4, 7, 8, 6, 9, 7, 4, 7, 8, 6, 9, 7, 4, 7, 8], [8, 6, 8, 6, 5, 9, 8, 6, 8, 6, 5, 9, 8, 6, 8, 6, 5, 9], [4, 7, 4, 8, 7, 8, 4, 7, 4, 8, 7, 8, 4, 7, 4, 8, 7, 8], [5, 9, 8, 9, 4, 7, 5, 9, 8, 9, 4, 7, 5, 9, 8, 9, 4, 7], [8, 4, 2, 8, 9, 1, 8, 4, 2, 8, 9, 1, 8, 4, 2, 8, 9, 1]]}], ""test"": [{""input"": [[4, 5, 8, 4, 2, 8], [2, 7, 5, 7, 4, 5], [4, 5, 3, 5, 3, 6], [6, 9, 2, 6, 5, 8], [7, 4, 7, 5, 2, 3], [3, 2, 6, 9, 3, 4]], ""output"": [[4, 5, 8, 4, 2, 8, 4, 5, 8, 4, 2, 8, 4, 5, 8, 4, 2, 8], [2, 7, 5, 7, 4, 5, 2, 7, 5, 7, 4, 5, 2, 7, 5, 7, 4, 5], [4, 5, 3, 5, 3, 6, 4, 5, 3, 5, 3, 6, 4, 5, 3, 5, 3, 6], [6, 9, 2, 6, 5, 8, 6, 9, 2, 6, 5, 8, 6, 9, 2, 6, 5, 8], [7, 4, 7, 5, 2, 3, 7, 4, 7, 5, 2, 3, 7, 4, 7, 5, 2, 3], [3, 2, 6, 9, 3, 4, 3, 2, 6, 9, 3, 4, 3, 2, 6, 9, 3, 4], [8, 5, 8, 4, 2, 4, 8, 5, 8, 4, 2, 4, 8, 5, 8, 4, 2, 4], [5, 7, 5, 7, 4, 2, 5, 7, 5, 7, 4, 2, 5, 7, 5, 7, 4, 2], [6, 5, 3, 5, 3, 4, 6, 5, 3, 5, 3, 4, 6, 5, 3, 5, 3, 4], [8, 9, 2, 6, 5, 6, 8, 9, 2, 6, 5, 6, 8, 9, 2, 6, 5, 6], [3, 4, 7, 5, 2, 7, 3, 4, 7, 5, 2, 7, 3, 4, 7, 5, 2, 7], [4, 2, 6, 9, 3, 3, 4, 2, 6, 9, 3, 3, 4, 2, 6, 9, 3, 3], [4, 5, 8, 4, 2, 8, 4, 5, 8, 4, 2, 8, 4, 5, 8, 4, 2, 8], [2, 7, 5, 7, 4, 5, 2, 7, 5, 7, 4, 5, 2, 7, 5, 7, 4, 5], [4, 5, 3, 5, 3, 6, 4, 5, 3, 5, 3, 6, 4, 5, 3, 5, 3, 6], [6, 9, 2, 6, 5, 8, 6, 9, 2, 6, 5, 8, 6, 9, 2, 6, 5, 8], [7, 4, 7, 5, 2, 3, 7, 4, 7, 5, 2, 3, 7, 4, 7, 5, 2, 3], [3, 2, 6, 9, 3, 4, 3, 2, 6, 9, 3, 4, 3, 2, 6, 9, 3, 4]]}]}"
Mc59d84Bnfq6YsGbyBZ4wP,2025-07-21T15:52:22.621363,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 8, 4, 9, 3], [3, 2, 8, 3, 2], [5, 3, 7, 6, 4], [7, 5, 3, 8, 3], [2, 8, 9, 3, 1]], ""output"": [[5, 8, 4, 9, 3, 5, 8, 4, 9, 3, 5, 8, 4, 9, 3], [3, 2, 8, 3, 2, 3, 2, 8, 3, 2, 3, 2, 8, 3, 2], [5, 3, 7, 6, 4, 5, 3, 7, 6, 4, 5, 3, 7, 6, 4], [7, 5, 3, 8, 3, 7, 5, 3, 8, 3, 7, 5, 3, 8, 3], [2, 8, 9, 3, 1, 2, 8, 9, 3, 1, 2, 8, 9, 3, 1], [3, 8, 4, 9, 5, 3, 8, 4, 9, 5, 3, 8, 4, 9, 5], [2, 2, 8, 3, 3, 2, 2, 8, 3, 3, 2, 2, 8, 3, 3], [4, 3, 7, 6, 5, 4, 3, 7, 6, 5, 4, 3, 7, 6, 5], [3, 5, 3, 8, 7, 3, 5, 3, 8, 7, 3, 5, 3, 8, 7], [1, 8, 9, 3, 2, 1, 8, 9, 3, 2, 1, 8, 9, 3, 2], [5, 8, 4, 9, 3, 5, 8, 4, 9, 3, 5, 8, 4, 9, 3], [3, 2, 8, 3, 2, 3, 2, 8, 3, 2, 3, 2, 8, 3, 2], [5, 3, 7, 6, 4, 5, 3, 7, 6, 4, 5, 3, 7, 6, 4], [7, 5, 3, 8, 3, 7, 5, 3, 8, 3, 7, 5, 3, 8, 3], [2, 8, 9, 3, 1, 2, 8, 9, 3, 1, 2, 8, 9, 3, 1]]}, {""input"": [[2, 9, 7, 3, 8], [4, 3, 2, 9, 7], [6, 2, 5, 3, 4], [8, 6, 3, 2, 9], [5, 2, 6, 9, 5]], ""output"": [[2, 9, 7, 3, 8, 2, 9, 7, 3, 8, 2, 9, 7, 3, 8], [4, 3, 2, 9, 7, 4, 3, 2, 9, 7, 4, 3, 2, 9, 7], [6, 2, 5, 3, 4, 6, 2, 5, 3, 4, 6, 2, 5, 3, 4], [8, 6, 3, 2, 9, 8, 6, 3, 2, 9, 8, 6, 3, 2, 9], [5, 2, 6, 9, 5, 5, 2, 6, 9, 5, 5, 2, 6, 9, 5], [8, 9, 7, 3, 2, 8, 9, 7, 3, 2, 8, 9, 7, 3, 2], [7, 3, 2, 9, 4, 7, 3, 2, 9, 4, 7, 3, 2, 9, 4], [4, 2, 5, 3, 6, 4, 2, 5, 3, 6, 4, 2, 5, 3, 6], [9, 6, 3, 2, 8, 9, 6, 3, 2, 8, 9, 6, 3, 2, 8], [5, 2, 6, 9, 5, 5, 2, 6, 9, 5, 5, 2, 6, 9, 5], [2, 9, 7, 3, 8, 2, 9, 7, 3, 8, 2, 9, 7, 3, 8], [4, 3, 2, 9, 7, 4, 3, 2, 9, 7, 4, 3, 2, 9, 7], [6, 2, 5, 3, 4, 6, 2, 5, 3, 4, 6, 2, 5, 3, 4], [8, 6, 3, 2, 9, 8, 6, 3, 2, 9, 8, 6, 3, 2, 9], [5, 2, 6, 9, 5, 5, 2, 6, 9, 5, 5, 2, 6, 9, 5]]}, {""input"": [[2, 5, 7, 8, 5], [7, 9, 2, 3, 6], [5, 8, 7, 6, 9], [3, 2, 6, 7, 2], [9, 7, 9, 4, 8]], ""output"": [[2, 5, 7, 8, 5, 2, 5, 7, 8, 5, 2, 5, 7, 8, 5], [7, 9, 2, 3, 6, 7, 9, 2, 3, 6, 7, 9, 2, 3, 6], [5, 8, 7, 6, 9, 5, 8, 7, 6, 9, 5, 8, 7, 6, 9], [3, 2, 6, 7, 2, 3, 2, 6, 7, 2, 3, 2, 6, 7, 2], [9, 7, 9, 4, 8, 9, 7, 9, 4, 8, 9, 7, 9, 4, 8], [5, 5, 7, 8, 2, 5, 5, 7, 8, 2, 5, 5, 7, 8, 2], [6, 9, 2, 3, 7, 6, 9, 2, 3, 7, 6, 9, 2, 3, 7], [9, 8, 7, 6, 5, 9, 8, 7, 6, 5, 9, 8, 7, 6, 5], [2, 2, 6, 7, 3, 2, 2, 6, 7, 3, 2, 2, 6, 7, 3], [8, 7, 9, 4, 9, 8, 7, 9, 4, 9, 8, 7, 9, 4, 9], [2, 5, 7, 8, 5, 2, 5, 7, 8, 5, 2, 5, 7, 8, 5], [7, 9, 2, 3, 6, 7, 9, 2, 3, 6, 7, 9, 2, 3, 6], [5, 8, 7, 6, 9, 5, 8, 7, 6, 9, 5, 8, 7, 6, 9], [3, 2, 6, 7, 2, 3, 2, 6, 7, 2, 3, 2, 6, 7, 2], [9, 7, 9, 4, 8, 9, 7, 9, 4, 8, 9, 7, 9, 4, 8]]}], ""test"": [{""input"": [[7, 9, 3, 6, 4], [8, 2, 5, 7, 8], [7, 4, 3, 5, 3], [6, 3, 2, 7, 4], [4, 8, 6, 8, 9]], ""output"": [[7, 9, 3, 6, 4, 7, 9, 3, 6, 4, 7, 9, 3, 6, 4], [8, 2, 5, 7, 8, 8, 2, 5, 7, 8, 8, 2, 5, 7, 8], [7, 4, 3, 5, 3, 7, 4, 3, 5, 3, 7, 4, 3, 5, 3], [6, 3, 2, 7, 4, 6, 3, 2, 7, 4, 6, 3, 2, 7, 4], [4, 8, 6, 8, 9, 4, 8, 6, 8, 9, 4, 8, 6, 8, 9], [4, 9, 3, 6, 7, 4, 9, 3, 6, 7, 4, 9, 3, 6, 7], [8, 2, 5, 7, 8, 8, 2, 5, 7, 8, 8, 2, 5, 7, 8], [3, 4, 3, 5, 7, 3, 4, 3, 5, 7, 3, 4, 3, 5, 7], [4, 3, 2, 7, 6, 4, 3, 2, 7, 6, 4, 3, 2, 7, 6], [9, 8, 6, 8, 4, 9, 8, 6, 8, 4, 9, 8, 6, 8, 4], [7, 9, 3, 6, 4, 7, 9, 3, 6, 4, 7, 9, 3, 6, 4], [8, 2, 5, 7, 8, 8, 2, 5, 7, 8, 8, 2, 5, 7, 8], [7, 4, 3, 5, 3, 7, 4, 3, 5, 3, 7, 4, 3, 5, 3], [6, 3, 2, 7, 4, 6, 3, 2, 7, 4, 6, 3, 2, 7, 4], [4, 8, 6, 8, 9, 4, 8, 6, 8, 9, 4, 8, 6, 8, 9]]}]}"
hjTkWbidUhAUArYZNB9X46,2025-07-21T15:52:22.623570,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 9, 2], [9, 7, 3], [8, 9, 5]], ""output"": [[6, 9, 2, 6, 9, 2, 6, 9, 2], [9, 7, 3, 9, 7, 3, 9, 7, 3], [8, 9, 5, 8, 9, 5, 8, 9, 5], [2, 9, 6, 2, 9, 6, 2, 9, 6], [3, 7, 9, 3, 7, 9, 3, 7, 9], [5, 9, 8, 5, 9, 8, 5, 9, 8], [6, 9, 2, 6, 9, 2, 6, 9, 2], [9, 7, 3, 9, 7, 3, 9, 7, 3], [8, 9, 5, 8, 9, 5, 8, 9, 5]]}, {""input"": [[7, 8, 6], [2, 5, 3], [5, 7, 2]], ""output"": [[7, 8, 6, 7, 8, 6, 7, 8, 6], [2, 5, 3, 2, 5, 3, 2, 5, 3], [5, 7, 2, 5, 7, 2, 5, 7, 2], [6, 8, 7, 6, 8, 7, 6, 8, 7], [3, 5, 2, 3, 5, 2, 3, 5, 2], [2, 7, 5, 2, 7, 5, 2, 7, 5], [7, 8, 6, 7, 8, 6, 7, 8, 6], [2, 5, 3, 2, 5, 3, 2, 5, 3], [5, 7, 2, 5, 7, 2, 5, 7, 2]]}, {""input"": [[4, 7, 2], [6, 9, 3], [5, 4, 8]], ""output"": [[4, 7, 2, 4, 7, 2, 4, 7, 2], [6, 9, 3, 6, 9, 3, 6, 9, 3], [5, 4, 8, 5, 4, 8, 5, 4, 8], [2, 7, 4, 2, 7, 4, 2, 7, 4], [3, 9, 6, 3, 9, 6, 3, 9, 6], [8, 4, 5, 8, 4, 5, 8, 4, 5], [4, 7, 2, 4, 7, 2, 4, 7, 2], [6, 9, 3, 6, 9, 3, 6, 9, 3], [5, 4, 8, 5, 4, 8, 5, 4, 8]]}], ""test"": [{""input"": [[4, 6, 3], [8, 4, 2], [6, 5, 9]], ""output"": [[4, 6, 3, 4, 6, 3, 4, 6, 3], [8, 4, 2, 8, 4, 2, 8, 4, 2], [6, 5, 9, 6, 5, 9, 6, 5, 9], [3, 6, 4, 3, 6, 4, 3, 6, 4], [2, 4, 8, 2, 4, 8, 2, 4, 8], [9, 5, 6, 9, 5, 6, 9, 5, 6], [4, 6, 3, 4, 6, 3, 4, 6, 3], [8, 4, 2, 8, 4, 2, 8, 4, 2], [6, 5, 9, 6, 5, 9, 6, 5, 9]]}]}"
RnDyriCgm66e2mWDxtfsXa,2025-07-21T15:52:22.625352,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 3], [9, 4]], ""output"": [[7, 3, 7, 3, 7, 3], [9, 4, 9, 4, 9, 4], [3, 7, 3, 7, 3, 7], [4, 9, 4, 9, 4, 9], [7, 3, 7, 3, 7, 3], [9, 4, 9, 4, 9, 4]]}, {""input"": [[3, 5], [4, 8]], ""output"": [[3, 5, 3, 5, 3, 5], [4, 8, 4, 8, 4, 8], [5, 3, 5, 3, 5, 3], [8, 4, 8, 4, 8, 4], [3, 5, 3, 5, 3, 5], [4, 8, 4, 8, 4, 8]]}, {""input"": [[8, 9], [9, 1]], ""output"": [[8, 9, 8, 9, 8, 9], [9, 1, 9, 1, 9, 1], [9, 8, 9, 8, 9, 8], [1, 9, 1, 9, 1, 9], [8, 9, 8, 9, 8, 9], [9, 1, 9, 1, 9, 1]]}], ""test"": [{""input"": [[9, 3], [4, 1]], ""output"": [[9, 3, 9, 3, 9, 3], [4, 1, 4, 1, 4, 1], [3, 9, 3, 9, 3, 9], [1, 4, 1, 4, 1, 4], [9, 3, 9, 3, 9, 3], [4, 1, 4, 1, 4, 1]]}]}"
ZgrKqnYgZLAQ22U4tYuWv7,2025-07-21T15:52:22.627499,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 6, 7], [5, 4, 6], [7, 6, 4]], ""output"": [[7, 6, 7, 7, 6, 7, 7, 6, 7], [5, 4, 6, 5, 4, 6, 5, 4, 6], [7, 6, 4, 7, 6, 4, 7, 6, 4], [7, 6, 7, 7, 6, 7, 7, 6, 7], [6, 4, 5, 6, 4, 5, 6, 4, 5], [4, 6, 7, 4, 6, 7, 4, 6, 7], [7, 6, 7, 7, 6, 7, 7, 6, 7], [5, 4, 6, 5, 4, 6, 5, 4, 6], [7, 6, 4, 7, 6, 4, 7, 6, 4]]}, {""input"": [[6, 9, 5], [8, 5, 2], [6, 2, 5]], ""output"": [[6, 9, 5, 6, 9, 5, 6, 9, 5], [8, 5, 2, 8, 5, 2, 8, 5, 2], [6, 2, 5, 6, 2, 5, 6, 2, 5], [5, 9, 6, 5, 9, 6, 5, 9, 6], [2, 5, 8, 2, 5, 8, 2, 5, 8], [5, 2, 6, 5, 2, 6, 5, 2, 6], [6, 9, 5, 6, 9, 5, 6, 9, 5], [8, 5, 2, 8, 5, 2, 8, 5, 2], [6, 2, 5, 6, 2, 5, 6, 2, 5]]}, {""input"": [[5, 9, 2], [3, 2, 7], [5, 4, 9]], ""output"": [[5, 9, 2, 5, 9, 2, 5, 9, 2], [3, 2, 7, 3, 2, 7, 3, 2, 7], [5, 4, 9, 5, 4, 9, 5, 4, 9], [2, 9, 5, 2, 9, 5, 2, 9, 5], [7, 2, 3, 7, 2, 3, 7, 2, 3], [9, 4, 5, 9, 4, 5, 9, 4, 5], [5, 9, 2, 5, 9, 2, 5, 9, 2], [3, 2, 7, 3, 2, 7, 3, 2, 7], [5, 4, 9, 5, 4, 9, 5, 4, 9]]}], ""test"": [{""input"": [[5, 4, 3], [6, 3, 5], [8, 6, 7]], ""output"": [[5, 4, 3, 5, 4, 3, 5, 4, 3], [6, 3, 5, 6, 3, 5, 6, 3, 5], [8, 6, 7, 8, 6, 7, 8, 6, 7], [3, 4, 5, 3, 4, 5, 3, 4, 5], [5, 3, 6, 5, 3, 6, 5, 3, 6], [7, 6, 8, 7, 6, 8, 7, 6, 8], [5, 4, 3, 5, 4, 3, 5, 4, 3], [6, 3, 5, 6, 3, 5, 6, 3, 5], [8, 6, 7, 8, 6, 7, 8, 6, 7]]}]}"
T4eD3mLfqene3cYnxUq3yZ,2025-07-21T15:52:22.629431,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 3, 7, 6], [6, 4, 5, 2], [2, 6, 8, 9], [5, 3, 7, 3]], ""output"": [[8, 3, 7, 6, 8, 3, 7, 6, 8, 3, 7, 6], [6, 4, 5, 2, 6, 4, 5, 2, 6, 4, 5, 2], [2, 6, 8, 9, 2, 6, 8, 9, 2, 6, 8, 9], [5, 3, 7, 3, 5, 3, 7, 3, 5, 3, 7, 3], [6, 3, 7, 8, 6, 3, 7, 8, 6, 3, 7, 8], [2, 4, 5, 6, 2, 4, 5, 6, 2, 4, 5, 6], [9, 6, 8, 2, 9, 6, 8, 2, 9, 6, 8, 2], [3, 3, 7, 5, 3, 3, 7, 5, 3, 3, 7, 5], [8, 3, 7, 6, 8, 3, 7, 6, 8, 3, 7, 6], [6, 4, 5, 2, 6, 4, 5, 2, 6, 4, 5, 2], [2, 6, 8, 9, 2, 6, 8, 9, 2, 6, 8, 9], [5, 3, 7, 3, 5, 3, 7, 3, 5, 3, 7, 3]]}, {""input"": [[7, 2, 7, 2], [2, 7, 4, 7], [7, 2, 7, 4], [3, 8, 5, 7]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 4, 7, 2, 7, 4, 7, 2, 7, 4, 7], [7, 2, 7, 4, 7, 2, 7, 4, 7, 2, 7, 4], [3, 8, 5, 7, 3, 8, 5, 7, 3, 8, 5, 7], [2, 2, 7, 7, 2, 2, 7, 7, 2, 2, 7, 7], [7, 7, 4, 2, 7, 7, 4, 2, 7, 7, 4, 2], [4, 2, 7, 7, 4, 2, 7, 7, 4, 2, 7, 7], [7, 8, 5, 3, 7, 8, 5, 3, 7, 8, 5, 3], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 4, 7, 2, 7, 4, 7, 2, 7, 4, 7], [7, 2, 7, 4, 7, 2, 7, 4, 7, 2, 7, 4], [3, 8, 5, 7, 3, 8, 5, 7, 3, 8, 5, 7]]}, {""input"": [[6, 9, 8, 7], [7, 2, 4, 2], [6, 3, 6, 7], [5, 7, 2, 4]], ""output"": [[6, 9, 8, 7, 6, 9, 8, 7, 6, 9, 8, 7], [7, 2, 4, 2, 7, 2, 4, 2, 7, 2, 4, 2], [6, 3, 6, 7, 6, 3, 6, 7, 6, 3, 6, 7], [5, 7, 2, 4, 5, 7, 2, 4, 5, 7, 2, 4], [7, 9, 8, 6, 7, 9, 8, 6, 7, 9, 8, 6], [2, 2, 4, 7, 2, 2, 4, 7, 2, 2, 4, 7], [7, 3, 6, 6, 7, 3, 6, 6, 7, 3, 6, 6], [4, 7, 2, 5, 4, 7, 2, 5, 4, 7, 2, 5], [6, 9, 8, 7, 6, 9, 8, 7, 6, 9, 8, 7], [7, 2, 4, 2, 7, 2, 4, 2, 7, 2, 4, 2], [6, 3, 6, 7, 6, 3, 6, 7, 6, 3, 6, 7], [5, 7, 2, 4, 5, 7, 2, 4, 5, 7, 2, 4]]}], ""test"": [{""input"": [[8, 7, 3, 5], [6, 9, 7, 4], [7, 3, 2, 5], [8, 7, 8, 4]], ""output"": [[8, 7, 3, 5, 8, 7, 3, 5, 8, 7, 3, 5], [6, 9, 7, 4, 6, 9, 7, 4, 6, 9, 7, 4], [7, 3, 2, 5, 7, 3, 2, 5, 7, 3, 2, 5], [8, 7, 8, 4, 8, 7, 8, 4, 8, 7, 8, 4], [5, 7, 3, 8, 5, 7, 3, 8, 5, 7, 3, 8], [4, 9, 7, 6, 4, 9, 7, 6, 4, 9, 7, 6], [5, 3, 2, 7, 5, 3, 2, 7, 5, 3, 2, 7], [4, 7, 8, 8, 4, 7, 8, 8, 4, 7, 8, 8], [8, 7, 3, 5, 8, 7, 3, 5, 8, 7, 3, 5], [6, 9, 7, 4, 6, 9, 7, 4, 6, 9, 7, 4], [7, 3, 2, 5, 7, 3, 2, 5, 7, 3, 2, 5], [8, 7, 8, 4, 8, 7, 8, 4, 8, 7, 8, 4]]}]}"
7sZcjMnutfCJLaXqPaLaHA,2025-07-21T15:52:22.631255,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 6], [3, 8]], ""output"": [[8, 6, 8, 6, 8, 6], [3, 8, 3, 8, 3, 8], [6, 8, 6, 8, 6, 8], [8, 3, 8, 3, 8, 3], [8, 6, 8, 6, 8, 6], [3, 8, 3, 8, 3, 8]]}, {""input"": [[8, 7], [4, 1]], ""output"": [[8, 7, 8, 7, 8, 7], [4, 1, 4, 1, 4, 1], [7, 8, 7, 8, 7, 8], [1, 4, 1, 4, 1, 4], [8, 7, 8, 7, 8, 7], [4, 1, 4, 1, 4, 1]]}, {""input"": [[6, 8], [5, 2]], ""output"": [[6, 8, 6, 8, 6, 8], [5, 2, 5, 2, 5, 2], [8, 6, 8, 6, 8, 6], [2, 5, 2, 5, 2, 5], [6, 8, 6, 8, 6, 8], [5, 2, 5, 2, 5, 2]]}], ""test"": [{""input"": [[2, 3], [5, 2]], ""output"": [[2, 3, 2, 3, 2, 3], [5, 2, 5, 2, 5, 2], [3, 2, 3, 2, 3, 2], [2, 5, 2, 5, 2, 5], [2, 3, 2, 3, 2, 3], [5, 2, 5, 2, 5, 2]]}]}"
2rHjnrkktdjTuypyMuHp5g,2025-07-21T15:52:22.633344,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 6, 3], [2, 8, 4], [5, 4, 9]], ""output"": [[8, 6, 3, 8, 6, 3, 8, 6, 3], [2, 8, 4, 2, 8, 4, 2, 8, 4], [5, 4, 9, 5, 4, 9, 5, 4, 9], [3, 6, 8, 3, 6, 8, 3, 6, 8], [4, 8, 2, 4, 8, 2, 4, 8, 2], [9, 4, 5, 9, 4, 5, 9, 4, 5], [8, 6, 3, 8, 6, 3, 8, 6, 3], [2, 8, 4, 2, 8, 4, 2, 8, 4], [5, 4, 9, 5, 4, 9, 5, 4, 9]]}, {""input"": [[2, 7, 5], [7, 8, 3], [2, 7, 5]], ""output"": [[2, 7, 5, 2, 7, 5, 2, 7, 5], [7, 8, 3, 7, 8, 3, 7, 8, 3], [2, 7, 5, 2, 7, 5, 2, 7, 5], [5, 7, 2, 5, 7, 2, 5, 7, 2], [3, 8, 7, 3, 8, 7, 3, 8, 7], [5, 7, 2, 5, 7, 2, 5, 7, 2], [2, 7, 5, 2, 7, 5, 2, 7, 5], [7, 8, 3, 7, 8, 3, 7, 8, 3], [2, 7, 5, 2, 7, 5, 2, 7, 5]]}, {""input"": [[5, 2, 3], [4, 6, 2], [2, 5, 4]], ""output"": [[5, 2, 3, 5, 2, 3, 5, 2, 3], [4, 6, 2, 4, 6, 2, 4, 6, 2], [2, 5, 4, 2, 5, 4, 2, 5, 4], [3, 2, 5, 3, 2, 5, 3, 2, 5], [2, 6, 4, 2, 6, 4, 2, 6, 4], [4, 5, 2, 4, 5, 2, 4, 5, 2], [5, 2, 3, 5, 2, 3, 5, 2, 3], [4, 6, 2, 4, 6, 2, 4, 6, 2], [2, 5, 4, 2, 5, 4, 2, 5, 4]]}], ""test"": [{""input"": [[6, 9, 4], [8, 4, 5], [2, 6, 8]], ""output"": [[6, 9, 4, 6, 9, 4, 6, 9, 4], [8, 4, 5, 8, 4, 5, 8, 4, 5], [2, 6, 8, 2, 6, 8, 2, 6, 8], [4, 9, 6, 4, 9, 6, 4, 9, 6], [5, 4, 8, 5, 4, 8, 5, 4, 8], [8, 6, 2, 8, 6, 2, 8, 6, 2], [6, 9, 4, 6, 9, 4, 6, 9, 4], [8, 4, 5, 8, 4, 5, 8, 4, 5], [2, 6, 8, 2, 6, 8, 2, 6, 8]]}]}"
CzRvdHWo8rA3VXAH3FrFjo,2025-07-21T15:52:22.635777,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 4, 9, 8, 4, 9], [3, 9, 8, 5, 3, 8], [5, 4, 2, 8, 7, 6], [7, 3, 4, 7, 8, 4], [5, 4, 9, 2, 7, 8], [4, 7, 3, 5, 9, 2]], ""output"": [[2, 4, 9, 8, 4, 9, 2, 4, 9, 8, 4, 9, 2, 4, 9, 8, 4, 9], [3, 9, 8, 5, 3, 8, 3, 9, 8, 5, 3, 8, 3, 9, 8, 5, 3, 8], [5, 4, 2, 8, 7, 6, 5, 4, 2, 8, 7, 6, 5, 4, 2, 8, 7, 6], [7, 3, 4, 7, 8, 4, 7, 3, 4, 7, 8, 4, 7, 3, 4, 7, 8, 4], [5, 4, 9, 2, 7, 8, 5, 4, 9, 2, 7, 8, 5, 4, 9, 2, 7, 8], [4, 7, 3, 5, 9, 2, 4, 7, 3, 5, 9, 2, 4, 7, 3, 5, 9, 2], [9, 4, 9, 8, 4, 2, 9, 4, 9, 8, 4, 2, 9, 4, 9, 8, 4, 2], [8, 9, 8, 5, 3, 3, 8, 9, 8, 5, 3, 3, 8, 9, 8, 5, 3, 3], [6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7, 5], [4, 3, 4, 7, 8, 7, 4, 3, 4, 7, 8, 7, 4, 3, 4, 7, 8, 7], [8, 4, 9, 2, 7, 5, 8, 4, 9, 2, 7, 5, 8, 4, 9, 2, 7, 5], [2, 7, 3, 5, 9, 4, 2, 7, 3, 5, 9, 4, 2, 7, 3, 5, 9, 4], [2, 4, 9, 8, 4, 9, 2, 4, 9, 8, 4, 9, 2, 4, 9, 8, 4, 9], [3, 9, 8, 5, 3, 8, 3, 9, 8, 5, 3, 8, 3, 9, 8, 5, 3, 8], [5, 4, 2, 8, 7, 6, 5, 4, 2, 8, 7, 6, 5, 4, 2, 8, 7, 6], [7, 3, 4, 7, 8, 4, 7, 3, 4, 7, 8, 4, 7, 3, 4, 7, 8, 4], [5, 4, 9, 2, 7, 8, 5, 4, 9, 2, 7, 8, 5, 4, 9, 2, 7, 8], [4, 7, 3, 5, 9, 2, 4, 7, 3, 5, 9, 2, 4, 7, 3, 5, 9, 2]]}, {""input"": [[6, 7, 3, 8, 4, 3], [5, 6, 4, 2, 8, 7], [2, 8, 7, 9, 3, 5], [4, 2, 9, 3, 9, 8], [3, 7, 6, 5, 3, 9], [5, 8, 3, 2, 6, 5]], ""output"": [[6, 7, 3, 8, 4, 3, 6, 7, 3, 8, 4, 3, 6, 7, 3, 8, 4, 3], [5, 6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7], [2, 8, 7, 9, 3, 5, 2, 8, 7, 9, 3, 5, 2, 8, 7, 9, 3, 5], [4, 2, 9, 3, 9, 8, 4, 2, 9, 3, 9, 8, 4, 2, 9, 3, 9, 8], [3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9], [5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5], [3, 7, 3, 8, 4, 6, 3, 7, 3, 8, 4, 6, 3, 7, 3, 8, 4, 6], [7, 6, 4, 2, 8, 5, 7, 6, 4, 2, 8, 5, 7, 6, 4, 2, 8, 5], [5, 8, 7, 9, 3, 2, 5, 8, 7, 9, 3, 2, 5, 8, 7, 9, 3, 2], [8, 2, 9, 3, 9, 4, 8, 2, 9, 3, 9, 4, 8, 2, 9, 3, 9, 4], [9, 7, 6, 5, 3, 3, 9, 7, 6, 5, 3, 3, 9, 7, 6, 5, 3, 3], [5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5], [6, 7, 3, 8, 4, 3, 6, 7, 3, 8, 4, 3, 6, 7, 3, 8, 4, 3], [5, 6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7, 5, 6, 4, 2, 8, 7], [2, 8, 7, 9, 3, 5, 2, 8, 7, 9, 3, 5, 2, 8, 7, 9, 3, 5], [4, 2, 9, 3, 9, 8, 4, 2, 9, 3, 9, 8, 4, 2, 9, 3, 9, 8], [3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9], [5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5, 5, 8, 3, 2, 6, 5]]}, {""input"": [[2, 3, 5, 4, 2, 6], [6, 5, 8, 7, 4, 8], [7, 2, 6, 5, 9, 5], [5, 9, 7, 2, 7, 2], [3, 5, 6, 5, 3, 6], [9, 6, 2, 8, 5, 4]], ""output"": [[2, 3, 5, 4, 2, 6, 2, 3, 5, 4, 2, 6, 2, 3, 5, 4, 2, 6], [6, 5, 8, 7, 4, 8, 6, 5, 8, 7, 4, 8, 6, 5, 8, 7, 4, 8], [7, 2, 6, 5, 9, 5, 7, 2, 6, 5, 9, 5, 7, 2, 6, 5, 9, 5], [5, 9, 7, 2, 7, 2, 5, 9, 7, 2, 7, 2, 5, 9, 7, 2, 7, 2], [3, 5, 6, 5, 3, 6, 3, 5, 6, 5, 3, 6, 3, 5, 6, 5, 3, 6], [9, 6, 2, 8, 5, 4, 9, 6, 2, 8, 5, 4, 9, 6, 2, 8, 5, 4], [6, 3, 5, 4, 2, 2, 6, 3, 5, 4, 2, 2, 6, 3, 5, 4, 2, 2], [8, 5, 8, 7, 4, 6, 8, 5, 8, 7, 4, 6, 8, 5, 8, 7, 4, 6], [5, 2, 6, 5, 9, 7, 5, 2, 6, 5, 9, 7, 5, 2, 6, 5, 9, 7], [2, 9, 7, 2, 7, 5, 2, 9, 7, 2, 7, 5, 2, 9, 7, 2, 7, 5], [6, 5, 6, 5, 3, 3, 6, 5, 6, 5, 3, 3, 6, 5, 6, 5, 3, 3], [4, 6, 2, 8, 5, 9, 4, 6, 2, 8, 5, 9, 4, 6, 2, 8, 5, 9], [2, 3, 5, 4, 2, 6, 2, 3, 5, 4, 2, 6, 2, 3, 5, 4, 2, 6], [6, 5, 8, 7, 4, 8, 6, 5, 8, 7, 4, 8, 6, 5, 8, 7, 4, 8], [7, 2, 6, 5, 9, 5, 7, 2, 6, 5, 9, 5, 7, 2, 6, 5, 9, 5], [5, 9, 7, 2, 7, 2, 5, 9, 7, 2, 7, 2, 5, 9, 7, 2, 7, 2], [3, 5, 6, 5, 3, 6, 3, 5, 6, 5, 3, 6, 3, 5, 6, 5, 3, 6], [9, 6, 2, 8, 5, 4, 9, 6, 2, 8, 5, 4, 9, 6, 2, 8, 5, 4]]}], ""test"": [{""input"": [[8, 2, 6, 5, 2, 9], [9, 4, 7, 2, 4, 8], [3, 2, 9, 7, 2, 3], [9, 6, 5, 4, 3, 9], [8, 4, 3, 9, 8, 6], [3, 5, 4, 5, 7, 3]], ""output"": [[8, 2, 6, 5, 2, 9, 8, 2, 6, 5, 2, 9, 8, 2, 6, 5, 2, 9], [9, 4, 7, 2, 4, 8, 9, 4, 7, 2, 4, 8, 9, 4, 7, 2, 4, 8], [3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3], [9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9], [8, 4, 3, 9, 8, 6, 8, 4, 3, 9, 8, 6, 8, 4, 3, 9, 8, 6], [3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3], [9, 2, 6, 5, 2, 8, 9, 2, 6, 5, 2, 8, 9, 2, 6, 5, 2, 8], [8, 4, 7, 2, 4, 9, 8, 4, 7, 2, 4, 9, 8, 4, 7, 2, 4, 9], [3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3], [9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9], [6, 4, 3, 9, 8, 8, 6, 4, 3, 9, 8, 8, 6, 4, 3, 9, 8, 8], [3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3], [8, 2, 6, 5, 2, 9, 8, 2, 6, 5, 2, 9, 8, 2, 6, 5, 2, 9], [9, 4, 7, 2, 4, 8, 9, 4, 7, 2, 4, 8, 9, 4, 7, 2, 4, 8], [3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3, 3, 2, 9, 7, 2, 3], [9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9, 9, 6, 5, 4, 3, 9], [8, 4, 3, 9, 8, 6, 8, 4, 3, 9, 8, 6, 8, 4, 3, 9, 8, 6], [3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3, 3, 5, 4, 5, 7, 3]]}]}"
ha9ZPgHQniT6aMrSQfcLMz,2025-07-21T15:52:22.637945,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 6, 8, 3], [7, 9, 7, 5], [3, 5, 9, 7], [7, 3, 8, 5]], ""output"": [[8, 6, 8, 3, 8, 6, 8, 3, 8, 6, 8, 3], [7, 9, 7, 5, 7, 9, 7, 5, 7, 9, 7, 5], [3, 5, 9, 7, 3, 5, 9, 7, 3, 5, 9, 7], [7, 3, 8, 5, 7, 3, 8, 5, 7, 3, 8, 5], [3, 6, 8, 8, 3, 6, 8, 8, 3, 6, 8, 8], [5, 9, 7, 7, 5, 9, 7, 7, 5, 9, 7, 7], [7, 5, 9, 3, 7, 5, 9, 3, 7, 5, 9, 3], [5, 3, 8, 7, 5, 3, 8, 7, 5, 3, 8, 7], [8, 6, 8, 3, 8, 6, 8, 3, 8, 6, 8, 3], [7, 9, 7, 5, 7, 9, 7, 5, 7, 9, 7, 5], [3, 5, 9, 7, 3, 5, 9, 7, 3, 5, 9, 7], [7, 3, 8, 5, 7, 3, 8, 5, 7, 3, 8, 5]]}, {""input"": [[6, 5, 2, 5], [8, 3, 5, 3], [5, 8, 7, 4], [4, 2, 6, 8]], ""output"": [[6, 5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5], [8, 3, 5, 3, 8, 3, 5, 3, 8, 3, 5, 3], [5, 8, 7, 4, 5, 8, 7, 4, 5, 8, 7, 4], [4, 2, 6, 8, 4, 2, 6, 8, 4, 2, 6, 8], [5, 5, 2, 6, 5, 5, 2, 6, 5, 5, 2, 6], [3, 3, 5, 8, 3, 3, 5, 8, 3, 3, 5, 8], [4, 8, 7, 5, 4, 8, 7, 5, 4, 8, 7, 5], [8, 2, 6, 4, 8, 2, 6, 4, 8, 2, 6, 4], [6, 5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5], [8, 3, 5, 3, 8, 3, 5, 3, 8, 3, 5, 3], [5, 8, 7, 4, 5, 8, 7, 4, 5, 8, 7, 4], [4, 2, 6, 8, 4, 2, 6, 8, 4, 2, 6, 8]]}, {""input"": [[4, 9, 3, 9], [9, 8, 4, 7], [2, 4, 8, 6], [9, 3, 5, 2]], ""output"": [[4, 9, 3, 9, 4, 9, 3, 9, 4, 9, 3, 9], [9, 8, 4, 7, 9, 8, 4, 7, 9, 8, 4, 7], [2, 4, 8, 6, 2, 4, 8, 6, 2, 4, 8, 6], [9, 3, 5, 2, 9, 3, 5, 2, 9, 3, 5, 2], [9, 9, 3, 4, 9, 9, 3, 4, 9, 9, 3, 4], [7, 8, 4, 9, 7, 8, 4, 9, 7, 8, 4, 9], [6, 4, 8, 2, 6, 4, 8, 2, 6, 4, 8, 2], [2, 3, 5, 9, 2, 3, 5, 9, 2, 3, 5, 9], [4, 9, 3, 9, 4, 9, 3, 9, 4, 9, 3, 9], [9, 8, 4, 7, 9, 8, 4, 7, 9, 8, 4, 7], [2, 4, 8, 6, 2, 4, 8, 6, 2, 4, 8, 6], [9, 3, 5, 2, 9, 3, 5, 2, 9, 3, 5, 2]]}], ""test"": [{""input"": [[7, 5, 3, 6], [8, 7, 4, 2], [9, 2, 8, 4], [7, 3, 4, 3]], ""output"": [[7, 5, 3, 6, 7, 5, 3, 6, 7, 5, 3, 6], [8, 7, 4, 2, 8, 7, 4, 2, 8, 7, 4, 2], [9, 2, 8, 4, 9, 2, 8, 4, 9, 2, 8, 4], [7, 3, 4, 3, 7, 3, 4, 3, 7, 3, 4, 3], [6, 5, 3, 7, 6, 5, 3, 7, 6, 5, 3, 7], [2, 7, 4, 8, 2, 7, 4, 8, 2, 7, 4, 8], [4, 2, 8, 9, 4, 2, 8, 9, 4, 2, 8, 9], [3, 3, 4, 7, 3, 3, 4, 7, 3, 3, 4, 7], [7, 5, 3, 6, 7, 5, 3, 6, 7, 5, 3, 6], [8, 7, 4, 2, 8, 7, 4, 2, 8, 7, 4, 2], [9, 2, 8, 4, 9, 2, 8, 4, 9, 2, 8, 4], [7, 3, 4, 3, 7, 3, 4, 3, 7, 3, 4, 3]]}]}"
KuT45gzi5pzBGFvK2aYQSz,2025-07-21T15:52:22.639976,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 8, 7, 5], [5, 2, 8, 4], [3, 8, 3, 8], [5, 6, 7, 2]], ""output"": [[6, 8, 7, 5, 6, 8, 7, 5, 6, 8, 7, 5], [5, 2, 8, 4, 5, 2, 8, 4, 5, 2, 8, 4], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [5, 6, 7, 2, 5, 6, 7, 2, 5, 6, 7, 2], [5, 8, 7, 6, 5, 8, 7, 6, 5, 8, 7, 6], [4, 2, 8, 5, 4, 2, 8, 5, 4, 2, 8, 5], [8, 8, 3, 3, 8, 8, 3, 3, 8, 8, 3, 3], [2, 6, 7, 5, 2, 6, 7, 5, 2, 6, 7, 5], [6, 8, 7, 5, 6, 8, 7, 5, 6, 8, 7, 5], [5, 2, 8, 4, 5, 2, 8, 4, 5, 2, 8, 4], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [5, 6, 7, 2, 5, 6, 7, 2, 5, 6, 7, 2]]}, {""input"": [[8, 7, 5, 2], [4, 6, 7, 8], [6, 2, 9, 3], [4, 8, 3, 6]], ""output"": [[8, 7, 5, 2, 8, 7, 5, 2, 8, 7, 5, 2], [4, 6, 7, 8, 4, 6, 7, 8, 4, 6, 7, 8], [6, 2, 9, 3, 6, 2, 9, 3, 6, 2, 9, 3], [4, 8, 3, 6, 4, 8, 3, 6, 4, 8, 3, 6], [2, 7, 5, 8, 2, 7, 5, 8, 2, 7, 5, 8], [8, 6, 7, 4, 8, 6, 7, 4, 8, 6, 7, 4], [3, 2, 9, 6, 3, 2, 9, 6, 3, 2, 9, 6], [6, 8, 3, 4, 6, 8, 3, 4, 6, 8, 3, 4], [8, 7, 5, 2, 8, 7, 5, 2, 8, 7, 5, 2], [4, 6, 7, 8, 4, 6, 7, 8, 4, 6, 7, 8], [6, 2, 9, 3, 6, 2, 9, 3, 6, 2, 9, 3], [4, 8, 3, 6, 4, 8, 3, 6, 4, 8, 3, 6]]}, {""input"": [[9, 7, 5, 9], [4, 8, 7, 6], [2, 4, 5, 4], [9, 8, 7, 5]], ""output"": [[9, 7, 5, 9, 9, 7, 5, 9, 9, 7, 5, 9], [4, 8, 7, 6, 4, 8, 7, 6, 4, 8, 7, 6], [2, 4, 5, 4, 2, 4, 5, 4, 2, 4, 5, 4], [9, 8, 7, 5, 9, 8, 7, 5, 9, 8, 7, 5], [9, 7, 5, 9, 9, 7, 5, 9, 9, 7, 5, 9], [6, 8, 7, 4, 6, 8, 7, 4, 6, 8, 7, 4], [4, 4, 5, 2, 4, 4, 5, 2, 4, 4, 5, 2], [5, 8, 7, 9, 5, 8, 7, 9, 5, 8, 7, 9], [9, 7, 5, 9, 9, 7, 5, 9, 9, 7, 5, 9], [4, 8, 7, 6, 4, 8, 7, 6, 4, 8, 7, 6], [2, 4, 5, 4, 2, 4, 5, 4, 2, 4, 5, 4], [9, 8, 7, 5, 9, 8, 7, 5, 9, 8, 7, 5]]}], ""test"": [{""input"": [[9, 8, 6, 5], [6, 7, 5, 4], [9, 8, 3, 5], [8, 3, 2, 3]], ""output"": [[9, 8, 6, 5, 9, 8, 6, 5, 9, 8, 6, 5], [6, 7, 5, 4, 6, 7, 5, 4, 6, 7, 5, 4], [9, 8, 3, 5, 9, 8, 3, 5, 9, 8, 3, 5], [8, 3, 2, 3, 8, 3, 2, 3, 8, 3, 2, 3], [5, 8, 6, 9, 5, 8, 6, 9, 5, 8, 6, 9], [4, 7, 5, 6, 4, 7, 5, 6, 4, 7, 5, 6], [5, 8, 3, 9, 5, 8, 3, 9, 5, 8, 3, 9], [3, 3, 2, 8, 3, 3, 2, 8, 3, 3, 2, 8], [9, 8, 6, 5, 9, 8, 6, 5, 9, 8, 6, 5], [6, 7, 5, 4, 6, 7, 5, 4, 6, 7, 5, 4], [9, 8, 3, 5, 9, 8, 3, 5, 9, 8, 3, 5], [8, 3, 2, 3, 8, 3, 2, 3, 8, 3, 2, 3]]}]}"
GvYAGafvrJmtd7uLs4i5m4,2025-07-21T15:52:22.644256,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 9, 2, 9, 5, 2, 6], [5, 6, 3, 5, 6, 7, 4], [4, 3, 2, 3, 7, 2, 8], [8, 4, 9, 2, 4, 9, 5], [3, 6, 4, 7, 5, 4, 8], [7, 8, 3, 6, 3, 7, 6], [9, 3, 7, 5, 7, 8, 9]], ""output"": [[2, 9, 2, 9, 5, 2, 6, 2, 9, 2, 9, 5, 2, 6, 2, 9, 2, 9, 5, 2, 6], [5, 6, 3, 5, 6, 7, 4, 5, 6, 3, 5, 6, 7, 4, 5, 6, 3, 5, 6, 7, 4], [4, 3, 2, 3, 7, 2, 8, 4, 3, 2, 3, 7, 2, 8, 4, 3, 2, 3, 7, 2, 8], [8, 4, 9, 2, 4, 9, 5, 8, 4, 9, 2, 4, 9, 5, 8, 4, 9, 2, 4, 9, 5], [3, 6, 4, 7, 5, 4, 8, 3, 6, 4, 7, 5, 4, 8, 3, 6, 4, 7, 5, 4, 8], [7, 8, 3, 6, 3, 7, 6, 7, 8, 3, 6, 3, 7, 6, 7, 8, 3, 6, 3, 7, 6], [9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9], [6, 9, 2, 9, 5, 2, 2, 6, 9, 2, 9, 5, 2, 2, 6, 9, 2, 9, 5, 2, 2], [4, 6, 3, 5, 6, 7, 5, 4, 6, 3, 5, 6, 7, 5, 4, 6, 3, 5, 6, 7, 5], [8, 3, 2, 3, 7, 2, 4, 8, 3, 2, 3, 7, 2, 4, 8, 3, 2, 3, 7, 2, 4], [5, 4, 9, 2, 4, 9, 8, 5, 4, 9, 2, 4, 9, 8, 5, 4, 9, 2, 4, 9, 8], [8, 6, 4, 7, 5, 4, 3, 8, 6, 4, 7, 5, 4, 3, 8, 6, 4, 7, 5, 4, 3], [6, 8, 3, 6, 3, 7, 7, 6, 8, 3, 6, 3, 7, 7, 6, 8, 3, 6, 3, 7, 7], [9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9], [2, 9, 2, 9, 5, 2, 6, 2, 9, 2, 9, 5, 2, 6, 2, 9, 2, 9, 5, 2, 6], [5, 6, 3, 5, 6, 7, 4, 5, 6, 3, 5, 6, 7, 4, 5, 6, 3, 5, 6, 7, 4], [4, 3, 2, 3, 7, 2, 8, 4, 3, 2, 3, 7, 2, 8, 4, 3, 2, 3, 7, 2, 8], [8, 4, 9, 2, 4, 9, 5, 8, 4, 9, 2, 4, 9, 5, 8, 4, 9, 2, 4, 9, 5], [3, 6, 4, 7, 5, 4, 8, 3, 6, 4, 7, 5, 4, 8, 3, 6, 4, 7, 5, 4, 8], [7, 8, 3, 6, 3, 7, 6, 7, 8, 3, 6, 3, 7, 6, 7, 8, 3, 6, 3, 7, 6], [9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9, 9, 3, 7, 5, 7, 8, 9]]}, {""input"": [[6, 3, 4, 2, 3, 5, 4], [7, 6, 7, 3, 5, 2, 3], [4, 2, 3, 6, 7, 8, 7], [2, 3, 7, 5, 3, 5, 2], [3, 9, 8, 3, 7, 4, 9], [7, 8, 2, 7, 3, 2, 7], [9, 3, 5, 4, 7, 5, 9]], ""output"": [[6, 3, 4, 2, 3, 5, 4, 6, 3, 4, 2, 3, 5, 4, 6, 3, 4, 2, 3, 5, 4], [7, 6, 7, 3, 5, 2, 3, 7, 6, 7, 3, 5, 2, 3, 7, 6, 7, 3, 5, 2, 3], [4, 2, 3, 6, 7, 8, 7, 4, 2, 3, 6, 7, 8, 7, 4, 2, 3, 6, 7, 8, 7], [2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2], [3, 9, 8, 3, 7, 4, 9, 3, 9, 8, 3, 7, 4, 9, 3, 9, 8, 3, 7, 4, 9], [7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7], [9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9], [4, 3, 4, 2, 3, 5, 6, 4, 3, 4, 2, 3, 5, 6, 4, 3, 4, 2, 3, 5, 6], [3, 6, 7, 3, 5, 2, 7, 3, 6, 7, 3, 5, 2, 7, 3, 6, 7, 3, 5, 2, 7], [7, 2, 3, 6, 7, 8, 4, 7, 2, 3, 6, 7, 8, 4, 7, 2, 3, 6, 7, 8, 4], [2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2], [9, 9, 8, 3, 7, 4, 3, 9, 9, 8, 3, 7, 4, 3, 9, 9, 8, 3, 7, 4, 3], [7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7], [9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9], [6, 3, 4, 2, 3, 5, 4, 6, 3, 4, 2, 3, 5, 4, 6, 3, 4, 2, 3, 5, 4], [7, 6, 7, 3, 5, 2, 3, 7, 6, 7, 3, 5, 2, 3, 7, 6, 7, 3, 5, 2, 3], [4, 2, 3, 6, 7, 8, 7, 4, 2, 3, 6, 7, 8, 7, 4, 2, 3, 6, 7, 8, 7], [2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2, 2, 3, 7, 5, 3, 5, 2], [3, 9, 8, 3, 7, 4, 9, 3, 9, 8, 3, 7, 4, 9, 3, 9, 8, 3, 7, 4, 9], [7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7, 7, 8, 2, 7, 3, 2, 7], [9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9, 9, 3, 5, 4, 7, 5, 9]]}, {""input"": [[6, 3, 7, 5, 4, 3, 4], [8, 5, 8, 7, 3, 7, 2], [3, 6, 3, 8, 6, 4, 3], [6, 5, 7, 2, 3, 9, 7], [9, 4, 2, 8, 6, 2, 4], [4, 6, 9, 6, 3, 9, 5], [9, 3, 6, 8, 2, 8, 4]], ""output"": [[6, 3, 7, 5, 4, 3, 4, 6, 3, 7, 5, 4, 3, 4, 6, 3, 7, 5, 4, 3, 4], [8, 5, 8, 7, 3, 7, 2, 8, 5, 8, 7, 3, 7, 2, 8, 5, 8, 7, 3, 7, 2], [3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3], [6, 5, 7, 2, 3, 9, 7, 6, 5, 7, 2, 3, 9, 7, 6, 5, 7, 2, 3, 9, 7], [9, 4, 2, 8, 6, 2, 4, 9, 4, 2, 8, 6, 2, 4, 9, 4, 2, 8, 6, 2, 4], [4, 6, 9, 6, 3, 9, 5, 4, 6, 9, 6, 3, 9, 5, 4, 6, 9, 6, 3, 9, 5], [9, 3, 6, 8, 2, 8, 4, 9, 3, 6, 8, 2, 8, 4, 9, 3, 6, 8, 2, 8, 4], [4, 3, 7, 5, 4, 3, 6, 4, 3, 7, 5, 4, 3, 6, 4, 3, 7, 5, 4, 3, 6], [2, 5, 8, 7, 3, 7, 8, 2, 5, 8, 7, 3, 7, 8, 2, 5, 8, 7, 3, 7, 8], [3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3], [7, 5, 7, 2, 3, 9, 6, 7, 5, 7, 2, 3, 9, 6, 7, 5, 7, 2, 3, 9, 6], [4, 4, 2, 8, 6, 2, 9, 4, 4, 2, 8, 6, 2, 9, 4, 4, 2, 8, 6, 2, 9], [5, 6, 9, 6, 3, 9, 4, 5, 6, 9, 6, 3, 9, 4, 5, 6, 9, 6, 3, 9, 4], [4, 3, 6, 8, 2, 8, 9, 4, 3, 6, 8, 2, 8, 9, 4, 3, 6, 8, 2, 8, 9], [6, 3, 7, 5, 4, 3, 4, 6, 3, 7, 5, 4, 3, 4, 6, 3, 7, 5, 4, 3, 4], [8, 5, 8, 7, 3, 7, 2, 8, 5, 8, 7, 3, 7, 2, 8, 5, 8, 7, 3, 7, 2], [3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3, 3, 6, 3, 8, 6, 4, 3], [6, 5, 7, 2, 3, 9, 7, 6, 5, 7, 2, 3, 9, 7, 6, 5, 7, 2, 3, 9, 7], [9, 4, 2, 8, 6, 2, 4, 9, 4, 2, 8, 6, 2, 4, 9, 4, 2, 8, 6, 2, 4], [4, 6, 9, 6, 3, 9, 5, 4, 6, 9, 6, 3, 9, 5, 4, 6, 9, 6, 3, 9, 5], [9, 3, 6, 8, 2, 8, 4, 9, 3, 6, 8, 2, 8, 4, 9, 3, 6, 8, 2, 8, 4]]}], ""test"": [{""input"": [[2, 4, 3, 5, 4, 6, 5], [3, 8, 2, 7, 3, 5, 3], [6, 3, 5, 2, 5, 6, 9], [4, 8, 9, 8, 9, 2, 7], [9, 2, 5, 6, 8, 5, 3], [3, 9, 8, 2, 7, 4, 2], [6, 3, 4, 9, 4, 8, 1]], ""output"": [[2, 4, 3, 5, 4, 6, 5, 2, 4, 3, 5, 4, 6, 5, 2, 4, 3, 5, 4, 6, 5], [3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3], [6, 3, 5, 2, 5, 6, 9, 6, 3, 5, 2, 5, 6, 9, 6, 3, 5, 2, 5, 6, 9], [4, 8, 9, 8, 9, 2, 7, 4, 8, 9, 8, 9, 2, 7, 4, 8, 9, 8, 9, 2, 7], [9, 2, 5, 6, 8, 5, 3, 9, 2, 5, 6, 8, 5, 3, 9, 2, 5, 6, 8, 5, 3], [3, 9, 8, 2, 7, 4, 2, 3, 9, 8, 2, 7, 4, 2, 3, 9, 8, 2, 7, 4, 2], [6, 3, 4, 9, 4, 8, 1, 6, 3, 4, 9, 4, 8, 1, 6, 3, 4, 9, 4, 8, 1], [5, 4, 3, 5, 4, 6, 2, 5, 4, 3, 5, 4, 6, 2, 5, 4, 3, 5, 4, 6, 2], [3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3], [9, 3, 5, 2, 5, 6, 6, 9, 3, 5, 2, 5, 6, 6, 9, 3, 5, 2, 5, 6, 6], [7, 8, 9, 8, 9, 2, 4, 7, 8, 9, 8, 9, 2, 4, 7, 8, 9, 8, 9, 2, 4], [3, 2, 5, 6, 8, 5, 9, 3, 2, 5, 6, 8, 5, 9, 3, 2, 5, 6, 8, 5, 9], [2, 9, 8, 2, 7, 4, 3, 2, 9, 8, 2, 7, 4, 3, 2, 9, 8, 2, 7, 4, 3], [1, 3, 4, 9, 4, 8, 6, 1, 3, 4, 9, 4, 8, 6, 1, 3, 4, 9, 4, 8, 6], [2, 4, 3, 5, 4, 6, 5, 2, 4, 3, 5, 4, 6, 5, 2, 4, 3, 5, 4, 6, 5], [3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3, 3, 8, 2, 7, 3, 5, 3], [6, 3, 5, 2, 5, 6, 9, 6, 3, 5, 2, 5, 6, 9, 6, 3, 5, 2, 5, 6, 9], [4, 8, 9, 8, 9, 2, 7, 4, 8, 9, 8, 9, 2, 7, 4, 8, 9, 8, 9, 2, 7], [9, 2, 5, 6, 8, 5, 3, 9, 2, 5, 6, 8, 5, 3, 9, 2, 5, 6, 8, 5, 3], [3, 9, 8, 2, 7, 4, 2, 3, 9, 8, 2, 7, 4, 2, 3, 9, 8, 2, 7, 4, 2], [6, 3, 4, 9, 4, 8, 1, 6, 3, 4, 9, 4, 8, 1, 6, 3, 4, 9, 4, 8, 1]]}]}"
bArv83RouXuGs9sjqz3Xqw,2025-07-21T15:52:22.648257,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 8, 7, 5], [4, 6, 4, 8], [6, 3, 8, 9], [7, 5, 4, 1]], ""output"": [[7, 8, 7, 5, 7, 8, 7, 5, 7, 8, 7, 5], [4, 6, 4, 8, 4, 6, 4, 8, 4, 6, 4, 8], [6, 3, 8, 9, 6, 3, 8, 9, 6, 3, 8, 9], [7, 5, 4, 1, 7, 5, 4, 1, 7, 5, 4, 1], [5, 8, 7, 7, 5, 8, 7, 7, 5, 8, 7, 7], [8, 6, 4, 4, 8, 6, 4, 4, 8, 6, 4, 4], [9, 3, 8, 6, 9, 3, 8, 6, 9, 3, 8, 6], [1, 5, 4, 7, 1, 5, 4, 7, 1, 5, 4, 7], [7, 8, 7, 5, 7, 8, 7, 5, 7, 8, 7, 5], [4, 6, 4, 8, 4, 6, 4, 8, 4, 6, 4, 8], [6, 3, 8, 9, 6, 3, 8, 9, 6, 3, 8, 9], [7, 5, 4, 1, 7, 5, 4, 1, 7, 5, 4, 1]]}, {""input"": [[9, 2, 6, 8], [8, 5, 8, 2], [9, 3, 6, 5], [5, 2, 3, 9]], ""output"": [[9, 2, 6, 8, 9, 2, 6, 8, 9, 2, 6, 8], [8, 5, 8, 2, 8, 5, 8, 2, 8, 5, 8, 2], [9, 3, 6, 5, 9, 3, 6, 5, 9, 3, 6, 5], [5, 2, 3, 9, 5, 2, 3, 9, 5, 2, 3, 9], [8, 2, 6, 9, 8, 2, 6, 9, 8, 2, 6, 9], [2, 5, 8, 8, 2, 5, 8, 8, 2, 5, 8, 8], [5, 3, 6, 9, 5, 3, 6, 9, 5, 3, 6, 9], [9, 2, 3, 5, 9, 2, 3, 5, 9, 2, 3, 5], [9, 2, 6, 8, 9, 2, 6, 8, 9, 2, 6, 8], [8, 5, 8, 2, 8, 5, 8, 2, 8, 5, 8, 2], [9, 3, 6, 5, 9, 3, 6, 5, 9, 3, 6, 5], [5, 2, 3, 9, 5, 2, 3, 9, 5, 2, 3, 9]]}, {""input"": [[8, 5, 9, 8], [7, 6, 3, 7], [9, 4, 9, 5], [7, 5, 6, 1]], ""output"": [[8, 5, 9, 8, 8, 5, 9, 8, 8, 5, 9, 8], [7, 6, 3, 7, 7, 6, 3, 7, 7, 6, 3, 7], [9, 4, 9, 5, 9, 4, 9, 5, 9, 4, 9, 5], [7, 5, 6, 1, 7, 5, 6, 1, 7, 5, 6, 1], [8, 5, 9, 8, 8, 5, 9, 8, 8, 5, 9, 8], [7, 6, 3, 7, 7, 6, 3, 7, 7, 6, 3, 7], [5, 4, 9, 9, 5, 4, 9, 9, 5, 4, 9, 9], [1, 5, 6, 7, 1, 5, 6, 7, 1, 5, 6, 7], [8, 5, 9, 8, 8, 5, 9, 8, 8, 5, 9, 8], [7, 6, 3, 7, 7, 6, 3, 7, 7, 6, 3, 7], [9, 4, 9, 5, 9, 4, 9, 5, 9, 4, 9, 5], [7, 5, 6, 1, 7, 5, 6, 1, 7, 5, 6, 1]]}], ""test"": [{""input"": [[9, 8, 5, 6], [8, 2, 9, 4], [7, 3, 7, 6], [8, 6, 9, 2]], ""output"": [[9, 8, 5, 6, 9, 8, 5, 6, 9, 8, 5, 6], [8, 2, 9, 4, 8, 2, 9, 4, 8, 2, 9, 4], [7, 3, 7, 6, 7, 3, 7, 6, 7, 3, 7, 6], [8, 6, 9, 2, 8, 6, 9, 2, 8, 6, 9, 2], [6, 8, 5, 9, 6, 8, 5, 9, 6, 8, 5, 9], [4, 2, 9, 8, 4, 2, 9, 8, 4, 2, 9, 8], [6, 3, 7, 7, 6, 3, 7, 7, 6, 3, 7, 7], [2, 6, 9, 8, 2, 6, 9, 8, 2, 6, 9, 8], [9, 8, 5, 6, 9, 8, 5, 6, 9, 8, 5, 6], [8, 2, 9, 4, 8, 2, 9, 4, 8, 2, 9, 4], [7, 3, 7, 6, 7, 3, 7, 6, 7, 3, 7, 6], [8, 6, 9, 2, 8, 6, 9, 2, 8, 6, 9, 2]]}]}"
4cnRTVS9RpvxksebanaKtz,2025-07-21T15:52:22.651121,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 5], [8, 2]], ""output"": [[2, 5, 2, 5, 2, 5], [8, 2, 8, 2, 8, 2], [5, 2, 5, 2, 5, 2], [2, 8, 2, 8, 2, 8], [2, 5, 2, 5, 2, 5], [8, 2, 8, 2, 8, 2]]}, {""input"": [[2, 5], [4, 2]], ""output"": [[2, 5, 2, 5, 2, 5], [4, 2, 4, 2, 4, 2], [5, 2, 5, 2, 5, 2], [2, 4, 2, 4, 2, 4], [2, 5, 2, 5, 2, 5], [4, 2, 4, 2, 4, 2]]}, {""input"": [[7, 2], [6, 1]], ""output"": [[7, 2, 7, 2, 7, 2], [6, 1, 6, 1, 6, 1], [2, 7, 2, 7, 2, 7], [1, 6, 1, 6, 1, 6], [7, 2, 7, 2, 7, 2], [6, 1, 6, 1, 6, 1]]}], ""test"": [{""input"": [[2, 6], [4, 7]], ""output"": [[2, 6, 2, 6, 2, 6], [4, 7, 4, 7, 4, 7], [6, 2, 6, 2, 6, 2], [7, 4, 7, 4, 7, 4], [2, 6, 2, 6, 2, 6], [4, 7, 4, 7, 4, 7]]}]}"
X7AtWDyH8RXANL54Sjj7pQ,2025-07-21T15:52:22.653841,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 9, 6], [9, 3, 4], [6, 4, 3]], ""output"": [[3, 9, 6, 3, 9, 6, 3, 9, 6], [9, 3, 4, 9, 3, 4, 9, 3, 4], [6, 4, 3, 6, 4, 3, 6, 4, 3], [6, 9, 3, 6, 9, 3, 6, 9, 3], [4, 3, 9, 4, 3, 9, 4, 3, 9], [3, 4, 6, 3, 4, 6, 3, 4, 6], [3, 9, 6, 3, 9, 6, 3, 9, 6], [9, 3, 4, 9, 3, 4, 9, 3, 4], [6, 4, 3, 6, 4, 3, 6, 4, 3]]}, {""input"": [[5, 2, 3], [9, 3, 5], [4, 6, 8]], ""output"": [[5, 2, 3, 5, 2, 3, 5, 2, 3], [9, 3, 5, 9, 3, 5, 9, 3, 5], [4, 6, 8, 4, 6, 8, 4, 6, 8], [3, 2, 5, 3, 2, 5, 3, 2, 5], [5, 3, 9, 5, 3, 9, 5, 3, 9], [8, 6, 4, 8, 6, 4, 8, 6, 4], [5, 2, 3, 5, 2, 3, 5, 2, 3], [9, 3, 5, 9, 3, 5, 9, 3, 5], [4, 6, 8, 4, 6, 8, 4, 6, 8]]}, {""input"": [[5, 3, 5], [4, 5, 4], [6, 8, 1]], ""output"": [[5, 3, 5, 5, 3, 5, 5, 3, 5], [4, 5, 4, 4, 5, 4, 4, 5, 4], [6, 8, 1, 6, 8, 1, 6, 8, 1], [5, 3, 5, 5, 3, 5, 5, 3, 5], [4, 5, 4, 4, 5, 4, 4, 5, 4], [1, 8, 6, 1, 8, 6, 1, 8, 6], [5, 3, 5, 5, 3, 5, 5, 3, 5], [4, 5, 4, 4, 5, 4, 4, 5, 4], [6, 8, 1, 6, 8, 1, 6, 8, 1]]}], ""test"": [{""input"": [[4, 2, 8], [3, 6, 3], [5, 8, 4]], ""output"": [[4, 2, 8, 4, 2, 8, 4, 2, 8], [3, 6, 3, 3, 6, 3, 3, 6, 3], [5, 8, 4, 5, 8, 4, 5, 8, 4], [8, 2, 4, 8, 2, 4, 8, 2, 4], [3, 6, 3, 3, 6, 3, 3, 6, 3], [4, 8, 5, 4, 8, 5, 4, 8, 5], [4, 2, 8, 4, 2, 8, 4, 2, 8], [3, 6, 3, 3, 6, 3, 3, 6, 3], [5, 8, 4, 5, 8, 4, 5, 8, 4]]}]}"
h33vrCa5QZrJer6BGrpuLv,2025-07-21T15:52:22.657324,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 3, 4, 9, 8, 4], [9, 5, 9, 2, 3, 8], [3, 6, 7, 8, 7, 9], [6, 9, 8, 6, 4, 3], [7, 8, 4, 5, 3, 8], [6, 4, 5, 4, 5, 9]], ""output"": [[6, 3, 4, 9, 8, 4, 6, 3, 4, 9, 8, 4, 6, 3, 4, 9, 8, 4], [9, 5, 9, 2, 3, 8, 9, 5, 9, 2, 3, 8, 9, 5, 9, 2, 3, 8], [3, 6, 7, 8, 7, 9, 3, 6, 7, 8, 7, 9, 3, 6, 7, 8, 7, 9], [6, 9, 8, 6, 4, 3, 6, 9, 8, 6, 4, 3, 6, 9, 8, 6, 4, 3], [7, 8, 4, 5, 3, 8, 7, 8, 4, 5, 3, 8, 7, 8, 4, 5, 3, 8], [6, 4, 5, 4, 5, 9, 6, 4, 5, 4, 5, 9, 6, 4, 5, 4, 5, 9], [4, 3, 4, 9, 8, 6, 4, 3, 4, 9, 8, 6, 4, 3, 4, 9, 8, 6], [8, 5, 9, 2, 3, 9, 8, 5, 9, 2, 3, 9, 8, 5, 9, 2, 3, 9], [9, 6, 7, 8, 7, 3, 9, 6, 7, 8, 7, 3, 9, 6, 7, 8, 7, 3], [3, 9, 8, 6, 4, 6, 3, 9, 8, 6, 4, 6, 3, 9, 8, 6, 4, 6], [8, 8, 4, 5, 3, 7, 8, 8, 4, 5, 3, 7, 8, 8, 4, 5, 3, 7], [9, 4, 5, 4, 5, 6, 9, 4, 5, 4, 5, 6, 9, 4, 5, 4, 5, 6], [6, 3, 4, 9, 8, 4, 6, 3, 4, 9, 8, 4, 6, 3, 4, 9, 8, 4], [9, 5, 9, 2, 3, 8, 9, 5, 9, 2, 3, 8, 9, 5, 9, 2, 3, 8], [3, 6, 7, 8, 7, 9, 3, 6, 7, 8, 7, 9, 3, 6, 7, 8, 7, 9], [6, 9, 8, 6, 4, 3, 6, 9, 8, 6, 4, 3, 6, 9, 8, 6, 4, 3], [7, 8, 4, 5, 3, 8, 7, 8, 4, 5, 3, 8, 7, 8, 4, 5, 3, 8], [6, 4, 5, 4, 5, 9, 6, 4, 5, 4, 5, 9, 6, 4, 5, 4, 5, 9]]}, {""input"": [[8, 9, 5, 4, 2, 5], [6, 7, 9, 2, 5, 8], [5, 8, 2, 4, 9, 5], [6, 5, 8, 2, 4, 6], [7, 8, 5, 9, 2, 7], [9, 4, 8, 4, 3, 2]], ""output"": [[8, 9, 5, 4, 2, 5, 8, 9, 5, 4, 2, 5, 8, 9, 5, 4, 2, 5], [6, 7, 9, 2, 5, 8, 6, 7, 9, 2, 5, 8, 6, 7, 9, 2, 5, 8], [5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5], [6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6], [7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7], [9, 4, 8, 4, 3, 2, 9, 4, 8, 4, 3, 2, 9, 4, 8, 4, 3, 2], [5, 9, 5, 4, 2, 8, 5, 9, 5, 4, 2, 8, 5, 9, 5, 4, 2, 8], [8, 7, 9, 2, 5, 6, 8, 7, 9, 2, 5, 6, 8, 7, 9, 2, 5, 6], [5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5], [6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6], [7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7], [2, 4, 8, 4, 3, 9, 2, 4, 8, 4, 3, 9, 2, 4, 8, 4, 3, 9], [8, 9, 5, 4, 2, 5, 8, 9, 5, 4, 2, 5, 8, 9, 5, 4, 2, 5], [6, 7, 9, 2, 5, 8, 6, 7, 9, 2, 5, 8, 6, 7, 9, 2, 5, 8], [5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5, 5, 8, 2, 4, 9, 5], [6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6, 6, 5, 8, 2, 4, 6], [7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7, 7, 8, 5, 9, 2, 7], [9, 4, 8, 4, 3, 2, 9, 4, 8, 4, 3, 2, 9, 4, 8, 4, 3, 2]]}, {""input"": [[3, 2, 3, 8, 5, 6], [2, 4, 6, 7, 4, 2], [7, 5, 9, 3, 8, 7], [4, 6, 8, 7, 2, 3], [5, 4, 5, 8, 3, 2], [6, 3, 9, 3, 6, 9]], ""output"": [[3, 2, 3, 8, 5, 6, 3, 2, 3, 8, 5, 6, 3, 2, 3, 8, 5, 6], [2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2], [7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7], [4, 6, 8, 7, 2, 3, 4, 6, 8, 7, 2, 3, 4, 6, 8, 7, 2, 3], [5, 4, 5, 8, 3, 2, 5, 4, 5, 8, 3, 2, 5, 4, 5, 8, 3, 2], [6, 3, 9, 3, 6, 9, 6, 3, 9, 3, 6, 9, 6, 3, 9, 3, 6, 9], [6, 2, 3, 8, 5, 3, 6, 2, 3, 8, 5, 3, 6, 2, 3, 8, 5, 3], [2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2], [7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7], [3, 6, 8, 7, 2, 4, 3, 6, 8, 7, 2, 4, 3, 6, 8, 7, 2, 4], [2, 4, 5, 8, 3, 5, 2, 4, 5, 8, 3, 5, 2, 4, 5, 8, 3, 5], [9, 3, 9, 3, 6, 6, 9, 3, 9, 3, 6, 6, 9, 3, 9, 3, 6, 6], [3, 2, 3, 8, 5, 6, 3, 2, 3, 8, 5, 6, 3, 2, 3, 8, 5, 6], [2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2, 2, 4, 6, 7, 4, 2], [7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7, 7, 5, 9, 3, 8, 7], [4, 6, 8, 7, 2, 3, 4, 6, 8, 7, 2, 3, 4, 6, 8, 7, 2, 3], [5, 4, 5, 8, 3, 2, 5, 4, 5, 8, 3, 2, 5, 4, 5, 8, 3, 2], [6, 3, 9, 3, 6, 9, 6, 3, 9, 3, 6, 9, 6, 3, 9, 3, 6, 9]]}], ""test"": [{""input"": [[9, 8, 6, 8, 6, 4], [5, 6, 2, 5, 3, 6], [2, 4, 5, 2, 8, 5], [6, 3, 4, 3, 4, 9], [7, 8, 6, 5, 8, 3], [6, 5, 3, 8, 7, 1]], ""output"": [[9, 8, 6, 8, 6, 4, 9, 8, 6, 8, 6, 4, 9, 8, 6, 8, 6, 4], [5, 6, 2, 5, 3, 6, 5, 6, 2, 5, 3, 6, 5, 6, 2, 5, 3, 6], [2, 4, 5, 2, 8, 5, 2, 4, 5, 2, 8, 5, 2, 4, 5, 2, 8, 5], [6, 3, 4, 3, 4, 9, 6, 3, 4, 3, 4, 9, 6, 3, 4, 3, 4, 9], [7, 8, 6, 5, 8, 3, 7, 8, 6, 5, 8, 3, 7, 8, 6, 5, 8, 3], [6, 5, 3, 8, 7, 1, 6, 5, 3, 8, 7, 1, 6, 5, 3, 8, 7, 1], [4, 8, 6, 8, 6, 9, 4, 8, 6, 8, 6, 9, 4, 8, 6, 8, 6, 9], [6, 6, 2, 5, 3, 5, 6, 6, 2, 5, 3, 5, 6, 6, 2, 5, 3, 5], [5, 4, 5, 2, 8, 2, 5, 4, 5, 2, 8, 2, 5, 4, 5, 2, 8, 2], [9, 3, 4, 3, 4, 6, 9, 3, 4, 3, 4, 6, 9, 3, 4, 3, 4, 6], [3, 8, 6, 5, 8, 7, 3, 8, 6, 5, 8, 7, 3, 8, 6, 5, 8, 7], [1, 5, 3, 8, 7, 6, 1, 5, 3, 8, 7, 6, 1, 5, 3, 8, 7, 6], [9, 8, 6, 8, 6, 4, 9, 8, 6, 8, 6, 4, 9, 8, 6, 8, 6, 4], [5, 6, 2, 5, 3, 6, 5, 6, 2, 5, 3, 6, 5, 6, 2, 5, 3, 6], [2, 4, 5, 2, 8, 5, 2, 4, 5, 2, 8, 5, 2, 4, 5, 2, 8, 5], [6, 3, 4, 3, 4, 9, 6, 3, 4, 3, 4, 9, 6, 3, 4, 3, 4, 9], [7, 8, 6, 5, 8, 3, 7, 8, 6, 5, 8, 3, 7, 8, 6, 5, 8, 3], [6, 5, 3, 8, 7, 1, 6, 5, 3, 8, 7, 1, 6, 5, 3, 8, 7, 1]]}]}"
QabiVAoq6YT6myE9yZfmwb,2025-07-21T15:52:22.661945,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 6, 8, 9, 6, 7, 4], [8, 4, 9, 8, 3, 2, 9], [4, 8, 3, 2, 7, 9, 5], [9, 6, 7, 9, 4, 5, 9], [5, 7, 3, 4, 9, 4, 6], [4, 6, 4, 9, 6, 5, 8], [5, 2, 8, 3, 9, 8, 3]], ""output"": [[5, 6, 8, 9, 6, 7, 4, 5, 6, 8, 9, 6, 7, 4, 5, 6, 8, 9, 6, 7, 4], [8, 4, 9, 8, 3, 2, 9, 8, 4, 9, 8, 3, 2, 9, 8, 4, 9, 8, 3, 2, 9], [4, 8, 3, 2, 7, 9, 5, 4, 8, 3, 2, 7, 9, 5, 4, 8, 3, 2, 7, 9, 5], [9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9], [5, 7, 3, 4, 9, 4, 6, 5, 7, 3, 4, 9, 4, 6, 5, 7, 3, 4, 9, 4, 6], [4, 6, 4, 9, 6, 5, 8, 4, 6, 4, 9, 6, 5, 8, 4, 6, 4, 9, 6, 5, 8], [5, 2, 8, 3, 9, 8, 3, 5, 2, 8, 3, 9, 8, 3, 5, 2, 8, 3, 9, 8, 3], [4, 6, 8, 9, 6, 7, 5, 4, 6, 8, 9, 6, 7, 5, 4, 6, 8, 9, 6, 7, 5], [9, 4, 9, 8, 3, 2, 8, 9, 4, 9, 8, 3, 2, 8, 9, 4, 9, 8, 3, 2, 8], [5, 8, 3, 2, 7, 9, 4, 5, 8, 3, 2, 7, 9, 4, 5, 8, 3, 2, 7, 9, 4], [9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9], [6, 7, 3, 4, 9, 4, 5, 6, 7, 3, 4, 9, 4, 5, 6, 7, 3, 4, 9, 4, 5], [8, 6, 4, 9, 6, 5, 4, 8, 6, 4, 9, 6, 5, 4, 8, 6, 4, 9, 6, 5, 4], [3, 2, 8, 3, 9, 8, 5, 3, 2, 8, 3, 9, 8, 5, 3, 2, 8, 3, 9, 8, 5], [5, 6, 8, 9, 6, 7, 4, 5, 6, 8, 9, 6, 7, 4, 5, 6, 8, 9, 6, 7, 4], [8, 4, 9, 8, 3, 2, 9, 8, 4, 9, 8, 3, 2, 9, 8, 4, 9, 8, 3, 2, 9], [4, 8, 3, 2, 7, 9, 5, 4, 8, 3, 2, 7, 9, 5, 4, 8, 3, 2, 7, 9, 5], [9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9, 9, 6, 7, 9, 4, 5, 9], [5, 7, 3, 4, 9, 4, 6, 5, 7, 3, 4, 9, 4, 6, 5, 7, 3, 4, 9, 4, 6], [4, 6, 4, 9, 6, 5, 8, 4, 6, 4, 9, 6, 5, 8, 4, 6, 4, 9, 6, 5, 8], [5, 2, 8, 3, 9, 8, 3, 5, 2, 8, 3, 9, 8, 3, 5, 2, 8, 3, 9, 8, 3]]}, {""input"": [[2, 9, 7, 6, 7, 3, 6], [6, 2, 6, 7, 6, 4, 7], [3, 4, 5, 4, 9, 6, 3], [2, 6, 3, 5, 7, 4, 5], [7, 4, 5, 2, 5, 7, 9], [2, 3, 8, 6, 8, 3, 7], [3, 4, 6, 7, 3, 5, 6]], ""output"": [[2, 9, 7, 6, 7, 3, 6, 2, 9, 7, 6, 7, 3, 6, 2, 9, 7, 6, 7, 3, 6], [6, 2, 6, 7, 6, 4, 7, 6, 2, 6, 7, 6, 4, 7, 6, 2, 6, 7, 6, 4, 7], [3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3], [2, 6, 3, 5, 7, 4, 5, 2, 6, 3, 5, 7, 4, 5, 2, 6, 3, 5, 7, 4, 5], [7, 4, 5, 2, 5, 7, 9, 7, 4, 5, 2, 5, 7, 9, 7, 4, 5, 2, 5, 7, 9], [2, 3, 8, 6, 8, 3, 7, 2, 3, 8, 6, 8, 3, 7, 2, 3, 8, 6, 8, 3, 7], [3, 4, 6, 7, 3, 5, 6, 3, 4, 6, 7, 3, 5, 6, 3, 4, 6, 7, 3, 5, 6], [6, 9, 7, 6, 7, 3, 2, 6, 9, 7, 6, 7, 3, 2, 6, 9, 7, 6, 7, 3, 2], [7, 2, 6, 7, 6, 4, 6, 7, 2, 6, 7, 6, 4, 6, 7, 2, 6, 7, 6, 4, 6], [3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3], [5, 6, 3, 5, 7, 4, 2, 5, 6, 3, 5, 7, 4, 2, 5, 6, 3, 5, 7, 4, 2], [9, 4, 5, 2, 5, 7, 7, 9, 4, 5, 2, 5, 7, 7, 9, 4, 5, 2, 5, 7, 7], [7, 3, 8, 6, 8, 3, 2, 7, 3, 8, 6, 8, 3, 2, 7, 3, 8, 6, 8, 3, 2], [6, 4, 6, 7, 3, 5, 3, 6, 4, 6, 7, 3, 5, 3, 6, 4, 6, 7, 3, 5, 3], [2, 9, 7, 6, 7, 3, 6, 2, 9, 7, 6, 7, 3, 6, 2, 9, 7, 6, 7, 3, 6], [6, 2, 6, 7, 6, 4, 7, 6, 2, 6, 7, 6, 4, 7, 6, 2, 6, 7, 6, 4, 7], [3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3, 3, 4, 5, 4, 9, 6, 3], [2, 6, 3, 5, 7, 4, 5, 2, 6, 3, 5, 7, 4, 5, 2, 6, 3, 5, 7, 4, 5], [7, 4, 5, 2, 5, 7, 9, 7, 4, 5, 2, 5, 7, 9, 7, 4, 5, 2, 5, 7, 9], [2, 3, 8, 6, 8, 3, 7, 2, 3, 8, 6, 8, 3, 7, 2, 3, 8, 6, 8, 3, 7], [3, 4, 6, 7, 3, 5, 6, 3, 4, 6, 7, 3, 5, 6, 3, 4, 6, 7, 3, 5, 6]]}, {""input"": [[5, 3, 7, 4, 5, 7, 6], [6, 5, 4, 6, 7, 4, 5], [2, 7, 3, 7, 5, 8, 3], [5, 9, 8, 9, 3, 7, 9], [4, 7, 6, 2, 6, 3, 5], [2, 6, 3, 8, 3, 6, 4], [8, 5, 2, 5, 4, 3, 7]], ""output"": [[5, 3, 7, 4, 5, 7, 6, 5, 3, 7, 4, 5, 7, 6, 5, 3, 7, 4, 5, 7, 6], [6, 5, 4, 6, 7, 4, 5, 6, 5, 4, 6, 7, 4, 5, 6, 5, 4, 6, 7, 4, 5], [2, 7, 3, 7, 5, 8, 3, 2, 7, 3, 7, 5, 8, 3, 2, 7, 3, 7, 5, 8, 3], [5, 9, 8, 9, 3, 7, 9, 5, 9, 8, 9, 3, 7, 9, 5, 9, 8, 9, 3, 7, 9], [4, 7, 6, 2, 6, 3, 5, 4, 7, 6, 2, 6, 3, 5, 4, 7, 6, 2, 6, 3, 5], [2, 6, 3, 8, 3, 6, 4, 2, 6, 3, 8, 3, 6, 4, 2, 6, 3, 8, 3, 6, 4], [8, 5, 2, 5, 4, 3, 7, 8, 5, 2, 5, 4, 3, 7, 8, 5, 2, 5, 4, 3, 7], [6, 3, 7, 4, 5, 7, 5, 6, 3, 7, 4, 5, 7, 5, 6, 3, 7, 4, 5, 7, 5], [5, 5, 4, 6, 7, 4, 6, 5, 5, 4, 6, 7, 4, 6, 5, 5, 4, 6, 7, 4, 6], [3, 7, 3, 7, 5, 8, 2, 3, 7, 3, 7, 5, 8, 2, 3, 7, 3, 7, 5, 8, 2], [9, 9, 8, 9, 3, 7, 5, 9, 9, 8, 9, 3, 7, 5, 9, 9, 8, 9, 3, 7, 5], [5, 7, 6, 2, 6, 3, 4, 5, 7, 6, 2, 6, 3, 4, 5, 7, 6, 2, 6, 3, 4], [4, 6, 3, 8, 3, 6, 2, 4, 6, 3, 8, 3, 6, 2, 4, 6, 3, 8, 3, 6, 2], [7, 5, 2, 5, 4, 3, 8, 7, 5, 2, 5, 4, 3, 8, 7, 5, 2, 5, 4, 3, 8], [5, 3, 7, 4, 5, 7, 6, 5, 3, 7, 4, 5, 7, 6, 5, 3, 7, 4, 5, 7, 6], [6, 5, 4, 6, 7, 4, 5, 6, 5, 4, 6, 7, 4, 5, 6, 5, 4, 6, 7, 4, 5], [2, 7, 3, 7, 5, 8, 3, 2, 7, 3, 7, 5, 8, 3, 2, 7, 3, 7, 5, 8, 3], [5, 9, 8, 9, 3, 7, 9, 5, 9, 8, 9, 3, 7, 9, 5, 9, 8, 9, 3, 7, 9], [4, 7, 6, 2, 6, 3, 5, 4, 7, 6, 2, 6, 3, 5, 4, 7, 6, 2, 6, 3, 5], [2, 6, 3, 8, 3, 6, 4, 2, 6, 3, 8, 3, 6, 4, 2, 6, 3, 8, 3, 6, 4], [8, 5, 2, 5, 4, 3, 7, 8, 5, 2, 5, 4, 3, 7, 8, 5, 2, 5, 4, 3, 7]]}], ""test"": [{""input"": [[2, 8, 5, 4, 3, 8, 6], [7, 5, 2, 3, 7, 3, 7], [6, 4, 6, 5, 4, 2, 3], [9, 7, 2, 7, 9, 8, 9], [4, 8, 7, 8, 4, 9, 4], [7, 6, 5, 6, 5, 4, 7], [8, 2, 9, 8, 4, 6, 5]], ""output"": [[2, 8, 5, 4, 3, 8, 6, 2, 8, 5, 4, 3, 8, 6, 2, 8, 5, 4, 3, 8, 6], [7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7], [6, 4, 6, 5, 4, 2, 3, 6, 4, 6, 5, 4, 2, 3, 6, 4, 6, 5, 4, 2, 3], [9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9], [4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4], [7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7], [8, 2, 9, 8, 4, 6, 5, 8, 2, 9, 8, 4, 6, 5, 8, 2, 9, 8, 4, 6, 5], [6, 8, 5, 4, 3, 8, 2, 6, 8, 5, 4, 3, 8, 2, 6, 8, 5, 4, 3, 8, 2], [7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7], [3, 4, 6, 5, 4, 2, 6, 3, 4, 6, 5, 4, 2, 6, 3, 4, 6, 5, 4, 2, 6], [9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9], [4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4], [7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7], [5, 2, 9, 8, 4, 6, 8, 5, 2, 9, 8, 4, 6, 8, 5, 2, 9, 8, 4, 6, 8], [2, 8, 5, 4, 3, 8, 6, 2, 8, 5, 4, 3, 8, 6, 2, 8, 5, 4, 3, 8, 6], [7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7, 7, 5, 2, 3, 7, 3, 7], [6, 4, 6, 5, 4, 2, 3, 6, 4, 6, 5, 4, 2, 3, 6, 4, 6, 5, 4, 2, 3], [9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9, 9, 7, 2, 7, 9, 8, 9], [4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4, 4, 8, 7, 8, 4, 9, 4], [7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7, 7, 6, 5, 6, 5, 4, 7], [8, 2, 9, 8, 4, 6, 5, 8, 2, 9, 8, 4, 6, 5, 8, 2, 9, 8, 4, 6, 5]]}]}"
3YmLtB5YEyRtF7Lyynm2kS,2025-07-21T15:52:22.666064,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 3, 6, 7, 8, 9], [7, 8, 5, 6, 7, 3], [6, 2, 9, 2, 8, 6], [3, 7, 2, 4, 2, 8], [2, 5, 6, 3, 8, 7], [3, 6, 3, 5, 4, 5]], ""output"": [[9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9], [7, 8, 5, 6, 7, 3, 7, 8, 5, 6, 7, 3, 7, 8, 5, 6, 7, 3], [6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6], [3, 7, 2, 4, 2, 8, 3, 7, 2, 4, 2, 8, 3, 7, 2, 4, 2, 8], [2, 5, 6, 3, 8, 7, 2, 5, 6, 3, 8, 7, 2, 5, 6, 3, 8, 7], [3, 6, 3, 5, 4, 5, 3, 6, 3, 5, 4, 5, 3, 6, 3, 5, 4, 5], [9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9], [3, 8, 5, 6, 7, 7, 3, 8, 5, 6, 7, 7, 3, 8, 5, 6, 7, 7], [6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6], [8, 7, 2, 4, 2, 3, 8, 7, 2, 4, 2, 3, 8, 7, 2, 4, 2, 3], [7, 5, 6, 3, 8, 2, 7, 5, 6, 3, 8, 2, 7, 5, 6, 3, 8, 2], [5, 6, 3, 5, 4, 3, 5, 6, 3, 5, 4, 3, 5, 6, 3, 5, 4, 3], [9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9, 9, 3, 6, 7, 8, 9], [7, 8, 5, 6, 7, 3, 7, 8, 5, 6, 7, 3, 7, 8, 5, 6, 7, 3], [6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6, 6, 2, 9, 2, 8, 6], [3, 7, 2, 4, 2, 8, 3, 7, 2, 4, 2, 8, 3, 7, 2, 4, 2, 8], [2, 5, 6, 3, 8, 7, 2, 5, 6, 3, 8, 7, 2, 5, 6, 3, 8, 7], [3, 6, 3, 5, 4, 5, 3, 6, 3, 5, 4, 5, 3, 6, 3, 5, 4, 5]]}, {""input"": [[8, 2, 7, 2, 9, 2], [6, 8, 2, 8, 6, 4], [5, 2, 4, 5, 8, 5], [8, 4, 2, 9, 5, 4], [2, 8, 6, 2, 7, 8], [9, 7, 3, 4, 9, 5]], ""output"": [[8, 2, 7, 2, 9, 2, 8, 2, 7, 2, 9, 2, 8, 2, 7, 2, 9, 2], [6, 8, 2, 8, 6, 4, 6, 8, 2, 8, 6, 4, 6, 8, 2, 8, 6, 4], [5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5], [8, 4, 2, 9, 5, 4, 8, 4, 2, 9, 5, 4, 8, 4, 2, 9, 5, 4], [2, 8, 6, 2, 7, 8, 2, 8, 6, 2, 7, 8, 2, 8, 6, 2, 7, 8], [9, 7, 3, 4, 9, 5, 9, 7, 3, 4, 9, 5, 9, 7, 3, 4, 9, 5], [2, 2, 7, 2, 9, 8, 2, 2, 7, 2, 9, 8, 2, 2, 7, 2, 9, 8], [4, 8, 2, 8, 6, 6, 4, 8, 2, 8, 6, 6, 4, 8, 2, 8, 6, 6], [5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5], [4, 4, 2, 9, 5, 8, 4, 4, 2, 9, 5, 8, 4, 4, 2, 9, 5, 8], [8, 8, 6, 2, 7, 2, 8, 8, 6, 2, 7, 2, 8, 8, 6, 2, 7, 2], [5, 7, 3, 4, 9, 9, 5, 7, 3, 4, 9, 9, 5, 7, 3, 4, 9, 9], [8, 2, 7, 2, 9, 2, 8, 2, 7, 2, 9, 2, 8, 2, 7, 2, 9, 2], [6, 8, 2, 8, 6, 4, 6, 8, 2, 8, 6, 4, 6, 8, 2, 8, 6, 4], [5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5, 5, 2, 4, 5, 8, 5], [8, 4, 2, 9, 5, 4, 8, 4, 2, 9, 5, 4, 8, 4, 2, 9, 5, 4], [2, 8, 6, 2, 7, 8, 2, 8, 6, 2, 7, 8, 2, 8, 6, 2, 7, 8], [9, 7, 3, 4, 9, 5, 9, 7, 3, 4, 9, 5, 9, 7, 3, 4, 9, 5]]}, {""input"": [[8, 2, 9, 6, 7, 5], [9, 3, 8, 3, 9, 3], [2, 5, 9, 7, 3, 6], [9, 8, 6, 2, 6, 2], [6, 2, 4, 5, 8, 5], [8, 7, 2, 8, 2, 6]], ""output"": [[8, 2, 9, 6, 7, 5, 8, 2, 9, 6, 7, 5, 8, 2, 9, 6, 7, 5], [9, 3, 8, 3, 9, 3, 9, 3, 8, 3, 9, 3, 9, 3, 8, 3, 9, 3], [2, 5, 9, 7, 3, 6, 2, 5, 9, 7, 3, 6, 2, 5, 9, 7, 3, 6], [9, 8, 6, 2, 6, 2, 9, 8, 6, 2, 6, 2, 9, 8, 6, 2, 6, 2], [6, 2, 4, 5, 8, 5, 6, 2, 4, 5, 8, 5, 6, 2, 4, 5, 8, 5], [8, 7, 2, 8, 2, 6, 8, 7, 2, 8, 2, 6, 8, 7, 2, 8, 2, 6], [5, 2, 9, 6, 7, 8, 5, 2, 9, 6, 7, 8, 5, 2, 9, 6, 7, 8], [3, 3, 8, 3, 9, 9, 3, 3, 8, 3, 9, 9, 3, 3, 8, 3, 9, 9], [6, 5, 9, 7, 3, 2, 6, 5, 9, 7, 3, 2, 6, 5, 9, 7, 3, 2], [2, 8, 6, 2, 6, 9, 2, 8, 6, 2, 6, 9, 2, 8, 6, 2, 6, 9], [5, 2, 4, 5, 8, 6, 5, 2, 4, 5, 8, 6, 5, 2, 4, 5, 8, 6], [6, 7, 2, 8, 2, 8, 6, 7, 2, 8, 2, 8, 6, 7, 2, 8, 2, 8], [8, 2, 9, 6, 7, 5, 8, 2, 9, 6, 7, 5, 8, 2, 9, 6, 7, 5], [9, 3, 8, 3, 9, 3, 9, 3, 8, 3, 9, 3, 9, 3, 8, 3, 9, 3], [2, 5, 9, 7, 3, 6, 2, 5, 9, 7, 3, 6, 2, 5, 9, 7, 3, 6], [9, 8, 6, 2, 6, 2, 9, 8, 6, 2, 6, 2, 9, 8, 6, 2, 6, 2], [6, 2, 4, 5, 8, 5, 6, 2, 4, 5, 8, 5, 6, 2, 4, 5, 8, 5], [8, 7, 2, 8, 2, 6, 8, 7, 2, 8, 2, 6, 8, 7, 2, 8, 2, 6]]}], ""test"": [{""input"": [[7, 5, 4, 2, 6, 3], [2, 3, 5, 3, 4, 8], [9, 6, 9, 8, 9, 2], [3, 9, 3, 7, 6, 5], [4, 5, 9, 5, 7, 9], [3, 2, 6, 2, 8, 6]], ""output"": [[7, 5, 4, 2, 6, 3, 7, 5, 4, 2, 6, 3, 7, 5, 4, 2, 6, 3], [2, 3, 5, 3, 4, 8, 2, 3, 5, 3, 4, 8, 2, 3, 5, 3, 4, 8], [9, 6, 9, 8, 9, 2, 9, 6, 9, 8, 9, 2, 9, 6, 9, 8, 9, 2], [3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5], [4, 5, 9, 5, 7, 9, 4, 5, 9, 5, 7, 9, 4, 5, 9, 5, 7, 9], [3, 2, 6, 2, 8, 6, 3, 2, 6, 2, 8, 6, 3, 2, 6, 2, 8, 6], [3, 5, 4, 2, 6, 7, 3, 5, 4, 2, 6, 7, 3, 5, 4, 2, 6, 7], [8, 3, 5, 3, 4, 2, 8, 3, 5, 3, 4, 2, 8, 3, 5, 3, 4, 2], [2, 6, 9, 8, 9, 9, 2, 6, 9, 8, 9, 9, 2, 6, 9, 8, 9, 9], [5, 9, 3, 7, 6, 3, 5, 9, 3, 7, 6, 3, 5, 9, 3, 7, 6, 3], [9, 5, 9, 5, 7, 4, 9, 5, 9, 5, 7, 4, 9, 5, 9, 5, 7, 4], [6, 2, 6, 2, 8, 3, 6, 2, 6, 2, 8, 3, 6, 2, 6, 2, 8, 3], [7, 5, 4, 2, 6, 3, 7, 5, 4, 2, 6, 3, 7, 5, 4, 2, 6, 3], [2, 3, 5, 3, 4, 8, 2, 3, 5, 3, 4, 8, 2, 3, 5, 3, 4, 8], [9, 6, 9, 8, 9, 2, 9, 6, 9, 8, 9, 2, 9, 6, 9, 8, 9, 2], [3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5, 3, 9, 3, 7, 6, 5], [4, 5, 9, 5, 7, 9, 4, 5, 9, 5, 7, 9, 4, 5, 9, 5, 7, 9], [3, 2, 6, 2, 8, 6, 3, 2, 6, 2, 8, 6, 3, 2, 6, 2, 8, 6]]}]}"
biJR4rn2ADFSBEkGzWwXRT,2025-07-21T15:52:22.669197,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 5, 4, 8], [5, 3, 5, 7], [7, 9, 4, 3], [4, 6, 7, 6]], ""output"": [[3, 5, 4, 8, 3, 5, 4, 8, 3, 5, 4, 8], [5, 3, 5, 7, 5, 3, 5, 7, 5, 3, 5, 7], [7, 9, 4, 3, 7, 9, 4, 3, 7, 9, 4, 3], [4, 6, 7, 6, 4, 6, 7, 6, 4, 6, 7, 6], [8, 5, 4, 3, 8, 5, 4, 3, 8, 5, 4, 3], [7, 3, 5, 5, 7, 3, 5, 5, 7, 3, 5, 5], [3, 9, 4, 7, 3, 9, 4, 7, 3, 9, 4, 7], [6, 6, 7, 4, 6, 6, 7, 4, 6, 6, 7, 4], [3, 5, 4, 8, 3, 5, 4, 8, 3, 5, 4, 8], [5, 3, 5, 7, 5, 3, 5, 7, 5, 3, 5, 7], [7, 9, 4, 3, 7, 9, 4, 3, 7, 9, 4, 3], [4, 6, 7, 6, 4, 6, 7, 6, 4, 6, 7, 6]]}, {""input"": [[4, 2, 9, 7], [2, 7, 4, 2], [7, 3, 7, 4], [4, 7, 8, 2]], ""output"": [[4, 2, 9, 7, 4, 2, 9, 7, 4, 2, 9, 7], [2, 7, 4, 2, 2, 7, 4, 2, 2, 7, 4, 2], [7, 3, 7, 4, 7, 3, 7, 4, 7, 3, 7, 4], [4, 7, 8, 2, 4, 7, 8, 2, 4, 7, 8, 2], [7, 2, 9, 4, 7, 2, 9, 4, 7, 2, 9, 4], [2, 7, 4, 2, 2, 7, 4, 2, 2, 7, 4, 2], [4, 3, 7, 7, 4, 3, 7, 7, 4, 3, 7, 7], [2, 7, 8, 4, 2, 7, 8, 4, 2, 7, 8, 4], [4, 2, 9, 7, 4, 2, 9, 7, 4, 2, 9, 7], [2, 7, 4, 2, 2, 7, 4, 2, 2, 7, 4, 2], [7, 3, 7, 4, 7, 3, 7, 4, 7, 3, 7, 4], [4, 7, 8, 2, 4, 7, 8, 2, 4, 7, 8, 2]]}, {""input"": [[5, 2, 6, 9], [8, 3, 9, 4], [5, 8, 5, 7], [4, 3, 7, 8]], ""output"": [[5, 2, 6, 9, 5, 2, 6, 9, 5, 2, 6, 9], [8, 3, 9, 4, 8, 3, 9, 4, 8, 3, 9, 4], [5, 8, 5, 7, 5, 8, 5, 7, 5, 8, 5, 7], [4, 3, 7, 8, 4, 3, 7, 8, 4, 3, 7, 8], [9, 2, 6, 5, 9, 2, 6, 5, 9, 2, 6, 5], [4, 3, 9, 8, 4, 3, 9, 8, 4, 3, 9, 8], [7, 8, 5, 5, 7, 8, 5, 5, 7, 8, 5, 5], [8, 3, 7, 4, 8, 3, 7, 4, 8, 3, 7, 4], [5, 2, 6, 9, 5, 2, 6, 9, 5, 2, 6, 9], [8, 3, 9, 4, 8, 3, 9, 4, 8, 3, 9, 4], [5, 8, 5, 7, 5, 8, 5, 7, 5, 8, 5, 7], [4, 3, 7, 8, 4, 3, 7, 8, 4, 3, 7, 8]]}], ""test"": [{""input"": [[9, 2, 8, 4], [5, 3, 2, 6], [2, 9, 6, 3], [7, 2, 9, 2]], ""output"": [[9, 2, 8, 4, 9, 2, 8, 4, 9, 2, 8, 4], [5, 3, 2, 6, 5, 3, 2, 6, 5, 3, 2, 6], [2, 9, 6, 3, 2, 9, 6, 3, 2, 9, 6, 3], [7, 2, 9, 2, 7, 2, 9, 2, 7, 2, 9, 2], [4, 2, 8, 9, 4, 2, 8, 9, 4, 2, 8, 9], [6, 3, 2, 5, 6, 3, 2, 5, 6, 3, 2, 5], [3, 9, 6, 2, 3, 9, 6, 2, 3, 9, 6, 2], [2, 2, 9, 7, 2, 2, 9, 7, 2, 2, 9, 7], [9, 2, 8, 4, 9, 2, 8, 4, 9, 2, 8, 4], [5, 3, 2, 6, 5, 3, 2, 6, 5, 3, 2, 6], [2, 9, 6, 3, 2, 9, 6, 3, 2, 9, 6, 3], [7, 2, 9, 2, 7, 2, 9, 2, 7, 2, 9, 2]]}]}"
VzVmStAp3bWcUqNZX9LFsL,2025-07-21T15:52:22.671695,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 6, 2], [3, 8, 4], [9, 4, 3]], ""output"": [[7, 6, 2, 7, 6, 2, 7, 6, 2], [3, 8, 4, 3, 8, 4, 3, 8, 4], [9, 4, 3, 9, 4, 3, 9, 4, 3], [2, 6, 7, 2, 6, 7, 2, 6, 7], [4, 8, 3, 4, 8, 3, 4, 8, 3], [3, 4, 9, 3, 4, 9, 3, 4, 9], [7, 6, 2, 7, 6, 2, 7, 6, 2], [3, 8, 4, 3, 8, 4, 3, 8, 4], [9, 4, 3, 9, 4, 3, 9, 4, 3]]}, {""input"": [[2, 9, 5], [4, 2, 8], [2, 7, 9]], ""output"": [[2, 9, 5, 2, 9, 5, 2, 9, 5], [4, 2, 8, 4, 2, 8, 4, 2, 8], [2, 7, 9, 2, 7, 9, 2, 7, 9], [5, 9, 2, 5, 9, 2, 5, 9, 2], [8, 2, 4, 8, 2, 4, 8, 2, 4], [9, 7, 2, 9, 7, 2, 9, 7, 2], [2, 9, 5, 2, 9, 5, 2, 9, 5], [4, 2, 8, 4, 2, 8, 4, 2, 8], [2, 7, 9, 2, 7, 9, 2, 7, 9]]}, {""input"": [[3, 5, 9], [4, 8, 2], [5, 7, 8]], ""output"": [[3, 5, 9, 3, 5, 9, 3, 5, 9], [4, 8, 2, 4, 8, 2, 4, 8, 2], [5, 7, 8, 5, 7, 8, 5, 7, 8], [9, 5, 3, 9, 5, 3, 9, 5, 3], [2, 8, 4, 2, 8, 4, 2, 8, 4], [8, 7, 5, 8, 7, 5, 8, 7, 5], [3, 5, 9, 3, 5, 9, 3, 5, 9], [4, 8, 2, 4, 8, 2, 4, 8, 2], [5, 7, 8, 5, 7, 8, 5, 7, 8]]}], ""test"": [{""input"": [[8, 4, 5], [9, 2, 6], [7, 6, 4]], ""output"": [[8, 4, 5, 8, 4, 5, 8, 4, 5], [9, 2, 6, 9, 2, 6, 9, 2, 6], [7, 6, 4, 7, 6, 4, 7, 6, 4], [5, 4, 8, 5, 4, 8, 5, 4, 8], [6, 2, 9, 6, 2, 9, 6, 2, 9], [4, 6, 7, 4, 6, 7, 4, 6, 7], [8, 4, 5, 8, 4, 5, 8, 4, 5], [9, 2, 6, 9, 2, 6, 9, 2, 6], [7, 6, 4, 7, 6, 4, 7, 6, 4]]}]}"
Hdh5EGpdE4CK2gQrh5YjPN,2025-07-21T15:52:22.673928,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 6], [6, 3]], ""output"": [[7, 6, 7, 6, 7, 6], [6, 3, 6, 3, 6, 3], [6, 7, 6, 7, 6, 7], [3, 6, 3, 6, 3, 6], [7, 6, 7, 6, 7, 6], [6, 3, 6, 3, 6, 3]]}, {""input"": [[4, 8], [2, 6]], ""output"": [[4, 8, 4, 8, 4, 8], [2, 6, 2, 6, 2, 6], [8, 4, 8, 4, 8, 4], [6, 2, 6, 2, 6, 2], [4, 8, 4, 8, 4, 8], [2, 6, 2, 6, 2, 6]]}, {""input"": [[9, 4], [6, 2]], ""output"": [[9, 4, 9, 4, 9, 4], [6, 2, 6, 2, 6, 2], [4, 9, 4, 9, 4, 9], [2, 6, 2, 6, 2, 6], [9, 4, 9, 4, 9, 4], [6, 2, 6, 2, 6, 2]]}], ""test"": [{""input"": [[9, 4], [8, 1]], ""output"": [[9, 4, 9, 4, 9, 4], [8, 1, 8, 1, 8, 1], [4, 9, 4, 9, 4, 9], [1, 8, 1, 8, 1, 8], [9, 4, 9, 4, 9, 4], [8, 1, 8, 1, 8, 1]]}]}"
XpmpDiCjGweVpdLJ9VLhSG,2025-07-21T15:52:22.676457,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 5, 2, 3, 6], [5, 2, 4, 2, 3], [8, 3, 9, 4, 5], [4, 6, 8, 3, 8], [3, 4, 9, 4, 9]], ""output"": [[8, 5, 2, 3, 6, 8, 5, 2, 3, 6, 8, 5, 2, 3, 6], [5, 2, 4, 2, 3, 5, 2, 4, 2, 3, 5, 2, 4, 2, 3], [8, 3, 9, 4, 5, 8, 3, 9, 4, 5, 8, 3, 9, 4, 5], [4, 6, 8, 3, 8, 4, 6, 8, 3, 8, 4, 6, 8, 3, 8], [3, 4, 9, 4, 9, 3, 4, 9, 4, 9, 3, 4, 9, 4, 9], [6, 5, 2, 3, 8, 6, 5, 2, 3, 8, 6, 5, 2, 3, 8], [3, 2, 4, 2, 5, 3, 2, 4, 2, 5, 3, 2, 4, 2, 5], [5, 3, 9, 4, 8, 5, 3, 9, 4, 8, 5, 3, 9, 4, 8], [8, 6, 8, 3, 4, 8, 6, 8, 3, 4, 8, 6, 8, 3, 4], [9, 4, 9, 4, 3, 9, 4, 9, 4, 3, 9, 4, 9, 4, 3], [8, 5, 2, 3, 6, 8, 5, 2, 3, 6, 8, 5, 2, 3, 6], [5, 2, 4, 2, 3, 5, 2, 4, 2, 3, 5, 2, 4, 2, 3], [8, 3, 9, 4, 5, 8, 3, 9, 4, 5, 8, 3, 9, 4, 5], [4, 6, 8, 3, 8, 4, 6, 8, 3, 8, 4, 6, 8, 3, 8], [3, 4, 9, 4, 9, 3, 4, 9, 4, 9, 3, 4, 9, 4, 9]]}, {""input"": [[5, 7, 8, 7, 3], [2, 3, 9, 6, 7], [3, 4, 8, 2, 8], [5, 6, 3, 9, 4], [7, 5, 6, 3, 2]], ""output"": [[5, 7, 8, 7, 3, 5, 7, 8, 7, 3, 5, 7, 8, 7, 3], [2, 3, 9, 6, 7, 2, 3, 9, 6, 7, 2, 3, 9, 6, 7], [3, 4, 8, 2, 8, 3, 4, 8, 2, 8, 3, 4, 8, 2, 8], [5, 6, 3, 9, 4, 5, 6, 3, 9, 4, 5, 6, 3, 9, 4], [7, 5, 6, 3, 2, 7, 5, 6, 3, 2, 7, 5, 6, 3, 2], [3, 7, 8, 7, 5, 3, 7, 8, 7, 5, 3, 7, 8, 7, 5], [7, 3, 9, 6, 2, 7, 3, 9, 6, 2, 7, 3, 9, 6, 2], [8, 4, 8, 2, 3, 8, 4, 8, 2, 3, 8, 4, 8, 2, 3], [4, 6, 3, 9, 5, 4, 6, 3, 9, 5, 4, 6, 3, 9, 5], [2, 5, 6, 3, 7, 2, 5, 6, 3, 7, 2, 5, 6, 3, 7], [5, 7, 8, 7, 3, 5, 7, 8, 7, 3, 5, 7, 8, 7, 3], [2, 3, 9, 6, 7, 2, 3, 9, 6, 7, 2, 3, 9, 6, 7], [3, 4, 8, 2, 8, 3, 4, 8, 2, 8, 3, 4, 8, 2, 8], [5, 6, 3, 9, 4, 5, 6, 3, 9, 4, 5, 6, 3, 9, 4], [7, 5, 6, 3, 2, 7, 5, 6, 3, 2, 7, 5, 6, 3, 2]]}, {""input"": [[8, 5, 7, 3, 8], [2, 7, 5, 9, 6], [6, 8, 3, 5, 2], [7, 5, 9, 2, 7], [9, 3, 6, 5, 4]], ""output"": [[8, 5, 7, 3, 8, 8, 5, 7, 3, 8, 8, 5, 7, 3, 8], [2, 7, 5, 9, 6, 2, 7, 5, 9, 6, 2, 7, 5, 9, 6], [6, 8, 3, 5, 2, 6, 8, 3, 5, 2, 6, 8, 3, 5, 2], [7, 5, 9, 2, 7, 7, 5, 9, 2, 7, 7, 5, 9, 2, 7], [9, 3, 6, 5, 4, 9, 3, 6, 5, 4, 9, 3, 6, 5, 4], [8, 5, 7, 3, 8, 8, 5, 7, 3, 8, 8, 5, 7, 3, 8], [6, 7, 5, 9, 2, 6, 7, 5, 9, 2, 6, 7, 5, 9, 2], [2, 8, 3, 5, 6, 2, 8, 3, 5, 6, 2, 8, 3, 5, 6], [7, 5, 9, 2, 7, 7, 5, 9, 2, 7, 7, 5, 9, 2, 7], [4, 3, 6, 5, 9, 4, 3, 6, 5, 9, 4, 3, 6, 5, 9], [8, 5, 7, 3, 8, 8, 5, 7, 3, 8, 8, 5, 7, 3, 8], [2, 7, 5, 9, 6, 2, 7, 5, 9, 6, 2, 7, 5, 9, 6], [6, 8, 3, 5, 2, 6, 8, 3, 5, 2, 6, 8, 3, 5, 2], [7, 5, 9, 2, 7, 7, 5, 9, 2, 7, 7, 5, 9, 2, 7], [9, 3, 6, 5, 4, 9, 3, 6, 5, 4, 9, 3, 6, 5, 4]]}], ""test"": [{""input"": [[5, 7, 4, 8, 5], [3, 9, 2, 5, 9], [4, 2, 5, 8, 2], [7, 4, 7, 5, 3], [4, 5, 3, 4, 7]], ""output"": [[5, 7, 4, 8, 5, 5, 7, 4, 8, 5, 5, 7, 4, 8, 5], [3, 9, 2, 5, 9, 3, 9, 2, 5, 9, 3, 9, 2, 5, 9], [4, 2, 5, 8, 2, 4, 2, 5, 8, 2, 4, 2, 5, 8, 2], [7, 4, 7, 5, 3, 7, 4, 7, 5, 3, 7, 4, 7, 5, 3], [4, 5, 3, 4, 7, 4, 5, 3, 4, 7, 4, 5, 3, 4, 7], [5, 7, 4, 8, 5, 5, 7, 4, 8, 5, 5, 7, 4, 8, 5], [9, 9, 2, 5, 3, 9, 9, 2, 5, 3, 9, 9, 2, 5, 3], [2, 2, 5, 8, 4, 2, 2, 5, 8, 4, 2, 2, 5, 8, 4], [3, 4, 7, 5, 7, 3, 4, 7, 5, 7, 3, 4, 7, 5, 7], [7, 5, 3, 4, 4, 7, 5, 3, 4, 4, 7, 5, 3, 4, 4], [5, 7, 4, 8, 5, 5, 7, 4, 8, 5, 5, 7, 4, 8, 5], [3, 9, 2, 5, 9, 3, 9, 2, 5, 9, 3, 9, 2, 5, 9], [4, 2, 5, 8, 2, 4, 2, 5, 8, 2, 4, 2, 5, 8, 2], [7, 4, 7, 5, 3, 7, 4, 7, 5, 3, 7, 4, 7, 5, 3], [4, 5, 3, 4, 7, 4, 5, 3, 4, 7, 4, 5, 3, 4, 7]]}]}"
Z5RnzvJswDuxe595Hsvhwu,2025-07-21T15:52:22.678679,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 2, 4], [5, 8, 2], [2, 4, 1]], ""output"": [[7, 2, 4, 7, 2, 4, 7, 2, 4], [5, 8, 2, 5, 8, 2, 5, 8, 2], [2, 4, 1, 2, 4, 1, 2, 4, 1], [4, 2, 7, 4, 2, 7, 4, 2, 7], [2, 8, 5, 2, 8, 5, 2, 8, 5], [1, 4, 2, 1, 4, 2, 1, 4, 2], [7, 2, 4, 7, 2, 4, 7, 2, 4], [5, 8, 2, 5, 8, 2, 5, 8, 2], [2, 4, 1, 2, 4, 1, 2, 4, 1]]}, {""input"": [[2, 5, 8], [7, 9, 7], [4, 5, 8]], ""output"": [[2, 5, 8, 2, 5, 8, 2, 5, 8], [7, 9, 7, 7, 9, 7, 7, 9, 7], [4, 5, 8, 4, 5, 8, 4, 5, 8], [8, 5, 2, 8, 5, 2, 8, 5, 2], [7, 9, 7, 7, 9, 7, 7, 9, 7], [8, 5, 4, 8, 5, 4, 8, 5, 4], [2, 5, 8, 2, 5, 8, 2, 5, 8], [7, 9, 7, 7, 9, 7, 7, 9, 7], [4, 5, 8, 4, 5, 8, 4, 5, 8]]}, {""input"": [[4, 8, 9], [9, 3, 5], [7, 5, 9]], ""output"": [[4, 8, 9, 4, 8, 9, 4, 8, 9], [9, 3, 5, 9, 3, 5, 9, 3, 5], [7, 5, 9, 7, 5, 9, 7, 5, 9], [9, 8, 4, 9, 8, 4, 9, 8, 4], [5, 3, 9, 5, 3, 9, 5, 3, 9], [9, 5, 7, 9, 5, 7, 9, 5, 7], [4, 8, 9, 4, 8, 9, 4, 8, 9], [9, 3, 5, 9, 3, 5, 9, 3, 5], [7, 5, 9, 7, 5, 9, 7, 5, 9]]}], ""test"": [{""input"": [[2, 5, 3], [9, 7, 8], [4, 5, 2]], ""output"": [[2, 5, 3, 2, 5, 3, 2, 5, 3], [9, 7, 8, 9, 7, 8, 9, 7, 8], [4, 5, 2, 4, 5, 2, 4, 5, 2], [3, 5, 2, 3, 5, 2, 3, 5, 2], [8, 7, 9, 8, 7, 9, 8, 7, 9], [2, 5, 4, 2, 5, 4, 2, 5, 4], [2, 5, 3, 2, 5, 3, 2, 5, 3], [9, 7, 8, 9, 7, 8, 9, 7, 8], [4, 5, 2, 4, 5, 2, 4, 5, 2]]}]}"
JvPkWA9WujwPwHyDVejY2R,2025-07-21T15:52:22.680571,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 8, 2], [7, 6, 5], [8, 7, 3]], ""output"": [[6, 8, 2, 6, 8, 2, 6, 8, 2], [7, 6, 5, 7, 6, 5, 7, 6, 5], [8, 7, 3, 8, 7, 3, 8, 7, 3], [2, 8, 6, 2, 8, 6, 2, 8, 6], [5, 6, 7, 5, 6, 7, 5, 6, 7], [3, 7, 8, 3, 7, 8, 3, 7, 8], [6, 8, 2, 6, 8, 2, 6, 8, 2], [7, 6, 5, 7, 6, 5, 7, 6, 5], [8, 7, 3, 8, 7, 3, 8, 7, 3]]}, {""input"": [[5, 4, 6], [9, 5, 9], [5, 9, 7]], ""output"": [[5, 4, 6, 5, 4, 6, 5, 4, 6], [9, 5, 9, 9, 5, 9, 9, 5, 9], [5, 9, 7, 5, 9, 7, 5, 9, 7], [6, 4, 5, 6, 4, 5, 6, 4, 5], [9, 5, 9, 9, 5, 9, 9, 5, 9], [7, 9, 5, 7, 9, 5, 7, 9, 5], [5, 4, 6, 5, 4, 6, 5, 4, 6], [9, 5, 9, 9, 5, 9, 9, 5, 9], [5, 9, 7, 5, 9, 7, 5, 9, 7]]}, {""input"": [[6, 2, 9], [5, 6, 4], [7, 4, 8]], ""output"": [[6, 2, 9, 6, 2, 9, 6, 2, 9], [5, 6, 4, 5, 6, 4, 5, 6, 4], [7, 4, 8, 7, 4, 8, 7, 4, 8], [9, 2, 6, 9, 2, 6, 9, 2, 6], [4, 6, 5, 4, 6, 5, 4, 6, 5], [8, 4, 7, 8, 4, 7, 8, 4, 7], [6, 2, 9, 6, 2, 9, 6, 2, 9], [5, 6, 4, 5, 6, 4, 5, 6, 4], [7, 4, 8, 7, 4, 8, 7, 4, 8]]}], ""test"": [{""input"": [[9, 8, 7], [2, 6, 4], [8, 9, 8]], ""output"": [[9, 8, 7, 9, 8, 7, 9, 8, 7], [2, 6, 4, 2, 6, 4, 2, 6, 4], [8, 9, 8, 8, 9, 8, 8, 9, 8], [7, 8, 9, 7, 8, 9, 7, 8, 9], [4, 6, 2, 4, 6, 2, 4, 6, 2], [8, 9, 8, 8, 9, 8, 8, 9, 8], [9, 8, 7, 9, 8, 7, 9, 8, 7], [2, 6, 4, 2, 6, 4, 2, 6, 4], [8, 9, 8, 8, 9, 8, 8, 9, 8]]}]}"
TNaUP9egrJzFYJGT6asmav,2025-07-21T15:52:22.682703,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 6, 2, 5, 4], [5, 4, 8, 4, 8], [3, 6, 7, 6, 4], [7, 4, 6, 4, 6], [3, 8, 2, 6, 4]], ""output"": [[9, 6, 2, 5, 4, 9, 6, 2, 5, 4, 9, 6, 2, 5, 4], [5, 4, 8, 4, 8, 5, 4, 8, 4, 8, 5, 4, 8, 4, 8], [3, 6, 7, 6, 4, 3, 6, 7, 6, 4, 3, 6, 7, 6, 4], [7, 4, 6, 4, 6, 7, 4, 6, 4, 6, 7, 4, 6, 4, 6], [3, 8, 2, 6, 4, 3, 8, 2, 6, 4, 3, 8, 2, 6, 4], [4, 6, 2, 5, 9, 4, 6, 2, 5, 9, 4, 6, 2, 5, 9], [8, 4, 8, 4, 5, 8, 4, 8, 4, 5, 8, 4, 8, 4, 5], [4, 6, 7, 6, 3, 4, 6, 7, 6, 3, 4, 6, 7, 6, 3], [6, 4, 6, 4, 7, 6, 4, 6, 4, 7, 6, 4, 6, 4, 7], [4, 8, 2, 6, 3, 4, 8, 2, 6, 3, 4, 8, 2, 6, 3], [9, 6, 2, 5, 4, 9, 6, 2, 5, 4, 9, 6, 2, 5, 4], [5, 4, 8, 4, 8, 5, 4, 8, 4, 8, 5, 4, 8, 4, 8], [3, 6, 7, 6, 4, 3, 6, 7, 6, 4, 3, 6, 7, 6, 4], [7, 4, 6, 4, 6, 7, 4, 6, 4, 6, 7, 4, 6, 4, 6], [3, 8, 2, 6, 4, 3, 8, 2, 6, 4, 3, 8, 2, 6, 4]]}, {""input"": [[2, 4, 3, 7, 4], [8, 2, 9, 4, 8], [6, 8, 4, 8, 9], [5, 4, 7, 6, 4], [9, 8, 4, 8, 9]], ""output"": [[2, 4, 3, 7, 4, 2, 4, 3, 7, 4, 2, 4, 3, 7, 4], [8, 2, 9, 4, 8, 8, 2, 9, 4, 8, 8, 2, 9, 4, 8], [6, 8, 4, 8, 9, 6, 8, 4, 8, 9, 6, 8, 4, 8, 9], [5, 4, 7, 6, 4, 5, 4, 7, 6, 4, 5, 4, 7, 6, 4], [9, 8, 4, 8, 9, 9, 8, 4, 8, 9, 9, 8, 4, 8, 9], [4, 4, 3, 7, 2, 4, 4, 3, 7, 2, 4, 4, 3, 7, 2], [8, 2, 9, 4, 8, 8, 2, 9, 4, 8, 8, 2, 9, 4, 8], [9, 8, 4, 8, 6, 9, 8, 4, 8, 6, 9, 8, 4, 8, 6], [4, 4, 7, 6, 5, 4, 4, 7, 6, 5, 4, 4, 7, 6, 5], [9, 8, 4, 8, 9, 9, 8, 4, 8, 9, 9, 8, 4, 8, 9], [2, 4, 3, 7, 4, 2, 4, 3, 7, 4, 2, 4, 3, 7, 4], [8, 2, 9, 4, 8, 8, 2, 9, 4, 8, 8, 2, 9, 4, 8], [6, 8, 4, 8, 9, 6, 8, 4, 8, 9, 6, 8, 4, 8, 9], [5, 4, 7, 6, 4, 5, 4, 7, 6, 4, 5, 4, 7, 6, 4], [9, 8, 4, 8, 9, 9, 8, 4, 8, 9, 9, 8, 4, 8, 9]]}, {""input"": [[5, 8, 3, 5, 9], [7, 4, 8, 3, 2], [4, 9, 5, 4, 6], [8, 2, 3, 2, 8], [3, 4, 5, 3, 7]], ""output"": [[5, 8, 3, 5, 9, 5, 8, 3, 5, 9, 5, 8, 3, 5, 9], [7, 4, 8, 3, 2, 7, 4, 8, 3, 2, 7, 4, 8, 3, 2], [4, 9, 5, 4, 6, 4, 9, 5, 4, 6, 4, 9, 5, 4, 6], [8, 2, 3, 2, 8, 8, 2, 3, 2, 8, 8, 2, 3, 2, 8], [3, 4, 5, 3, 7, 3, 4, 5, 3, 7, 3, 4, 5, 3, 7], [9, 8, 3, 5, 5, 9, 8, 3, 5, 5, 9, 8, 3, 5, 5], [2, 4, 8, 3, 7, 2, 4, 8, 3, 7, 2, 4, 8, 3, 7], [6, 9, 5, 4, 4, 6, 9, 5, 4, 4, 6, 9, 5, 4, 4], [8, 2, 3, 2, 8, 8, 2, 3, 2, 8, 8, 2, 3, 2, 8], [7, 4, 5, 3, 3, 7, 4, 5, 3, 3, 7, 4, 5, 3, 3], [5, 8, 3, 5, 9, 5, 8, 3, 5, 9, 5, 8, 3, 5, 9], [7, 4, 8, 3, 2, 7, 4, 8, 3, 2, 7, 4, 8, 3, 2], [4, 9, 5, 4, 6, 4, 9, 5, 4, 6, 4, 9, 5, 4, 6], [8, 2, 3, 2, 8, 8, 2, 3, 2, 8, 8, 2, 3, 2, 8], [3, 4, 5, 3, 7, 3, 4, 5, 3, 7, 3, 4, 5, 3, 7]]}], ""test"": [{""input"": [[7, 5, 3, 4, 3], [2, 3, 8, 6, 7], [5, 7, 2, 7, 2], [4, 5, 8, 9, 4], [3, 6, 5, 2, 5]], ""output"": [[7, 5, 3, 4, 3, 7, 5, 3, 4, 3, 7, 5, 3, 4, 3], [2, 3, 8, 6, 7, 2, 3, 8, 6, 7, 2, 3, 8, 6, 7], [5, 7, 2, 7, 2, 5, 7, 2, 7, 2, 5, 7, 2, 7, 2], [4, 5, 8, 9, 4, 4, 5, 8, 9, 4, 4, 5, 8, 9, 4], [3, 6, 5, 2, 5, 3, 6, 5, 2, 5, 3, 6, 5, 2, 5], [3, 5, 3, 4, 7, 3, 5, 3, 4, 7, 3, 5, 3, 4, 7], [7, 3, 8, 6, 2, 7, 3, 8, 6, 2, 7, 3, 8, 6, 2], [2, 7, 2, 7, 5, 2, 7, 2, 7, 5, 2, 7, 2, 7, 5], [4, 5, 8, 9, 4, 4, 5, 8, 9, 4, 4, 5, 8, 9, 4], [5, 6, 5, 2, 3, 5, 6, 5, 2, 3, 5, 6, 5, 2, 3], [7, 5, 3, 4, 3, 7, 5, 3, 4, 3, 7, 5, 3, 4, 3], [2, 3, 8, 6, 7, 2, 3, 8, 6, 7, 2, 3, 8, 6, 7], [5, 7, 2, 7, 2, 5, 7, 2, 7, 2, 5, 7, 2, 7, 2], [4, 5, 8, 9, 4, 4, 5, 8, 9, 4, 4, 5, 8, 9, 4], [3, 6, 5, 2, 5, 3, 6, 5, 2, 5, 3, 6, 5, 2, 5]]}]}"
HoVSuhRWs8n72VoMSRjL8F,2025-07-21T15:52:22.685249,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 2, 9, 7, 2, 7], [6, 7, 5, 2, 6, 4], [4, 2, 6, 9, 5, 2], [7, 5, 7, 5, 3, 9], [3, 8, 9, 7, 5, 3], [9, 4, 5, 6, 2, 8]], ""output"": [[8, 2, 9, 7, 2, 7, 8, 2, 9, 7, 2, 7, 8, 2, 9, 7, 2, 7], [6, 7, 5, 2, 6, 4, 6, 7, 5, 2, 6, 4, 6, 7, 5, 2, 6, 4], [4, 2, 6, 9, 5, 2, 4, 2, 6, 9, 5, 2, 4, 2, 6, 9, 5, 2], [7, 5, 7, 5, 3, 9, 7, 5, 7, 5, 3, 9, 7, 5, 7, 5, 3, 9], [3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3], [9, 4, 5, 6, 2, 8, 9, 4, 5, 6, 2, 8, 9, 4, 5, 6, 2, 8], [7, 2, 9, 7, 2, 8, 7, 2, 9, 7, 2, 8, 7, 2, 9, 7, 2, 8], [4, 7, 5, 2, 6, 6, 4, 7, 5, 2, 6, 6, 4, 7, 5, 2, 6, 6], [2, 2, 6, 9, 5, 4, 2, 2, 6, 9, 5, 4, 2, 2, 6, 9, 5, 4], [9, 5, 7, 5, 3, 7, 9, 5, 7, 5, 3, 7, 9, 5, 7, 5, 3, 7], [3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3], [8, 4, 5, 6, 2, 9, 8, 4, 5, 6, 2, 9, 8, 4, 5, 6, 2, 9], [8, 2, 9, 7, 2, 7, 8, 2, 9, 7, 2, 7, 8, 2, 9, 7, 2, 7], [6, 7, 5, 2, 6, 4, 6, 7, 5, 2, 6, 4, 6, 7, 5, 2, 6, 4], [4, 2, 6, 9, 5, 2, 4, 2, 6, 9, 5, 2, 4, 2, 6, 9, 5, 2], [7, 5, 7, 5, 3, 9, 7, 5, 7, 5, 3, 9, 7, 5, 7, 5, 3, 9], [3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3, 3, 8, 9, 7, 5, 3], [9, 4, 5, 6, 2, 8, 9, 4, 5, 6, 2, 8, 9, 4, 5, 6, 2, 8]]}, {""input"": [[3, 9, 6, 2, 6, 8], [2, 6, 3, 4, 5, 9], [5, 8, 5, 2, 3, 8], [2, 9, 7, 8, 5, 4], [4, 3, 4, 3, 4, 7], [5, 2, 6, 9, 8, 5]], ""output"": [[3, 9, 6, 2, 6, 8, 3, 9, 6, 2, 6, 8, 3, 9, 6, 2, 6, 8], [2, 6, 3, 4, 5, 9, 2, 6, 3, 4, 5, 9, 2, 6, 3, 4, 5, 9], [5, 8, 5, 2, 3, 8, 5, 8, 5, 2, 3, 8, 5, 8, 5, 2, 3, 8], [2, 9, 7, 8, 5, 4, 2, 9, 7, 8, 5, 4, 2, 9, 7, 8, 5, 4], [4, 3, 4, 3, 4, 7, 4, 3, 4, 3, 4, 7, 4, 3, 4, 3, 4, 7], [5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5], [8, 9, 6, 2, 6, 3, 8, 9, 6, 2, 6, 3, 8, 9, 6, 2, 6, 3], [9, 6, 3, 4, 5, 2, 9, 6, 3, 4, 5, 2, 9, 6, 3, 4, 5, 2], [8, 8, 5, 2, 3, 5, 8, 8, 5, 2, 3, 5, 8, 8, 5, 2, 3, 5], [4, 9, 7, 8, 5, 2, 4, 9, 7, 8, 5, 2, 4, 9, 7, 8, 5, 2], [7, 3, 4, 3, 4, 4, 7, 3, 4, 3, 4, 4, 7, 3, 4, 3, 4, 4], [5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5], [3, 9, 6, 2, 6, 8, 3, 9, 6, 2, 6, 8, 3, 9, 6, 2, 6, 8], [2, 6, 3, 4, 5, 9, 2, 6, 3, 4, 5, 9, 2, 6, 3, 4, 5, 9], [5, 8, 5, 2, 3, 8, 5, 8, 5, 2, 3, 8, 5, 8, 5, 2, 3, 8], [2, 9, 7, 8, 5, 4, 2, 9, 7, 8, 5, 4, 2, 9, 7, 8, 5, 4], [4, 3, 4, 3, 4, 7, 4, 3, 4, 3, 4, 7, 4, 3, 4, 3, 4, 7], [5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5, 5, 2, 6, 9, 8, 5]]}, {""input"": [[3, 6, 7, 5, 9, 6], [7, 9, 8, 6, 3, 5], [5, 2, 7, 5, 9, 2], [7, 8, 6, 9, 7, 6], [5, 7, 2, 3, 5, 4], [9, 8, 6, 7, 2, 1]], ""output"": [[3, 6, 7, 5, 9, 6, 3, 6, 7, 5, 9, 6, 3, 6, 7, 5, 9, 6], [7, 9, 8, 6, 3, 5, 7, 9, 8, 6, 3, 5, 7, 9, 8, 6, 3, 5], [5, 2, 7, 5, 9, 2, 5, 2, 7, 5, 9, 2, 5, 2, 7, 5, 9, 2], [7, 8, 6, 9, 7, 6, 7, 8, 6, 9, 7, 6, 7, 8, 6, 9, 7, 6], [5, 7, 2, 3, 5, 4, 5, 7, 2, 3, 5, 4, 5, 7, 2, 3, 5, 4], [9, 8, 6, 7, 2, 1, 9, 8, 6, 7, 2, 1, 9, 8, 6, 7, 2, 1], [6, 6, 7, 5, 9, 3, 6, 6, 7, 5, 9, 3, 6, 6, 7, 5, 9, 3], [5, 9, 8, 6, 3, 7, 5, 9, 8, 6, 3, 7, 5, 9, 8, 6, 3, 7], [2, 2, 7, 5, 9, 5, 2, 2, 7, 5, 9, 5, 2, 2, 7, 5, 9, 5], [6, 8, 6, 9, 7, 7, 6, 8, 6, 9, 7, 7, 6, 8, 6, 9, 7, 7], [4, 7, 2, 3, 5, 5, 4, 7, 2, 3, 5, 5, 4, 7, 2, 3, 5, 5], [1, 8, 6, 7, 2, 9, 1, 8, 6, 7, 2, 9, 1, 8, 6, 7, 2, 9], [3, 6, 7, 5, 9, 6, 3, 6, 7, 5, 9, 6, 3, 6, 7, 5, 9, 6], [7, 9, 8, 6, 3, 5, 7, 9, 8, 6, 3, 5, 7, 9, 8, 6, 3, 5], [5, 2, 7, 5, 9, 2, 5, 2, 7, 5, 9, 2, 5, 2, 7, 5, 9, 2], [7, 8, 6, 9, 7, 6, 7, 8, 6, 9, 7, 6, 7, 8, 6, 9, 7, 6], [5, 7, 2, 3, 5, 4, 5, 7, 2, 3, 5, 4, 5, 7, 2, 3, 5, 4], [9, 8, 6, 7, 2, 1, 9, 8, 6, 7, 2, 1, 9, 8, 6, 7, 2, 1]]}], ""test"": [{""input"": [[6, 4, 3, 4, 3, 8], [3, 7, 5, 9, 6, 2], [5, 4, 8, 4, 9, 5], [7, 5, 4, 3, 6, 2], [8, 3, 5, 7, 9, 5], [4, 7, 9, 5, 6, 1]], ""output"": [[6, 4, 3, 4, 3, 8, 6, 4, 3, 4, 3, 8, 6, 4, 3, 4, 3, 8], [3, 7, 5, 9, 6, 2, 3, 7, 5, 9, 6, 2, 3, 7, 5, 9, 6, 2], [5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5], [7, 5, 4, 3, 6, 2, 7, 5, 4, 3, 6, 2, 7, 5, 4, 3, 6, 2], [8, 3, 5, 7, 9, 5, 8, 3, 5, 7, 9, 5, 8, 3, 5, 7, 9, 5], [4, 7, 9, 5, 6, 1, 4, 7, 9, 5, 6, 1, 4, 7, 9, 5, 6, 1], [8, 4, 3, 4, 3, 6, 8, 4, 3, 4, 3, 6, 8, 4, 3, 4, 3, 6], [2, 7, 5, 9, 6, 3, 2, 7, 5, 9, 6, 3, 2, 7, 5, 9, 6, 3], [5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5], [2, 5, 4, 3, 6, 7, 2, 5, 4, 3, 6, 7, 2, 5, 4, 3, 6, 7], [5, 3, 5, 7, 9, 8, 5, 3, 5, 7, 9, 8, 5, 3, 5, 7, 9, 8], [1, 7, 9, 5, 6, 4, 1, 7, 9, 5, 6, 4, 1, 7, 9, 5, 6, 4], [6, 4, 3, 4, 3, 8, 6, 4, 3, 4, 3, 8, 6, 4, 3, 4, 3, 8], [3, 7, 5, 9, 6, 2, 3, 7, 5, 9, 6, 2, 3, 7, 5, 9, 6, 2], [5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5, 5, 4, 8, 4, 9, 5], [7, 5, 4, 3, 6, 2, 7, 5, 4, 3, 6, 2, 7, 5, 4, 3, 6, 2], [8, 3, 5, 7, 9, 5, 8, 3, 5, 7, 9, 5, 8, 3, 5, 7, 9, 5], [4, 7, 9, 5, 6, 1, 4, 7, 9, 5, 6, 1, 4, 7, 9, 5, 6, 1]]}]}"
XHy6yHE9D8UBQLFxJV8C3w,2025-07-21T15:52:22.687707,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 9, 3, 9, 2], [8, 5, 8, 3, 4], [7, 3, 9, 7, 5], [3, 9, 2, 6, 8], [8, 3, 6, 3, 2]], ""output"": [[6, 9, 3, 9, 2, 6, 9, 3, 9, 2, 6, 9, 3, 9, 2], [8, 5, 8, 3, 4, 8, 5, 8, 3, 4, 8, 5, 8, 3, 4], [7, 3, 9, 7, 5, 7, 3, 9, 7, 5, 7, 3, 9, 7, 5], [3, 9, 2, 6, 8, 3, 9, 2, 6, 8, 3, 9, 2, 6, 8], [8, 3, 6, 3, 2, 8, 3, 6, 3, 2, 8, 3, 6, 3, 2], [2, 9, 3, 9, 6, 2, 9, 3, 9, 6, 2, 9, 3, 9, 6], [4, 5, 8, 3, 8, 4, 5, 8, 3, 8, 4, 5, 8, 3, 8], [5, 3, 9, 7, 7, 5, 3, 9, 7, 7, 5, 3, 9, 7, 7], [8, 9, 2, 6, 3, 8, 9, 2, 6, 3, 8, 9, 2, 6, 3], [2, 3, 6, 3, 8, 2, 3, 6, 3, 8, 2, 3, 6, 3, 8], [6, 9, 3, 9, 2, 6, 9, 3, 9, 2, 6, 9, 3, 9, 2], [8, 5, 8, 3, 4, 8, 5, 8, 3, 4, 8, 5, 8, 3, 4], [7, 3, 9, 7, 5, 7, 3, 9, 7, 5, 7, 3, 9, 7, 5], [3, 9, 2, 6, 8, 3, 9, 2, 6, 8, 3, 9, 2, 6, 8], [8, 3, 6, 3, 2, 8, 3, 6, 3, 2, 8, 3, 6, 3, 2]]}, {""input"": [[9, 7, 2, 6, 4], [7, 4, 7, 9, 8], [5, 6, 9, 6, 3], [6, 4, 6, 3, 4], [3, 5, 4, 6, 7]], ""output"": [[9, 7, 2, 6, 4, 9, 7, 2, 6, 4, 9, 7, 2, 6, 4], [7, 4, 7, 9, 8, 7, 4, 7, 9, 8, 7, 4, 7, 9, 8], [5, 6, 9, 6, 3, 5, 6, 9, 6, 3, 5, 6, 9, 6, 3], [6, 4, 6, 3, 4, 6, 4, 6, 3, 4, 6, 4, 6, 3, 4], [3, 5, 4, 6, 7, 3, 5, 4, 6, 7, 3, 5, 4, 6, 7], [4, 7, 2, 6, 9, 4, 7, 2, 6, 9, 4, 7, 2, 6, 9], [8, 4, 7, 9, 7, 8, 4, 7, 9, 7, 8, 4, 7, 9, 7], [3, 6, 9, 6, 5, 3, 6, 9, 6, 5, 3, 6, 9, 6, 5], [4, 4, 6, 3, 6, 4, 4, 6, 3, 6, 4, 4, 6, 3, 6], [7, 5, 4, 6, 3, 7, 5, 4, 6, 3, 7, 5, 4, 6, 3], [9, 7, 2, 6, 4, 9, 7, 2, 6, 4, 9, 7, 2, 6, 4], [7, 4, 7, 9, 8, 7, 4, 7, 9, 8, 7, 4, 7, 9, 8], [5, 6, 9, 6, 3, 5, 6, 9, 6, 3, 5, 6, 9, 6, 3], [6, 4, 6, 3, 4, 6, 4, 6, 3, 4, 6, 4, 6, 3, 4], [3, 5, 4, 6, 7, 3, 5, 4, 6, 7, 3, 5, 4, 6, 7]]}, {""input"": [[7, 8, 7, 2, 4], [2, 3, 6, 7, 5], [4, 9, 5, 8, 3], [3, 5, 3, 6, 5], [8, 4, 5, 7, 2]], ""output"": [[7, 8, 7, 2, 4, 7, 8, 7, 2, 4, 7, 8, 7, 2, 4], [2, 3, 6, 7, 5, 2, 3, 6, 7, 5, 2, 3, 6, 7, 5], [4, 9, 5, 8, 3, 4, 9, 5, 8, 3, 4, 9, 5, 8, 3], [3, 5, 3, 6, 5, 3, 5, 3, 6, 5, 3, 5, 3, 6, 5], [8, 4, 5, 7, 2, 8, 4, 5, 7, 2, 8, 4, 5, 7, 2], [4, 8, 7, 2, 7, 4, 8, 7, 2, 7, 4, 8, 7, 2, 7], [5, 3, 6, 7, 2, 5, 3, 6, 7, 2, 5, 3, 6, 7, 2], [3, 9, 5, 8, 4, 3, 9, 5, 8, 4, 3, 9, 5, 8, 4], [5, 5, 3, 6, 3, 5, 5, 3, 6, 3, 5, 5, 3, 6, 3], [2, 4, 5, 7, 8, 2, 4, 5, 7, 8, 2, 4, 5, 7, 8], [7, 8, 7, 2, 4, 7, 8, 7, 2, 4, 7, 8, 7, 2, 4], [2, 3, 6, 7, 5, 2, 3, 6, 7, 5, 2, 3, 6, 7, 5], [4, 9, 5, 8, 3, 4, 9, 5, 8, 3, 4, 9, 5, 8, 3], [3, 5, 3, 6, 5, 3, 5, 3, 6, 5, 3, 5, 3, 6, 5], [8, 4, 5, 7, 2, 8, 4, 5, 7, 2, 8, 4, 5, 7, 2]]}], ""test"": [{""input"": [[8, 9, 7, 5, 4], [6, 5, 2, 6, 3], [3, 7, 9, 2, 9], [9, 6, 4, 8, 6], [6, 7, 6, 7, 4]], ""output"": [[8, 9, 7, 5, 4, 8, 9, 7, 5, 4, 8, 9, 7, 5, 4], [6, 5, 2, 6, 3, 6, 5, 2, 6, 3, 6, 5, 2, 6, 3], [3, 7, 9, 2, 9, 3, 7, 9, 2, 9, 3, 7, 9, 2, 9], [9, 6, 4, 8, 6, 9, 6, 4, 8, 6, 9, 6, 4, 8, 6], [6, 7, 6, 7, 4, 6, 7, 6, 7, 4, 6, 7, 6, 7, 4], [4, 9, 7, 5, 8, 4, 9, 7, 5, 8, 4, 9, 7, 5, 8], [3, 5, 2, 6, 6, 3, 5, 2, 6, 6, 3, 5, 2, 6, 6], [9, 7, 9, 2, 3, 9, 7, 9, 2, 3, 9, 7, 9, 2, 3], [6, 6, 4, 8, 9, 6, 6, 4, 8, 9, 6, 6, 4, 8, 9], [4, 7, 6, 7, 6, 4, 7, 6, 7, 6, 4, 7, 6, 7, 6], [8, 9, 7, 5, 4, 8, 9, 7, 5, 4, 8, 9, 7, 5, 4], [6, 5, 2, 6, 3, 6, 5, 2, 6, 3, 6, 5, 2, 6, 3], [3, 7, 9, 2, 9, 3, 7, 9, 2, 9, 3, 7, 9, 2, 9], [9, 6, 4, 8, 6, 9, 6, 4, 8, 6, 9, 6, 4, 8, 6], [6, 7, 6, 7, 4, 6, 7, 6, 7, 4, 6, 7, 6, 7, 4]]}]}"
7Mzbc9h8ueNNcrj4Z6Vq6W,2025-07-21T15:52:22.690646,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 4, 5, 3, 9, 2, 9], [8, 3, 4, 2, 8, 9, 6], [2, 7, 9, 3, 4, 6, 9], [8, 2, 3, 5, 6, 8, 5], [7, 5, 8, 6, 7, 9, 6], [3, 6, 3, 5, 4, 7, 4], [8, 2, 7, 8, 2, 4, 3]], ""output"": [[3, 4, 5, 3, 9, 2, 9, 3, 4, 5, 3, 9, 2, 9, 3, 4, 5, 3, 9, 2, 9], [8, 3, 4, 2, 8, 9, 6, 8, 3, 4, 2, 8, 9, 6, 8, 3, 4, 2, 8, 9, 6], [2, 7, 9, 3, 4, 6, 9, 2, 7, 9, 3, 4, 6, 9, 2, 7, 9, 3, 4, 6, 9], [8, 2, 3, 5, 6, 8, 5, 8, 2, 3, 5, 6, 8, 5, 8, 2, 3, 5, 6, 8, 5], [7, 5, 8, 6, 7, 9, 6, 7, 5, 8, 6, 7, 9, 6, 7, 5, 8, 6, 7, 9, 6], [3, 6, 3, 5, 4, 7, 4, 3, 6, 3, 5, 4, 7, 4, 3, 6, 3, 5, 4, 7, 4], [8, 2, 7, 8, 2, 4, 3, 8, 2, 7, 8, 2, 4, 3, 8, 2, 7, 8, 2, 4, 3], [9, 4, 5, 3, 9, 2, 3, 9, 4, 5, 3, 9, 2, 3, 9, 4, 5, 3, 9, 2, 3], [6, 3, 4, 2, 8, 9, 8, 6, 3, 4, 2, 8, 9, 8, 6, 3, 4, 2, 8, 9, 8], [9, 7, 9, 3, 4, 6, 2, 9, 7, 9, 3, 4, 6, 2, 9, 7, 9, 3, 4, 6, 2], [5, 2, 3, 5, 6, 8, 8, 5, 2, 3, 5, 6, 8, 8, 5, 2, 3, 5, 6, 8, 8], [6, 5, 8, 6, 7, 9, 7, 6, 5, 8, 6, 7, 9, 7, 6, 5, 8, 6, 7, 9, 7], [4, 6, 3, 5, 4, 7, 3, 4, 6, 3, 5, 4, 7, 3, 4, 6, 3, 5, 4, 7, 3], [3, 2, 7, 8, 2, 4, 8, 3, 2, 7, 8, 2, 4, 8, 3, 2, 7, 8, 2, 4, 8], [3, 4, 5, 3, 9, 2, 9, 3, 4, 5, 3, 9, 2, 9, 3, 4, 5, 3, 9, 2, 9], [8, 3, 4, 2, 8, 9, 6, 8, 3, 4, 2, 8, 9, 6, 8, 3, 4, 2, 8, 9, 6], [2, 7, 9, 3, 4, 6, 9, 2, 7, 9, 3, 4, 6, 9, 2, 7, 9, 3, 4, 6, 9], [8, 2, 3, 5, 6, 8, 5, 8, 2, 3, 5, 6, 8, 5, 8, 2, 3, 5, 6, 8, 5], [7, 5, 8, 6, 7, 9, 6, 7, 5, 8, 6, 7, 9, 6, 7, 5, 8, 6, 7, 9, 6], [3, 6, 3, 5, 4, 7, 4, 3, 6, 3, 5, 4, 7, 4, 3, 6, 3, 5, 4, 7, 4], [8, 2, 7, 8, 2, 4, 3, 8, 2, 7, 8, 2, 4, 3, 8, 2, 7, 8, 2, 4, 3]]}, {""input"": [[6, 7, 9, 7, 2, 6, 2], [2, 3, 7, 5, 7, 3, 6], [9, 5, 4, 3, 4, 8, 9], [2, 9, 2, 6, 7, 4, 6], [8, 4, 3, 5, 3, 2, 3], [5, 7, 5, 8, 4, 7, 9], [2, 6, 4, 2, 6, 3, 7]], ""output"": [[6, 7, 9, 7, 2, 6, 2, 6, 7, 9, 7, 2, 6, 2, 6, 7, 9, 7, 2, 6, 2], [2, 3, 7, 5, 7, 3, 6, 2, 3, 7, 5, 7, 3, 6, 2, 3, 7, 5, 7, 3, 6], [9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9], [2, 9, 2, 6, 7, 4, 6, 2, 9, 2, 6, 7, 4, 6, 2, 9, 2, 6, 7, 4, 6], [8, 4, 3, 5, 3, 2, 3, 8, 4, 3, 5, 3, 2, 3, 8, 4, 3, 5, 3, 2, 3], [5, 7, 5, 8, 4, 7, 9, 5, 7, 5, 8, 4, 7, 9, 5, 7, 5, 8, 4, 7, 9], [2, 6, 4, 2, 6, 3, 7, 2, 6, 4, 2, 6, 3, 7, 2, 6, 4, 2, 6, 3, 7], [2, 7, 9, 7, 2, 6, 6, 2, 7, 9, 7, 2, 6, 6, 2, 7, 9, 7, 2, 6, 6], [6, 3, 7, 5, 7, 3, 2, 6, 3, 7, 5, 7, 3, 2, 6, 3, 7, 5, 7, 3, 2], [9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9], [6, 9, 2, 6, 7, 4, 2, 6, 9, 2, 6, 7, 4, 2, 6, 9, 2, 6, 7, 4, 2], [3, 4, 3, 5, 3, 2, 8, 3, 4, 3, 5, 3, 2, 8, 3, 4, 3, 5, 3, 2, 8], [9, 7, 5, 8, 4, 7, 5, 9, 7, 5, 8, 4, 7, 5, 9, 7, 5, 8, 4, 7, 5], [7, 6, 4, 2, 6, 3, 2, 7, 6, 4, 2, 6, 3, 2, 7, 6, 4, 2, 6, 3, 2], [6, 7, 9, 7, 2, 6, 2, 6, 7, 9, 7, 2, 6, 2, 6, 7, 9, 7, 2, 6, 2], [2, 3, 7, 5, 7, 3, 6, 2, 3, 7, 5, 7, 3, 6, 2, 3, 7, 5, 7, 3, 6], [9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9, 9, 5, 4, 3, 4, 8, 9], [2, 9, 2, 6, 7, 4, 6, 2, 9, 2, 6, 7, 4, 6, 2, 9, 2, 6, 7, 4, 6], [8, 4, 3, 5, 3, 2, 3, 8, 4, 3, 5, 3, 2, 3, 8, 4, 3, 5, 3, 2, 3], [5, 7, 5, 8, 4, 7, 9, 5, 7, 5, 8, 4, 7, 9, 5, 7, 5, 8, 4, 7, 9], [2, 6, 4, 2, 6, 3, 7, 2, 6, 4, 2, 6, 3, 7, 2, 6, 4, 2, 6, 3, 7]]}, {""input"": [[8, 3, 8, 5, 3, 2, 4], [6, 5, 9, 8, 4, 3, 9], [2, 9, 6, 7, 9, 4, 5], [5, 2, 8, 5, 4, 5, 7], [6, 5, 9, 7, 5, 7, 5], [2, 3, 7, 3, 9, 2, 9], [7, 9, 2, 7, 8, 6, 3]], ""output"": [[8, 3, 8, 5, 3, 2, 4, 8, 3, 8, 5, 3, 2, 4, 8, 3, 8, 5, 3, 2, 4], [6, 5, 9, 8, 4, 3, 9, 6, 5, 9, 8, 4, 3, 9, 6, 5, 9, 8, 4, 3, 9], [2, 9, 6, 7, 9, 4, 5, 2, 9, 6, 7, 9, 4, 5, 2, 9, 6, 7, 9, 4, 5], [5, 2, 8, 5, 4, 5, 7, 5, 2, 8, 5, 4, 5, 7, 5, 2, 8, 5, 4, 5, 7], [6, 5, 9, 7, 5, 7, 5, 6, 5, 9, 7, 5, 7, 5, 6, 5, 9, 7, 5, 7, 5], [2, 3, 7, 3, 9, 2, 9, 2, 3, 7, 3, 9, 2, 9, 2, 3, 7, 3, 9, 2, 9], [7, 9, 2, 7, 8, 6, 3, 7, 9, 2, 7, 8, 6, 3, 7, 9, 2, 7, 8, 6, 3], [4, 3, 8, 5, 3, 2, 8, 4, 3, 8, 5, 3, 2, 8, 4, 3, 8, 5, 3, 2, 8], [9, 5, 9, 8, 4, 3, 6, 9, 5, 9, 8, 4, 3, 6, 9, 5, 9, 8, 4, 3, 6], [5, 9, 6, 7, 9, 4, 2, 5, 9, 6, 7, 9, 4, 2, 5, 9, 6, 7, 9, 4, 2], [7, 2, 8, 5, 4, 5, 5, 7, 2, 8, 5, 4, 5, 5, 7, 2, 8, 5, 4, 5, 5], [5, 5, 9, 7, 5, 7, 6, 5, 5, 9, 7, 5, 7, 6, 5, 5, 9, 7, 5, 7, 6], [9, 3, 7, 3, 9, 2, 2, 9, 3, 7, 3, 9, 2, 2, 9, 3, 7, 3, 9, 2, 2], [3, 9, 2, 7, 8, 6, 7, 3, 9, 2, 7, 8, 6, 7, 3, 9, 2, 7, 8, 6, 7], [8, 3, 8, 5, 3, 2, 4, 8, 3, 8, 5, 3, 2, 4, 8, 3, 8, 5, 3, 2, 4], [6, 5, 9, 8, 4, 3, 9, 6, 5, 9, 8, 4, 3, 9, 6, 5, 9, 8, 4, 3, 9], [2, 9, 6, 7, 9, 4, 5, 2, 9, 6, 7, 9, 4, 5, 2, 9, 6, 7, 9, 4, 5], [5, 2, 8, 5, 4, 5, 7, 5, 2, 8, 5, 4, 5, 7, 5, 2, 8, 5, 4, 5, 7], [6, 5, 9, 7, 5, 7, 5, 6, 5, 9, 7, 5, 7, 5, 6, 5, 9, 7, 5, 7, 5], [2, 3, 7, 3, 9, 2, 9, 2, 3, 7, 3, 9, 2, 9, 2, 3, 7, 3, 9, 2, 9], [7, 9, 2, 7, 8, 6, 3, 7, 9, 2, 7, 8, 6, 3, 7, 9, 2, 7, 8, 6, 3]]}], ""test"": [{""input"": [[7, 3, 4, 7, 3, 9, 2], [4, 6, 3, 5, 6, 5, 6], [3, 5, 9, 8, 5, 6, 4], [9, 8, 7, 3, 6, 2, 3], [3, 4, 9, 5, 9, 3, 2], [6, 5, 2, 4, 7, 4, 7], [8, 3, 4, 6, 8, 9, 2]], ""output"": [[7, 3, 4, 7, 3, 9, 2, 7, 3, 4, 7, 3, 9, 2, 7, 3, 4, 7, 3, 9, 2], [4, 6, 3, 5, 6, 5, 6, 4, 6, 3, 5, 6, 5, 6, 4, 6, 3, 5, 6, 5, 6], [3, 5, 9, 8, 5, 6, 4, 3, 5, 9, 8, 5, 6, 4, 3, 5, 9, 8, 5, 6, 4], [9, 8, 7, 3, 6, 2, 3, 9, 8, 7, 3, 6, 2, 3, 9, 8, 7, 3, 6, 2, 3], [3, 4, 9, 5, 9, 3, 2, 3, 4, 9, 5, 9, 3, 2, 3, 4, 9, 5, 9, 3, 2], [6, 5, 2, 4, 7, 4, 7, 6, 5, 2, 4, 7, 4, 7, 6, 5, 2, 4, 7, 4, 7], [8, 3, 4, 6, 8, 9, 2, 8, 3, 4, 6, 8, 9, 2, 8, 3, 4, 6, 8, 9, 2], [2, 3, 4, 7, 3, 9, 7, 2, 3, 4, 7, 3, 9, 7, 2, 3, 4, 7, 3, 9, 7], [6, 6, 3, 5, 6, 5, 4, 6, 6, 3, 5, 6, 5, 4, 6, 6, 3, 5, 6, 5, 4], [4, 5, 9, 8, 5, 6, 3, 4, 5, 9, 8, 5, 6, 3, 4, 5, 9, 8, 5, 6, 3], [3, 8, 7, 3, 6, 2, 9, 3, 8, 7, 3, 6, 2, 9, 3, 8, 7, 3, 6, 2, 9], [2, 4, 9, 5, 9, 3, 3, 2, 4, 9, 5, 9, 3, 3, 2, 4, 9, 5, 9, 3, 3], [7, 5, 2, 4, 7, 4, 6, 7, 5, 2, 4, 7, 4, 6, 7, 5, 2, 4, 7, 4, 6], [2, 3, 4, 6, 8, 9, 8, 2, 3, 4, 6, 8, 9, 8, 2, 3, 4, 6, 8, 9, 8], [7, 3, 4, 7, 3, 9, 2, 7, 3, 4, 7, 3, 9, 2, 7, 3, 4, 7, 3, 9, 2], [4, 6, 3, 5, 6, 5, 6, 4, 6, 3, 5, 6, 5, 6, 4, 6, 3, 5, 6, 5, 6], [3, 5, 9, 8, 5, 6, 4, 3, 5, 9, 8, 5, 6, 4, 3, 5, 9, 8, 5, 6, 4], [9, 8, 7, 3, 6, 2, 3, 9, 8, 7, 3, 6, 2, 3, 9, 8, 7, 3, 6, 2, 3], [3, 4, 9, 5, 9, 3, 2, 3, 4, 9, 5, 9, 3, 2, 3, 4, 9, 5, 9, 3, 2], [6, 5, 2, 4, 7, 4, 7, 6, 5, 2, 4, 7, 4, 7, 6, 5, 2, 4, 7, 4, 7], [8, 3, 4, 6, 8, 9, 2, 8, 3, 4, 6, 8, 9, 2, 8, 3, 4, 6, 8, 9, 2]]}]}"
9UEpjHBftxrgMRXHf55tmm,2025-07-21T15:52:22.693758,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 7, 9, 7, 3, 6, 4], [4, 6, 8, 4, 8, 2, 7], [5, 3, 5, 3, 4, 7, 3], [2, 6, 8, 5, 2, 3, 9], [9, 2, 7, 3, 5, 6, 3], [5, 8, 6, 7, 3, 5, 8], [2, 9, 7, 9, 7, 3, 1]], ""output"": [[3, 7, 9, 7, 3, 6, 4, 3, 7, 9, 7, 3, 6, 4, 3, 7, 9, 7, 3, 6, 4], [4, 6, 8, 4, 8, 2, 7, 4, 6, 8, 4, 8, 2, 7, 4, 6, 8, 4, 8, 2, 7], [5, 3, 5, 3, 4, 7, 3, 5, 3, 5, 3, 4, 7, 3, 5, 3, 5, 3, 4, 7, 3], [2, 6, 8, 5, 2, 3, 9, 2, 6, 8, 5, 2, 3, 9, 2, 6, 8, 5, 2, 3, 9], [9, 2, 7, 3, 5, 6, 3, 9, 2, 7, 3, 5, 6, 3, 9, 2, 7, 3, 5, 6, 3], [5, 8, 6, 7, 3, 5, 8, 5, 8, 6, 7, 3, 5, 8, 5, 8, 6, 7, 3, 5, 8], [2, 9, 7, 9, 7, 3, 1, 2, 9, 7, 9, 7, 3, 1, 2, 9, 7, 9, 7, 3, 1], [4, 7, 9, 7, 3, 6, 3, 4, 7, 9, 7, 3, 6, 3, 4, 7, 9, 7, 3, 6, 3], [7, 6, 8, 4, 8, 2, 4, 7, 6, 8, 4, 8, 2, 4, 7, 6, 8, 4, 8, 2, 4], [3, 3, 5, 3, 4, 7, 5, 3, 3, 5, 3, 4, 7, 5, 3, 3, 5, 3, 4, 7, 5], [9, 6, 8, 5, 2, 3, 2, 9, 6, 8, 5, 2, 3, 2, 9, 6, 8, 5, 2, 3, 2], [3, 2, 7, 3, 5, 6, 9, 3, 2, 7, 3, 5, 6, 9, 3, 2, 7, 3, 5, 6, 9], [8, 8, 6, 7, 3, 5, 5, 8, 8, 6, 7, 3, 5, 5, 8, 8, 6, 7, 3, 5, 5], [1, 9, 7, 9, 7, 3, 2, 1, 9, 7, 9, 7, 3, 2, 1, 9, 7, 9, 7, 3, 2], [3, 7, 9, 7, 3, 6, 4, 3, 7, 9, 7, 3, 6, 4, 3, 7, 9, 7, 3, 6, 4], [4, 6, 8, 4, 8, 2, 7, 4, 6, 8, 4, 8, 2, 7, 4, 6, 8, 4, 8, 2, 7], [5, 3, 5, 3, 4, 7, 3, 5, 3, 5, 3, 4, 7, 3, 5, 3, 5, 3, 4, 7, 3], [2, 6, 8, 5, 2, 3, 9, 2, 6, 8, 5, 2, 3, 9, 2, 6, 8, 5, 2, 3, 9], [9, 2, 7, 3, 5, 6, 3, 9, 2, 7, 3, 5, 6, 3, 9, 2, 7, 3, 5, 6, 3], [5, 8, 6, 7, 3, 5, 8, 5, 8, 6, 7, 3, 5, 8, 5, 8, 6, 7, 3, 5, 8], [2, 9, 7, 9, 7, 3, 1, 2, 9, 7, 9, 7, 3, 1, 2, 9, 7, 9, 7, 3, 1]]}, {""input"": [[8, 5, 3, 2, 7, 2, 3], [2, 7, 6, 5, 4, 3, 6], [9, 8, 3, 7, 6, 5, 2], [4, 7, 6, 2, 8, 4, 3], [5, 3, 5, 8, 4, 5, 7], [7, 4, 6, 5, 3, 9, 8], [5, 2, 8, 3, 8, 7, 5]], ""output"": [[8, 5, 3, 2, 7, 2, 3, 8, 5, 3, 2, 7, 2, 3, 8, 5, 3, 2, 7, 2, 3], [2, 7, 6, 5, 4, 3, 6, 2, 7, 6, 5, 4, 3, 6, 2, 7, 6, 5, 4, 3, 6], [9, 8, 3, 7, 6, 5, 2, 9, 8, 3, 7, 6, 5, 2, 9, 8, 3, 7, 6, 5, 2], [4, 7, 6, 2, 8, 4, 3, 4, 7, 6, 2, 8, 4, 3, 4, 7, 6, 2, 8, 4, 3], [5, 3, 5, 8, 4, 5, 7, 5, 3, 5, 8, 4, 5, 7, 5, 3, 5, 8, 4, 5, 7], [7, 4, 6, 5, 3, 9, 8, 7, 4, 6, 5, 3, 9, 8, 7, 4, 6, 5, 3, 9, 8], [5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5], [3, 5, 3, 2, 7, 2, 8, 3, 5, 3, 2, 7, 2, 8, 3, 5, 3, 2, 7, 2, 8], [6, 7, 6, 5, 4, 3, 2, 6, 7, 6, 5, 4, 3, 2, 6, 7, 6, 5, 4, 3, 2], [2, 8, 3, 7, 6, 5, 9, 2, 8, 3, 7, 6, 5, 9, 2, 8, 3, 7, 6, 5, 9], [3, 7, 6, 2, 8, 4, 4, 3, 7, 6, 2, 8, 4, 4, 3, 7, 6, 2, 8, 4, 4], [7, 3, 5, 8, 4, 5, 5, 7, 3, 5, 8, 4, 5, 5, 7, 3, 5, 8, 4, 5, 5], [8, 4, 6, 5, 3, 9, 7, 8, 4, 6, 5, 3, 9, 7, 8, 4, 6, 5, 3, 9, 7], [5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5], [8, 5, 3, 2, 7, 2, 3, 8, 5, 3, 2, 7, 2, 3, 8, 5, 3, 2, 7, 2, 3], [2, 7, 6, 5, 4, 3, 6, 2, 7, 6, 5, 4, 3, 6, 2, 7, 6, 5, 4, 3, 6], [9, 8, 3, 7, 6, 5, 2, 9, 8, 3, 7, 6, 5, 2, 9, 8, 3, 7, 6, 5, 2], [4, 7, 6, 2, 8, 4, 3, 4, 7, 6, 2, 8, 4, 3, 4, 7, 6, 2, 8, 4, 3], [5, 3, 5, 8, 4, 5, 7, 5, 3, 5, 8, 4, 5, 7, 5, 3, 5, 8, 4, 5, 7], [7, 4, 6, 5, 3, 9, 8, 7, 4, 6, 5, 3, 9, 8, 7, 4, 6, 5, 3, 9, 8], [5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5, 5, 2, 8, 3, 8, 7, 5]]}, {""input"": [[4, 7, 4, 8, 6, 2, 6], [9, 3, 6, 5, 4, 7, 9], [4, 2, 3, 7, 8, 6, 8], [3, 5, 8, 5, 7, 9, 2], [8, 2, 4, 3, 6, 5, 4], [3, 7, 9, 7, 9, 8, 3], [2, 8, 5, 4, 3, 4, 8]], ""output"": [[4, 7, 4, 8, 6, 2, 6, 4, 7, 4, 8, 6, 2, 6, 4, 7, 4, 8, 6, 2, 6], [9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9], [4, 2, 3, 7, 8, 6, 8, 4, 2, 3, 7, 8, 6, 8, 4, 2, 3, 7, 8, 6, 8], [3, 5, 8, 5, 7, 9, 2, 3, 5, 8, 5, 7, 9, 2, 3, 5, 8, 5, 7, 9, 2], [8, 2, 4, 3, 6, 5, 4, 8, 2, 4, 3, 6, 5, 4, 8, 2, 4, 3, 6, 5, 4], [3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3], [2, 8, 5, 4, 3, 4, 8, 2, 8, 5, 4, 3, 4, 8, 2, 8, 5, 4, 3, 4, 8], [6, 7, 4, 8, 6, 2, 4, 6, 7, 4, 8, 6, 2, 4, 6, 7, 4, 8, 6, 2, 4], [9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9], [8, 2, 3, 7, 8, 6, 4, 8, 2, 3, 7, 8, 6, 4, 8, 2, 3, 7, 8, 6, 4], [2, 5, 8, 5, 7, 9, 3, 2, 5, 8, 5, 7, 9, 3, 2, 5, 8, 5, 7, 9, 3], [4, 2, 4, 3, 6, 5, 8, 4, 2, 4, 3, 6, 5, 8, 4, 2, 4, 3, 6, 5, 8], [3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3], [8, 8, 5, 4, 3, 4, 2, 8, 8, 5, 4, 3, 4, 2, 8, 8, 5, 4, 3, 4, 2], [4, 7, 4, 8, 6, 2, 6, 4, 7, 4, 8, 6, 2, 6, 4, 7, 4, 8, 6, 2, 6], [9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9, 9, 3, 6, 5, 4, 7, 9], [4, 2, 3, 7, 8, 6, 8, 4, 2, 3, 7, 8, 6, 8, 4, 2, 3, 7, 8, 6, 8], [3, 5, 8, 5, 7, 9, 2, 3, 5, 8, 5, 7, 9, 2, 3, 5, 8, 5, 7, 9, 2], [8, 2, 4, 3, 6, 5, 4, 8, 2, 4, 3, 6, 5, 4, 8, 2, 4, 3, 6, 5, 4], [3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3, 3, 7, 9, 7, 9, 8, 3], [2, 8, 5, 4, 3, 4, 8, 2, 8, 5, 4, 3, 4, 8, 2, 8, 5, 4, 3, 4, 8]]}], ""test"": [{""input"": [[7, 4, 7, 5, 2, 5, 2], [9, 7, 3, 8, 9, 6, 8], [7, 8, 5, 3, 2, 9, 5], [6, 9, 3, 9, 7, 3, 9], [8, 7, 9, 2, 6, 5, 2], [9, 6, 4, 9, 8, 2, 7], [3, 5, 8, 5, 6, 3, 5]], ""output"": [[7, 4, 7, 5, 2, 5, 2, 7, 4, 7, 5, 2, 5, 2, 7, 4, 7, 5, 2, 5, 2], [9, 7, 3, 8, 9, 6, 8, 9, 7, 3, 8, 9, 6, 8, 9, 7, 3, 8, 9, 6, 8], [7, 8, 5, 3, 2, 9, 5, 7, 8, 5, 3, 2, 9, 5, 7, 8, 5, 3, 2, 9, 5], [6, 9, 3, 9, 7, 3, 9, 6, 9, 3, 9, 7, 3, 9, 6, 9, 3, 9, 7, 3, 9], [8, 7, 9, 2, 6, 5, 2, 8, 7, 9, 2, 6, 5, 2, 8, 7, 9, 2, 6, 5, 2], [9, 6, 4, 9, 8, 2, 7, 9, 6, 4, 9, 8, 2, 7, 9, 6, 4, 9, 8, 2, 7], [3, 5, 8, 5, 6, 3, 5, 3, 5, 8, 5, 6, 3, 5, 3, 5, 8, 5, 6, 3, 5], [2, 4, 7, 5, 2, 5, 7, 2, 4, 7, 5, 2, 5, 7, 2, 4, 7, 5, 2, 5, 7], [8, 7, 3, 8, 9, 6, 9, 8, 7, 3, 8, 9, 6, 9, 8, 7, 3, 8, 9, 6, 9], [5, 8, 5, 3, 2, 9, 7, 5, 8, 5, 3, 2, 9, 7, 5, 8, 5, 3, 2, 9, 7], [9, 9, 3, 9, 7, 3, 6, 9, 9, 3, 9, 7, 3, 6, 9, 9, 3, 9, 7, 3, 6], [2, 7, 9, 2, 6, 5, 8, 2, 7, 9, 2, 6, 5, 8, 2, 7, 9, 2, 6, 5, 8], [7, 6, 4, 9, 8, 2, 9, 7, 6, 4, 9, 8, 2, 9, 7, 6, 4, 9, 8, 2, 9], [5, 5, 8, 5, 6, 3, 3, 5, 5, 8, 5, 6, 3, 3, 5, 5, 8, 5, 6, 3, 3], [7, 4, 7, 5, 2, 5, 2, 7, 4, 7, 5, 2, 5, 2, 7, 4, 7, 5, 2, 5, 2], [9, 7, 3, 8, 9, 6, 8, 9, 7, 3, 8, 9, 6, 8, 9, 7, 3, 8, 9, 6, 8], [7, 8, 5, 3, 2, 9, 5, 7, 8, 5, 3, 2, 9, 5, 7, 8, 5, 3, 2, 9, 5], [6, 9, 3, 9, 7, 3, 9, 6, 9, 3, 9, 7, 3, 9, 6, 9, 3, 9, 7, 3, 9], [8, 7, 9, 2, 6, 5, 2, 8, 7, 9, 2, 6, 5, 2, 8, 7, 9, 2, 6, 5, 2], [9, 6, 4, 9, 8, 2, 7, 9, 6, 4, 9, 8, 2, 7, 9, 6, 4, 9, 8, 2, 7], [3, 5, 8, 5, 6, 3, 5, 3, 5, 8, 5, 6, 3, 5, 3, 5, 8, 5, 6, 3, 5]]}]}"
Qmu7Y2nTvF5hhwH5FmVVv9,2025-07-21T15:52:22.696108,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 5, 4, 6], [2, 8, 9, 2], [3, 9, 6, 8], [9, 2, 8, 5]], ""output"": [[7, 5, 4, 6, 7, 5, 4, 6, 7, 5, 4, 6], [2, 8, 9, 2, 2, 8, 9, 2, 2, 8, 9, 2], [3, 9, 6, 8, 3, 9, 6, 8, 3, 9, 6, 8], [9, 2, 8, 5, 9, 2, 8, 5, 9, 2, 8, 5], [6, 5, 4, 7, 6, 5, 4, 7, 6, 5, 4, 7], [2, 8, 9, 2, 2, 8, 9, 2, 2, 8, 9, 2], [8, 9, 6, 3, 8, 9, 6, 3, 8, 9, 6, 3], [5, 2, 8, 9, 5, 2, 8, 9, 5, 2, 8, 9], [7, 5, 4, 6, 7, 5, 4, 6, 7, 5, 4, 6], [2, 8, 9, 2, 2, 8, 9, 2, 2, 8, 9, 2], [3, 9, 6, 8, 3, 9, 6, 8, 3, 9, 6, 8], [9, 2, 8, 5, 9, 2, 8, 5, 9, 2, 8, 5]]}, {""input"": [[6, 8, 9, 4], [7, 4, 3, 6], [6, 3, 9, 2], [4, 5, 4, 1]], ""output"": [[6, 8, 9, 4, 6, 8, 9, 4, 6, 8, 9, 4], [7, 4, 3, 6, 7, 4, 3, 6, 7, 4, 3, 6], [6, 3, 9, 2, 6, 3, 9, 2, 6, 3, 9, 2], [4, 5, 4, 1, 4, 5, 4, 1, 4, 5, 4, 1], [4, 8, 9, 6, 4, 8, 9, 6, 4, 8, 9, 6], [6, 4, 3, 7, 6, 4, 3, 7, 6, 4, 3, 7], [2, 3, 9, 6, 2, 3, 9, 6, 2, 3, 9, 6], [1, 5, 4, 4, 1, 5, 4, 4, 1, 5, 4, 4], [6, 8, 9, 4, 6, 8, 9, 4, 6, 8, 9, 4], [7, 4, 3, 6, 7, 4, 3, 6, 7, 4, 3, 6], [6, 3, 9, 2, 6, 3, 9, 2, 6, 3, 9, 2], [4, 5, 4, 1, 4, 5, 4, 1, 4, 5, 4, 1]]}, {""input"": [[2, 9, 2, 9], [6, 2, 6, 7], [7, 9, 2, 3], [8, 6, 5, 7]], ""output"": [[2, 9, 2, 9, 2, 9, 2, 9, 2, 9, 2, 9], [6, 2, 6, 7, 6, 2, 6, 7, 6, 2, 6, 7], [7, 9, 2, 3, 7, 9, 2, 3, 7, 9, 2, 3], [8, 6, 5, 7, 8, 6, 5, 7, 8, 6, 5, 7], [9, 9, 2, 2, 9, 9, 2, 2, 9, 9, 2, 2], [7, 2, 6, 6, 7, 2, 6, 6, 7, 2, 6, 6], [3, 9, 2, 7, 3, 9, 2, 7, 3, 9, 2, 7], [7, 6, 5, 8, 7, 6, 5, 8, 7, 6, 5, 8], [2, 9, 2, 9, 2, 9, 2, 9, 2, 9, 2, 9], [6, 2, 6, 7, 6, 2, 6, 7, 6, 2, 6, 7], [7, 9, 2, 3, 7, 9, 2, 3, 7, 9, 2, 3], [8, 6, 5, 7, 8, 6, 5, 7, 8, 6, 5, 7]]}], ""test"": [{""input"": [[9, 8, 6, 7], [6, 7, 9, 8], [8, 6, 8, 7], [3, 9, 2, 4]], ""output"": [[9, 8, 6, 7, 9, 8, 6, 7, 9, 8, 6, 7], [6, 7, 9, 8, 6, 7, 9, 8, 6, 7, 9, 8], [8, 6, 8, 7, 8, 6, 8, 7, 8, 6, 8, 7], [3, 9, 2, 4, 3, 9, 2, 4, 3, 9, 2, 4], [7, 8, 6, 9, 7, 8, 6, 9, 7, 8, 6, 9], [8, 7, 9, 6, 8, 7, 9, 6, 8, 7, 9, 6], [7, 6, 8, 8, 7, 6, 8, 8, 7, 6, 8, 8], [4, 9, 2, 3, 4, 9, 2, 3, 4, 9, 2, 3], [9, 8, 6, 7, 9, 8, 6, 7, 9, 8, 6, 7], [6, 7, 9, 8, 6, 7, 9, 8, 6, 7, 9, 8], [8, 6, 8, 7, 8, 6, 8, 7, 8, 6, 8, 7], [3, 9, 2, 4, 3, 9, 2, 4, 3, 9, 2, 4]]}]}"
DNnmJzWNHoCYupTrcTBKsi,2025-07-21T15:52:22.698879,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 5, 4, 5, 8, 2, 6], [9, 2, 3, 2, 6, 8, 9], [6, 7, 5, 9, 2, 3, 8], [4, 8, 7, 3, 8, 7, 6], [7, 4, 3, 9, 6, 5, 9], [4, 6, 9, 8, 2, 4, 8], [6, 7, 8, 4, 7, 9, 4]], ""output"": [[6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6], [9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9], [6, 7, 5, 9, 2, 3, 8, 6, 7, 5, 9, 2, 3, 8, 6, 7, 5, 9, 2, 3, 8], [4, 8, 7, 3, 8, 7, 6, 4, 8, 7, 3, 8, 7, 6, 4, 8, 7, 3, 8, 7, 6], [7, 4, 3, 9, 6, 5, 9, 7, 4, 3, 9, 6, 5, 9, 7, 4, 3, 9, 6, 5, 9], [4, 6, 9, 8, 2, 4, 8, 4, 6, 9, 8, 2, 4, 8, 4, 6, 9, 8, 2, 4, 8], [6, 7, 8, 4, 7, 9, 4, 6, 7, 8, 4, 7, 9, 4, 6, 7, 8, 4, 7, 9, 4], [6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6], [9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9], [8, 7, 5, 9, 2, 3, 6, 8, 7, 5, 9, 2, 3, 6, 8, 7, 5, 9, 2, 3, 6], [6, 8, 7, 3, 8, 7, 4, 6, 8, 7, 3, 8, 7, 4, 6, 8, 7, 3, 8, 7, 4], [9, 4, 3, 9, 6, 5, 7, 9, 4, 3, 9, 6, 5, 7, 9, 4, 3, 9, 6, 5, 7], [8, 6, 9, 8, 2, 4, 4, 8, 6, 9, 8, 2, 4, 4, 8, 6, 9, 8, 2, 4, 4], [4, 7, 8, 4, 7, 9, 6, 4, 7, 8, 4, 7, 9, 6, 4, 7, 8, 4, 7, 9, 6], [6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6, 6, 5, 4, 5, 8, 2, 6], [9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9, 9, 2, 3, 2, 6, 8, 9], [6, 7, 5, 9, 2, 3, 8, 6, 7, 5, 9, 2, 3, 8, 6, 7, 5, 9, 2, 3, 8], [4, 8, 7, 3, 8, 7, 6, 4, 8, 7, 3, 8, 7, 6, 4, 8, 7, 3, 8, 7, 6], [7, 4, 3, 9, 6, 5, 9, 7, 4, 3, 9, 6, 5, 9, 7, 4, 3, 9, 6, 5, 9], [4, 6, 9, 8, 2, 4, 8, 4, 6, 9, 8, 2, 4, 8, 4, 6, 9, 8, 2, 4, 8], [6, 7, 8, 4, 7, 9, 4, 6, 7, 8, 4, 7, 9, 4, 6, 7, 8, 4, 7, 9, 4]]}, {""input"": [[7, 9, 7, 8, 6, 3, 8], [5, 8, 9, 4, 8, 6, 9], [7, 3, 4, 3, 7, 8, 4], [5, 7, 3, 5, 3, 4, 8], [3, 9, 5, 9, 8, 7, 4], [4, 5, 4, 8, 7, 6, 9], [2, 8, 2, 3, 5, 7, 4]], ""output"": [[7, 9, 7, 8, 6, 3, 8, 7, 9, 7, 8, 6, 3, 8, 7, 9, 7, 8, 6, 3, 8], [5, 8, 9, 4, 8, 6, 9, 5, 8, 9, 4, 8, 6, 9, 5, 8, 9, 4, 8, 6, 9], [7, 3, 4, 3, 7, 8, 4, 7, 3, 4, 3, 7, 8, 4, 7, 3, 4, 3, 7, 8, 4], [5, 7, 3, 5, 3, 4, 8, 5, 7, 3, 5, 3, 4, 8, 5, 7, 3, 5, 3, 4, 8], [3, 9, 5, 9, 8, 7, 4, 3, 9, 5, 9, 8, 7, 4, 3, 9, 5, 9, 8, 7, 4], [4, 5, 4, 8, 7, 6, 9, 4, 5, 4, 8, 7, 6, 9, 4, 5, 4, 8, 7, 6, 9], [2, 8, 2, 3, 5, 7, 4, 2, 8, 2, 3, 5, 7, 4, 2, 8, 2, 3, 5, 7, 4], [8, 9, 7, 8, 6, 3, 7, 8, 9, 7, 8, 6, 3, 7, 8, 9, 7, 8, 6, 3, 7], [9, 8, 9, 4, 8, 6, 5, 9, 8, 9, 4, 8, 6, 5, 9, 8, 9, 4, 8, 6, 5], [4, 3, 4, 3, 7, 8, 7, 4, 3, 4, 3, 7, 8, 7, 4, 3, 4, 3, 7, 8, 7], [8, 7, 3, 5, 3, 4, 5, 8, 7, 3, 5, 3, 4, 5, 8, 7, 3, 5, 3, 4, 5], [4, 9, 5, 9, 8, 7, 3, 4, 9, 5, 9, 8, 7, 3, 4, 9, 5, 9, 8, 7, 3], [9, 5, 4, 8, 7, 6, 4, 9, 5, 4, 8, 7, 6, 4, 9, 5, 4, 8, 7, 6, 4], [4, 8, 2, 3, 5, 7, 2, 4, 8, 2, 3, 5, 7, 2, 4, 8, 2, 3, 5, 7, 2], [7, 9, 7, 8, 6, 3, 8, 7, 9, 7, 8, 6, 3, 8, 7, 9, 7, 8, 6, 3, 8], [5, 8, 9, 4, 8, 6, 9, 5, 8, 9, 4, 8, 6, 9, 5, 8, 9, 4, 8, 6, 9], [7, 3, 4, 3, 7, 8, 4, 7, 3, 4, 3, 7, 8, 4, 7, 3, 4, 3, 7, 8, 4], [5, 7, 3, 5, 3, 4, 8, 5, 7, 3, 5, 3, 4, 8, 5, 7, 3, 5, 3, 4, 8], [3, 9, 5, 9, 8, 7, 4, 3, 9, 5, 9, 8, 7, 4, 3, 9, 5, 9, 8, 7, 4], [4, 5, 4, 8, 7, 6, 9, 4, 5, 4, 8, 7, 6, 9, 4, 5, 4, 8, 7, 6, 9], [2, 8, 2, 3, 5, 7, 4, 2, 8, 2, 3, 5, 7, 4, 2, 8, 2, 3, 5, 7, 4]]}, {""input"": [[9, 3, 5, 2, 9, 5, 2], [5, 8, 6, 3, 2, 7, 4], [7, 9, 2, 5, 6, 9, 2], [6, 3, 6, 4, 9, 3, 6], [7, 8, 3, 9, 6, 7, 3], [4, 7, 2, 7, 3, 6, 5], [9, 4, 7, 9, 4, 2, 7]], ""output"": [[9, 3, 5, 2, 9, 5, 2, 9, 3, 5, 2, 9, 5, 2, 9, 3, 5, 2, 9, 5, 2], [5, 8, 6, 3, 2, 7, 4, 5, 8, 6, 3, 2, 7, 4, 5, 8, 6, 3, 2, 7, 4], [7, 9, 2, 5, 6, 9, 2, 7, 9, 2, 5, 6, 9, 2, 7, 9, 2, 5, 6, 9, 2], [6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6], [7, 8, 3, 9, 6, 7, 3, 7, 8, 3, 9, 6, 7, 3, 7, 8, 3, 9, 6, 7, 3], [4, 7, 2, 7, 3, 6, 5, 4, 7, 2, 7, 3, 6, 5, 4, 7, 2, 7, 3, 6, 5], [9, 4, 7, 9, 4, 2, 7, 9, 4, 7, 9, 4, 2, 7, 9, 4, 7, 9, 4, 2, 7], [2, 3, 5, 2, 9, 5, 9, 2, 3, 5, 2, 9, 5, 9, 2, 3, 5, 2, 9, 5, 9], [4, 8, 6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5], [2, 9, 2, 5, 6, 9, 7, 2, 9, 2, 5, 6, 9, 7, 2, 9, 2, 5, 6, 9, 7], [6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6], [3, 8, 3, 9, 6, 7, 7, 3, 8, 3, 9, 6, 7, 7, 3, 8, 3, 9, 6, 7, 7], [5, 7, 2, 7, 3, 6, 4, 5, 7, 2, 7, 3, 6, 4, 5, 7, 2, 7, 3, 6, 4], [7, 4, 7, 9, 4, 2, 9, 7, 4, 7, 9, 4, 2, 9, 7, 4, 7, 9, 4, 2, 9], [9, 3, 5, 2, 9, 5, 2, 9, 3, 5, 2, 9, 5, 2, 9, 3, 5, 2, 9, 5, 2], [5, 8, 6, 3, 2, 7, 4, 5, 8, 6, 3, 2, 7, 4, 5, 8, 6, 3, 2, 7, 4], [7, 9, 2, 5, 6, 9, 2, 7, 9, 2, 5, 6, 9, 2, 7, 9, 2, 5, 6, 9, 2], [6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6, 6, 3, 6, 4, 9, 3, 6], [7, 8, 3, 9, 6, 7, 3, 7, 8, 3, 9, 6, 7, 3, 7, 8, 3, 9, 6, 7, 3], [4, 7, 2, 7, 3, 6, 5, 4, 7, 2, 7, 3, 6, 5, 4, 7, 2, 7, 3, 6, 5], [9, 4, 7, 9, 4, 2, 7, 9, 4, 7, 9, 4, 2, 7, 9, 4, 7, 9, 4, 2, 7]]}], ""test"": [{""input"": [[2, 7, 9, 6, 4, 6, 3], [6, 4, 7, 3, 6, 7, 4], [2, 3, 4, 9, 7, 3, 9], [4, 8, 2, 4, 5, 8, 3], [5, 9, 7, 6, 7, 3, 5], [9, 5, 6, 3, 6, 4, 6], [5, 7, 9, 7, 8, 5, 4]], ""output"": [[2, 7, 9, 6, 4, 6, 3, 2, 7, 9, 6, 4, 6, 3, 2, 7, 9, 6, 4, 6, 3], [6, 4, 7, 3, 6, 7, 4, 6, 4, 7, 3, 6, 7, 4, 6, 4, 7, 3, 6, 7, 4], [2, 3, 4, 9, 7, 3, 9, 2, 3, 4, 9, 7, 3, 9, 2, 3, 4, 9, 7, 3, 9], [4, 8, 2, 4, 5, 8, 3, 4, 8, 2, 4, 5, 8, 3, 4, 8, 2, 4, 5, 8, 3], [5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5], [9, 5, 6, 3, 6, 4, 6, 9, 5, 6, 3, 6, 4, 6, 9, 5, 6, 3, 6, 4, 6], [5, 7, 9, 7, 8, 5, 4, 5, 7, 9, 7, 8, 5, 4, 5, 7, 9, 7, 8, 5, 4], [3, 7, 9, 6, 4, 6, 2, 3, 7, 9, 6, 4, 6, 2, 3, 7, 9, 6, 4, 6, 2], [4, 4, 7, 3, 6, 7, 6, 4, 4, 7, 3, 6, 7, 6, 4, 4, 7, 3, 6, 7, 6], [9, 3, 4, 9, 7, 3, 2, 9, 3, 4, 9, 7, 3, 2, 9, 3, 4, 9, 7, 3, 2], [3, 8, 2, 4, 5, 8, 4, 3, 8, 2, 4, 5, 8, 4, 3, 8, 2, 4, 5, 8, 4], [5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5], [6, 5, 6, 3, 6, 4, 9, 6, 5, 6, 3, 6, 4, 9, 6, 5, 6, 3, 6, 4, 9], [4, 7, 9, 7, 8, 5, 5, 4, 7, 9, 7, 8, 5, 5, 4, 7, 9, 7, 8, 5, 5], [2, 7, 9, 6, 4, 6, 3, 2, 7, 9, 6, 4, 6, 3, 2, 7, 9, 6, 4, 6, 3], [6, 4, 7, 3, 6, 7, 4, 6, 4, 7, 3, 6, 7, 4, 6, 4, 7, 3, 6, 7, 4], [2, 3, 4, 9, 7, 3, 9, 2, 3, 4, 9, 7, 3, 9, 2, 3, 4, 9, 7, 3, 9], [4, 8, 2, 4, 5, 8, 3, 4, 8, 2, 4, 5, 8, 3, 4, 8, 2, 4, 5, 8, 3], [5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5, 5, 9, 7, 6, 7, 3, 5], [9, 5, 6, 3, 6, 4, 6, 9, 5, 6, 3, 6, 4, 6, 9, 5, 6, 3, 6, 4, 6], [5, 7, 9, 7, 8, 5, 4, 5, 7, 9, 7, 8, 5, 4, 5, 7, 9, 7, 8, 5, 4]]}]}"
avsLQMV6BaaC5jfEYxnv6x,2025-07-21T15:52:22.701293,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 9, 8, 7], [5, 2, 5, 3], [6, 3, 7, 2], [2, 8, 4, 6]], ""output"": [[4, 9, 8, 7, 4, 9, 8, 7, 4, 9, 8, 7], [5, 2, 5, 3, 5, 2, 5, 3, 5, 2, 5, 3], [6, 3, 7, 2, 6, 3, 7, 2, 6, 3, 7, 2], [2, 8, 4, 6, 2, 8, 4, 6, 2, 8, 4, 6], [7, 9, 8, 4, 7, 9, 8, 4, 7, 9, 8, 4], [3, 2, 5, 5, 3, 2, 5, 5, 3, 2, 5, 5], [2, 3, 7, 6, 2, 3, 7, 6, 2, 3, 7, 6], [6, 8, 4, 2, 6, 8, 4, 2, 6, 8, 4, 2], [4, 9, 8, 7, 4, 9, 8, 7, 4, 9, 8, 7], [5, 2, 5, 3, 5, 2, 5, 3, 5, 2, 5, 3], [6, 3, 7, 2, 6, 3, 7, 2, 6, 3, 7, 2], [2, 8, 4, 6, 2, 8, 4, 6, 2, 8, 4, 6]]}, {""input"": [[4, 3, 7, 6], [2, 6, 4, 5], [4, 8, 9, 3], [5, 4, 3, 2]], ""output"": [[4, 3, 7, 6, 4, 3, 7, 6, 4, 3, 7, 6], [2, 6, 4, 5, 2, 6, 4, 5, 2, 6, 4, 5], [4, 8, 9, 3, 4, 8, 9, 3, 4, 8, 9, 3], [5, 4, 3, 2, 5, 4, 3, 2, 5, 4, 3, 2], [6, 3, 7, 4, 6, 3, 7, 4, 6, 3, 7, 4], [5, 6, 4, 2, 5, 6, 4, 2, 5, 6, 4, 2], [3, 8, 9, 4, 3, 8, 9, 4, 3, 8, 9, 4], [2, 4, 3, 5, 2, 4, 3, 5, 2, 4, 3, 5], [4, 3, 7, 6, 4, 3, 7, 6, 4, 3, 7, 6], [2, 6, 4, 5, 2, 6, 4, 5, 2, 6, 4, 5], [4, 8, 9, 3, 4, 8, 9, 3, 4, 8, 9, 3], [5, 4, 3, 2, 5, 4, 3, 2, 5, 4, 3, 2]]}, {""input"": [[7, 4, 3, 7], [4, 8, 6, 4], [5, 2, 5, 6], [8, 9, 6, 1]], ""output"": [[7, 4, 3, 7, 7, 4, 3, 7, 7, 4, 3, 7], [4, 8, 6, 4, 4, 8, 6, 4, 4, 8, 6, 4], [5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5, 6], [8, 9, 6, 1, 8, 9, 6, 1, 8, 9, 6, 1], [7, 4, 3, 7, 7, 4, 3, 7, 7, 4, 3, 7], [4, 8, 6, 4, 4, 8, 6, 4, 4, 8, 6, 4], [6, 2, 5, 5, 6, 2, 5, 5, 6, 2, 5, 5], [1, 9, 6, 8, 1, 9, 6, 8, 1, 9, 6, 8], [7, 4, 3, 7, 7, 4, 3, 7, 7, 4, 3, 7], [4, 8, 6, 4, 4, 8, 6, 4, 4, 8, 6, 4], [5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5, 6], [8, 9, 6, 1, 8, 9, 6, 1, 8, 9, 6, 1]]}], ""test"": [{""input"": [[5, 6, 8, 9], [4, 2, 9, 6], [2, 3, 2, 3], [4, 5, 4, 7]], ""output"": [[5, 6, 8, 9, 5, 6, 8, 9, 5, 6, 8, 9], [4, 2, 9, 6, 4, 2, 9, 6, 4, 2, 9, 6], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7], [9, 6, 8, 5, 9, 6, 8, 5, 9, 6, 8, 5], [6, 2, 9, 4, 6, 2, 9, 4, 6, 2, 9, 4], [3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2], [7, 5, 4, 4, 7, 5, 4, 4, 7, 5, 4, 4], [5, 6, 8, 9, 5, 6, 8, 9, 5, 6, 8, 9], [4, 2, 9, 6, 4, 2, 9, 6, 4, 2, 9, 6], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7]]}]}"
M94rC7aNbjYuaxm5m738th,2025-07-21T15:52:22.703737,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 8, 7, 8, 7, 9], [3, 6, 4, 6, 4, 5], [2, 4, 2, 4, 2, 3], [8, 5, 6, 3, 7, 5], [6, 3, 9, 4, 8, 2], [2, 4, 5, 8, 9, 7]], ""output"": [[6, 8, 7, 8, 7, 9, 6, 8, 7, 8, 7, 9, 6, 8, 7, 8, 7, 9], [3, 6, 4, 6, 4, 5, 3, 6, 4, 6, 4, 5, 3, 6, 4, 6, 4, 5], [2, 4, 2, 4, 2, 3, 2, 4, 2, 4, 2, 3, 2, 4, 2, 4, 2, 3], [8, 5, 6, 3, 7, 5, 8, 5, 6, 3, 7, 5, 8, 5, 6, 3, 7, 5], [6, 3, 9, 4, 8, 2, 6, 3, 9, 4, 8, 2, 6, 3, 9, 4, 8, 2], [2, 4, 5, 8, 9, 7, 2, 4, 5, 8, 9, 7, 2, 4, 5, 8, 9, 7], [9, 8, 7, 8, 7, 6, 9, 8, 7, 8, 7, 6, 9, 8, 7, 8, 7, 6], [5, 6, 4, 6, 4, 3, 5, 6, 4, 6, 4, 3, 5, 6, 4, 6, 4, 3], [3, 4, 2, 4, 2, 2, 3, 4, 2, 4, 2, 2, 3, 4, 2, 4, 2, 2], [5, 5, 6, 3, 7, 8, 5, 5, 6, 3, 7, 8, 5, 5, 6, 3, 7, 8], [2, 3, 9, 4, 8, 6, 2, 3, 9, 4, 8, 6, 2, 3, 9, 4, 8, 6], [7, 4, 5, 8, 9, 2, 7, 4, 5, 8, 9, 2, 7, 4, 5, 8, 9, 2], [6, 8, 7, 8, 7, 9, 6, 8, 7, 8, 7, 9, 6, 8, 7, 8, 7, 9], [3, 6, 4, 6, 4, 5, 3, 6, 4, 6, 4, 5, 3, 6, 4, 6, 4, 5], [2, 4, 2, 4, 2, 3, 2, 4, 2, 4, 2, 3, 2, 4, 2, 4, 2, 3], [8, 5, 6, 3, 7, 5, 8, 5, 6, 3, 7, 5, 8, 5, 6, 3, 7, 5], [6, 3, 9, 4, 8, 2, 6, 3, 9, 4, 8, 2, 6, 3, 9, 4, 8, 2], [2, 4, 5, 8, 9, 7, 2, 4, 5, 8, 9, 7, 2, 4, 5, 8, 9, 7]]}, {""input"": [[3, 9, 5, 7, 2, 9], [7, 4, 7, 2, 9, 4], [2, 6, 2, 6, 4, 2], [4, 7, 5, 7, 2, 4], [6, 4, 3, 2, 9, 6], [3, 2, 8, 6, 3, 2]], ""output"": [[3, 9, 5, 7, 2, 9, 3, 9, 5, 7, 2, 9, 3, 9, 5, 7, 2, 9], [7, 4, 7, 2, 9, 4, 7, 4, 7, 2, 9, 4, 7, 4, 7, 2, 9, 4], [2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2], [4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4], [6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6], [3, 2, 8, 6, 3, 2, 3, 2, 8, 6, 3, 2, 3, 2, 8, 6, 3, 2], [9, 9, 5, 7, 2, 3, 9, 9, 5, 7, 2, 3, 9, 9, 5, 7, 2, 3], [4, 4, 7, 2, 9, 7, 4, 4, 7, 2, 9, 7, 4, 4, 7, 2, 9, 7], [2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2], [4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4], [6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6], [2, 2, 8, 6, 3, 3, 2, 2, 8, 6, 3, 3, 2, 2, 8, 6, 3, 3], [3, 9, 5, 7, 2, 9, 3, 9, 5, 7, 2, 9, 3, 9, 5, 7, 2, 9], [7, 4, 7, 2, 9, 4, 7, 4, 7, 2, 9, 4, 7, 4, 7, 2, 9, 4], [2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2, 2, 6, 2, 6, 4, 2], [4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4, 4, 7, 5, 7, 2, 4], [6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6, 6, 4, 3, 2, 9, 6], [3, 2, 8, 6, 3, 2, 3, 2, 8, 6, 3, 2, 3, 2, 8, 6, 3, 2]]}, {""input"": [[7, 9, 6, 4, 9, 2], [5, 7, 2, 3, 7, 8], [2, 6, 7, 5, 9, 5], [4, 8, 2, 7, 8, 9], [3, 6, 4, 8, 2, 7], [7, 9, 8, 2, 4, 2]], ""output"": [[7, 9, 6, 4, 9, 2, 7, 9, 6, 4, 9, 2, 7, 9, 6, 4, 9, 2], [5, 7, 2, 3, 7, 8, 5, 7, 2, 3, 7, 8, 5, 7, 2, 3, 7, 8], [2, 6, 7, 5, 9, 5, 2, 6, 7, 5, 9, 5, 2, 6, 7, 5, 9, 5], [4, 8, 2, 7, 8, 9, 4, 8, 2, 7, 8, 9, 4, 8, 2, 7, 8, 9], [3, 6, 4, 8, 2, 7, 3, 6, 4, 8, 2, 7, 3, 6, 4, 8, 2, 7], [7, 9, 8, 2, 4, 2, 7, 9, 8, 2, 4, 2, 7, 9, 8, 2, 4, 2], [2, 9, 6, 4, 9, 7, 2, 9, 6, 4, 9, 7, 2, 9, 6, 4, 9, 7], [8, 7, 2, 3, 7, 5, 8, 7, 2, 3, 7, 5, 8, 7, 2, 3, 7, 5], [5, 6, 7, 5, 9, 2, 5, 6, 7, 5, 9, 2, 5, 6, 7, 5, 9, 2], [9, 8, 2, 7, 8, 4, 9, 8, 2, 7, 8, 4, 9, 8, 2, 7, 8, 4], [7, 6, 4, 8, 2, 3, 7, 6, 4, 8, 2, 3, 7, 6, 4, 8, 2, 3], [2, 9, 8, 2, 4, 7, 2, 9, 8, 2, 4, 7, 2, 9, 8, 2, 4, 7], [7, 9, 6, 4, 9, 2, 7, 9, 6, 4, 9, 2, 7, 9, 6, 4, 9, 2], [5, 7, 2, 3, 7, 8, 5, 7, 2, 3, 7, 8, 5, 7, 2, 3, 7, 8], [2, 6, 7, 5, 9, 5, 2, 6, 7, 5, 9, 5, 2, 6, 7, 5, 9, 5], [4, 8, 2, 7, 8, 9, 4, 8, 2, 7, 8, 9, 4, 8, 2, 7, 8, 9], [3, 6, 4, 8, 2, 7, 3, 6, 4, 8, 2, 7, 3, 6, 4, 8, 2, 7], [7, 9, 8, 2, 4, 2, 7, 9, 8, 2, 4, 2, 7, 9, 8, 2, 4, 2]]}], ""test"": [{""input"": [[5, 7, 6, 9, 3, 4], [6, 5, 2, 7, 5, 3], [5, 7, 6, 8, 7, 6], [7, 6, 3, 5, 8, 3], [6, 9, 7, 8, 2, 5], [9, 3, 9, 5, 6, 1]], ""output"": [[5, 7, 6, 9, 3, 4, 5, 7, 6, 9, 3, 4, 5, 7, 6, 9, 3, 4], [6, 5, 2, 7, 5, 3, 6, 5, 2, 7, 5, 3, 6, 5, 2, 7, 5, 3], [5, 7, 6, 8, 7, 6, 5, 7, 6, 8, 7, 6, 5, 7, 6, 8, 7, 6], [7, 6, 3, 5, 8, 3, 7, 6, 3, 5, 8, 3, 7, 6, 3, 5, 8, 3], [6, 9, 7, 8, 2, 5, 6, 9, 7, 8, 2, 5, 6, 9, 7, 8, 2, 5], [9, 3, 9, 5, 6, 1, 9, 3, 9, 5, 6, 1, 9, 3, 9, 5, 6, 1], [4, 7, 6, 9, 3, 5, 4, 7, 6, 9, 3, 5, 4, 7, 6, 9, 3, 5], [3, 5, 2, 7, 5, 6, 3, 5, 2, 7, 5, 6, 3, 5, 2, 7, 5, 6], [6, 7, 6, 8, 7, 5, 6, 7, 6, 8, 7, 5, 6, 7, 6, 8, 7, 5], [3, 6, 3, 5, 8, 7, 3, 6, 3, 5, 8, 7, 3, 6, 3, 5, 8, 7], [5, 9, 7, 8, 2, 6, 5, 9, 7, 8, 2, 6, 5, 9, 7, 8, 2, 6], [1, 3, 9, 5, 6, 9, 1, 3, 9, 5, 6, 9, 1, 3, 9, 5, 6, 9], [5, 7, 6, 9, 3, 4, 5, 7, 6, 9, 3, 4, 5, 7, 6, 9, 3, 4], [6, 5, 2, 7, 5, 3, 6, 5, 2, 7, 5, 3, 6, 5, 2, 7, 5, 3], [5, 7, 6, 8, 7, 6, 5, 7, 6, 8, 7, 6, 5, 7, 6, 8, 7, 6], [7, 6, 3, 5, 8, 3, 7, 6, 3, 5, 8, 3, 7, 6, 3, 5, 8, 3], [6, 9, 7, 8, 2, 5, 6, 9, 7, 8, 2, 5, 6, 9, 7, 8, 2, 5], [9, 3, 9, 5, 6, 1, 9, 3, 9, 5, 6, 1, 9, 3, 9, 5, 6, 1]]}]}"
UtxaaV7YKZkP72jP3XaeGK,2025-07-21T15:52:22.705852,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 2, 7], [4, 3, 4], [6, 9, 8]], ""output"": [[6, 2, 7, 6, 2, 7, 6, 2, 7], [4, 3, 4, 4, 3, 4, 4, 3, 4], [6, 9, 8, 6, 9, 8, 6, 9, 8], [7, 2, 6, 7, 2, 6, 7, 2, 6], [4, 3, 4, 4, 3, 4, 4, 3, 4], [8, 9, 6, 8, 9, 6, 8, 9, 6], [6, 2, 7, 6, 2, 7, 6, 2, 7], [4, 3, 4, 4, 3, 4, 4, 3, 4], [6, 9, 8, 6, 9, 8, 6, 9, 8]]}, {""input"": [[2, 6, 8], [8, 3, 4], [3, 5, 2]], ""output"": [[2, 6, 8, 2, 6, 8, 2, 6, 8], [8, 3, 4, 8, 3, 4, 8, 3, 4], [3, 5, 2, 3, 5, 2, 3, 5, 2], [8, 6, 2, 8, 6, 2, 8, 6, 2], [4, 3, 8, 4, 3, 8, 4, 3, 8], [2, 5, 3, 2, 5, 3, 2, 5, 3], [2, 6, 8, 2, 6, 8, 2, 6, 8], [8, 3, 4, 8, 3, 4, 8, 3, 4], [3, 5, 2, 3, 5, 2, 3, 5, 2]]}, {""input"": [[8, 7, 3], [5, 3, 4], [7, 9, 2]], ""output"": [[8, 7, 3, 8, 7, 3, 8, 7, 3], [5, 3, 4, 5, 3, 4, 5, 3, 4], [7, 9, 2, 7, 9, 2, 7, 9, 2], [3, 7, 8, 3, 7, 8, 3, 7, 8], [4, 3, 5, 4, 3, 5, 4, 3, 5], [2, 9, 7, 2, 9, 7, 2, 9, 7], [8, 7, 3, 8, 7, 3, 8, 7, 3], [5, 3, 4, 5, 3, 4, 5, 3, 4], [7, 9, 2, 7, 9, 2, 7, 9, 2]]}], ""test"": [{""input"": [[5, 7, 5], [4, 5, 9], [6, 7, 3]], ""output"": [[5, 7, 5, 5, 7, 5, 5, 7, 5], [4, 5, 9, 4, 5, 9, 4, 5, 9], [6, 7, 3, 6, 7, 3, 6, 7, 3], [5, 7, 5, 5, 7, 5, 5, 7, 5], [9, 5, 4, 9, 5, 4, 9, 5, 4], [3, 7, 6, 3, 7, 6, 3, 7, 6], [5, 7, 5, 5, 7, 5, 5, 7, 5], [4, 5, 9, 4, 5, 9, 4, 5, 9], [6, 7, 3, 6, 7, 3, 6, 7, 3]]}]}"
DLpio7PEUk7gfaF3MJqgHw,2025-07-21T15:52:22.708539,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 4, 5, 3, 6, 9, 8], [3, 2, 6, 9, 5, 4, 3], [4, 9, 8, 5, 7, 3, 4], [2, 6, 2, 7, 9, 5, 7], [9, 4, 7, 5, 7, 6, 5], [3, 2, 3, 9, 5, 3, 8], [4, 3, 8, 2, 6, 4, 3]], ""output"": [[7, 4, 5, 3, 6, 9, 8, 7, 4, 5, 3, 6, 9, 8, 7, 4, 5, 3, 6, 9, 8], [3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3], [4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4], [2, 6, 2, 7, 9, 5, 7, 2, 6, 2, 7, 9, 5, 7, 2, 6, 2, 7, 9, 5, 7], [9, 4, 7, 5, 7, 6, 5, 9, 4, 7, 5, 7, 6, 5, 9, 4, 7, 5, 7, 6, 5], [3, 2, 3, 9, 5, 3, 8, 3, 2, 3, 9, 5, 3, 8, 3, 2, 3, 9, 5, 3, 8], [4, 3, 8, 2, 6, 4, 3, 4, 3, 8, 2, 6, 4, 3, 4, 3, 8, 2, 6, 4, 3], [8, 4, 5, 3, 6, 9, 7, 8, 4, 5, 3, 6, 9, 7, 8, 4, 5, 3, 6, 9, 7], [3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3], [4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4], [7, 6, 2, 7, 9, 5, 2, 7, 6, 2, 7, 9, 5, 2, 7, 6, 2, 7, 9, 5, 2], [5, 4, 7, 5, 7, 6, 9, 5, 4, 7, 5, 7, 6, 9, 5, 4, 7, 5, 7, 6, 9], [8, 2, 3, 9, 5, 3, 3, 8, 2, 3, 9, 5, 3, 3, 8, 2, 3, 9, 5, 3, 3], [3, 3, 8, 2, 6, 4, 4, 3, 3, 8, 2, 6, 4, 4, 3, 3, 8, 2, 6, 4, 4], [7, 4, 5, 3, 6, 9, 8, 7, 4, 5, 3, 6, 9, 8, 7, 4, 5, 3, 6, 9, 8], [3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3, 3, 2, 6, 9, 5, 4, 3], [4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4, 4, 9, 8, 5, 7, 3, 4], [2, 6, 2, 7, 9, 5, 7, 2, 6, 2, 7, 9, 5, 7, 2, 6, 2, 7, 9, 5, 7], [9, 4, 7, 5, 7, 6, 5, 9, 4, 7, 5, 7, 6, 5, 9, 4, 7, 5, 7, 6, 5], [3, 2, 3, 9, 5, 3, 8, 3, 2, 3, 9, 5, 3, 8, 3, 2, 3, 9, 5, 3, 8], [4, 3, 8, 2, 6, 4, 3, 4, 3, 8, 2, 6, 4, 3, 4, 3, 8, 2, 6, 4, 3]]}, {""input"": [[7, 5, 9, 4, 3, 8, 5], [8, 6, 8, 9, 7, 3, 8], [6, 3, 2, 7, 5, 4, 3], [2, 6, 8, 9, 2, 7, 8], [5, 2, 5, 3, 8, 2, 5], [4, 3, 2, 6, 5, 4, 2], [6, 8, 6, 9, 2, 6, 1]], ""output"": [[7, 5, 9, 4, 3, 8, 5, 7, 5, 9, 4, 3, 8, 5, 7, 5, 9, 4, 3, 8, 5], [8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8], [6, 3, 2, 7, 5, 4, 3, 6, 3, 2, 7, 5, 4, 3, 6, 3, 2, 7, 5, 4, 3], [2, 6, 8, 9, 2, 7, 8, 2, 6, 8, 9, 2, 7, 8, 2, 6, 8, 9, 2, 7, 8], [5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5], [4, 3, 2, 6, 5, 4, 2, 4, 3, 2, 6, 5, 4, 2, 4, 3, 2, 6, 5, 4, 2], [6, 8, 6, 9, 2, 6, 1, 6, 8, 6, 9, 2, 6, 1, 6, 8, 6, 9, 2, 6, 1], [5, 5, 9, 4, 3, 8, 7, 5, 5, 9, 4, 3, 8, 7, 5, 5, 9, 4, 3, 8, 7], [8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8], [3, 3, 2, 7, 5, 4, 6, 3, 3, 2, 7, 5, 4, 6, 3, 3, 2, 7, 5, 4, 6], [8, 6, 8, 9, 2, 7, 2, 8, 6, 8, 9, 2, 7, 2, 8, 6, 8, 9, 2, 7, 2], [5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5], [2, 3, 2, 6, 5, 4, 4, 2, 3, 2, 6, 5, 4, 4, 2, 3, 2, 6, 5, 4, 4], [1, 8, 6, 9, 2, 6, 6, 1, 8, 6, 9, 2, 6, 6, 1, 8, 6, 9, 2, 6, 6], [7, 5, 9, 4, 3, 8, 5, 7, 5, 9, 4, 3, 8, 5, 7, 5, 9, 4, 3, 8, 5], [8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8, 8, 6, 8, 9, 7, 3, 8], [6, 3, 2, 7, 5, 4, 3, 6, 3, 2, 7, 5, 4, 3, 6, 3, 2, 7, 5, 4, 3], [2, 6, 8, 9, 2, 7, 8, 2, 6, 8, 9, 2, 7, 8, 2, 6, 8, 9, 2, 7, 8], [5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5, 5, 2, 5, 3, 8, 2, 5], [4, 3, 2, 6, 5, 4, 2, 4, 3, 2, 6, 5, 4, 2, 4, 3, 2, 6, 5, 4, 2], [6, 8, 6, 9, 2, 6, 1, 6, 8, 6, 9, 2, 6, 1, 6, 8, 6, 9, 2, 6, 1]]}, {""input"": [[4, 3, 6, 4, 9, 4, 6], [2, 5, 9, 3, 8, 2, 5], [7, 9, 6, 8, 7, 9, 6], [6, 3, 5, 2, 4, 7, 2], [9, 2, 6, 4, 9, 4, 7], [4, 9, 7, 8, 3, 2, 9], [2, 5, 3, 5, 7, 8, 7]], ""output"": [[4, 3, 6, 4, 9, 4, 6, 4, 3, 6, 4, 9, 4, 6, 4, 3, 6, 4, 9, 4, 6], [2, 5, 9, 3, 8, 2, 5, 2, 5, 9, 3, 8, 2, 5, 2, 5, 9, 3, 8, 2, 5], [7, 9, 6, 8, 7, 9, 6, 7, 9, 6, 8, 7, 9, 6, 7, 9, 6, 8, 7, 9, 6], [6, 3, 5, 2, 4, 7, 2, 6, 3, 5, 2, 4, 7, 2, 6, 3, 5, 2, 4, 7, 2], [9, 2, 6, 4, 9, 4, 7, 9, 2, 6, 4, 9, 4, 7, 9, 2, 6, 4, 9, 4, 7], [4, 9, 7, 8, 3, 2, 9, 4, 9, 7, 8, 3, 2, 9, 4, 9, 7, 8, 3, 2, 9], [2, 5, 3, 5, 7, 8, 7, 2, 5, 3, 5, 7, 8, 7, 2, 5, 3, 5, 7, 8, 7], [6, 3, 6, 4, 9, 4, 4, 6, 3, 6, 4, 9, 4, 4, 6, 3, 6, 4, 9, 4, 4], [5, 5, 9, 3, 8, 2, 2, 5, 5, 9, 3, 8, 2, 2, 5, 5, 9, 3, 8, 2, 2], [6, 9, 6, 8, 7, 9, 7, 6, 9, 6, 8, 7, 9, 7, 6, 9, 6, 8, 7, 9, 7], [2, 3, 5, 2, 4, 7, 6, 2, 3, 5, 2, 4, 7, 6, 2, 3, 5, 2, 4, 7, 6], [7, 2, 6, 4, 9, 4, 9, 7, 2, 6, 4, 9, 4, 9, 7, 2, 6, 4, 9, 4, 9], [9, 9, 7, 8, 3, 2, 4, 9, 9, 7, 8, 3, 2, 4, 9, 9, 7, 8, 3, 2, 4], [7, 5, 3, 5, 7, 8, 2, 7, 5, 3, 5, 7, 8, 2, 7, 5, 3, 5, 7, 8, 2], [4, 3, 6, 4, 9, 4, 6, 4, 3, 6, 4, 9, 4, 6, 4, 3, 6, 4, 9, 4, 6], [2, 5, 9, 3, 8, 2, 5, 2, 5, 9, 3, 8, 2, 5, 2, 5, 9, 3, 8, 2, 5], [7, 9, 6, 8, 7, 9, 6, 7, 9, 6, 8, 7, 9, 6, 7, 9, 6, 8, 7, 9, 6], [6, 3, 5, 2, 4, 7, 2, 6, 3, 5, 2, 4, 7, 2, 6, 3, 5, 2, 4, 7, 2], [9, 2, 6, 4, 9, 4, 7, 9, 2, 6, 4, 9, 4, 7, 9, 2, 6, 4, 9, 4, 7], [4, 9, 7, 8, 3, 2, 9, 4, 9, 7, 8, 3, 2, 9, 4, 9, 7, 8, 3, 2, 9], [2, 5, 3, 5, 7, 8, 7, 2, 5, 3, 5, 7, 8, 7, 2, 5, 3, 5, 7, 8, 7]]}], ""test"": [{""input"": [[6, 3, 2, 3, 2, 3, 4], [7, 2, 4, 8, 6, 4, 5], [4, 9, 5, 7, 2, 6, 2], [3, 5, 2, 9, 6, 3, 6], [5, 7, 8, 3, 5, 9, 2], [4, 8, 2, 5, 9, 6, 5], [3, 9, 4, 8, 6, 9, 1]], ""output"": [[6, 3, 2, 3, 2, 3, 4, 6, 3, 2, 3, 2, 3, 4, 6, 3, 2, 3, 2, 3, 4], [7, 2, 4, 8, 6, 4, 5, 7, 2, 4, 8, 6, 4, 5, 7, 2, 4, 8, 6, 4, 5], [4, 9, 5, 7, 2, 6, 2, 4, 9, 5, 7, 2, 6, 2, 4, 9, 5, 7, 2, 6, 2], [3, 5, 2, 9, 6, 3, 6, 3, 5, 2, 9, 6, 3, 6, 3, 5, 2, 9, 6, 3, 6], [5, 7, 8, 3, 5, 9, 2, 5, 7, 8, 3, 5, 9, 2, 5, 7, 8, 3, 5, 9, 2], [4, 8, 2, 5, 9, 6, 5, 4, 8, 2, 5, 9, 6, 5, 4, 8, 2, 5, 9, 6, 5], [3, 9, 4, 8, 6, 9, 1, 3, 9, 4, 8, 6, 9, 1, 3, 9, 4, 8, 6, 9, 1], [4, 3, 2, 3, 2, 3, 6, 4, 3, 2, 3, 2, 3, 6, 4, 3, 2, 3, 2, 3, 6], [5, 2, 4, 8, 6, 4, 7, 5, 2, 4, 8, 6, 4, 7, 5, 2, 4, 8, 6, 4, 7], [2, 9, 5, 7, 2, 6, 4, 2, 9, 5, 7, 2, 6, 4, 2, 9, 5, 7, 2, 6, 4], [6, 5, 2, 9, 6, 3, 3, 6, 5, 2, 9, 6, 3, 3, 6, 5, 2, 9, 6, 3, 3], [2, 7, 8, 3, 5, 9, 5, 2, 7, 8, 3, 5, 9, 5, 2, 7, 8, 3, 5, 9, 5], [5, 8, 2, 5, 9, 6, 4, 5, 8, 2, 5, 9, 6, 4, 5, 8, 2, 5, 9, 6, 4], [1, 9, 4, 8, 6, 9, 3, 1, 9, 4, 8, 6, 9, 3, 1, 9, 4, 8, 6, 9, 3], [6, 3, 2, 3, 2, 3, 4, 6, 3, 2, 3, 2, 3, 4, 6, 3, 2, 3, 2, 3, 4], [7, 2, 4, 8, 6, 4, 5, 7, 2, 4, 8, 6, 4, 5, 7, 2, 4, 8, 6, 4, 5], [4, 9, 5, 7, 2, 6, 2, 4, 9, 5, 7, 2, 6, 2, 4, 9, 5, 7, 2, 6, 2], [3, 5, 2, 9, 6, 3, 6, 3, 5, 2, 9, 6, 3, 6, 3, 5, 2, 9, 6, 3, 6], [5, 7, 8, 3, 5, 9, 2, 5, 7, 8, 3, 5, 9, 2, 5, 7, 8, 3, 5, 9, 2], [4, 8, 2, 5, 9, 6, 5, 4, 8, 2, 5, 9, 6, 5, 4, 8, 2, 5, 9, 6, 5], [3, 9, 4, 8, 6, 9, 1, 3, 9, 4, 8, 6, 9, 1, 3, 9, 4, 8, 6, 9, 1]]}]}"
fW8hmjRyLdwBFHR252FT2U,2025-07-21T15:52:22.711352,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 3, 6, 5, 3, 2], [5, 6, 8, 2, 8, 9], [4, 9, 2, 4, 5, 7], [8, 3, 9, 7, 2, 5], [9, 4, 6, 9, 4, 9], [5, 2, 7, 2, 6, 5]], ""output"": [[8, 3, 6, 5, 3, 2, 8, 3, 6, 5, 3, 2, 8, 3, 6, 5, 3, 2], [5, 6, 8, 2, 8, 9, 5, 6, 8, 2, 8, 9, 5, 6, 8, 2, 8, 9], [4, 9, 2, 4, 5, 7, 4, 9, 2, 4, 5, 7, 4, 9, 2, 4, 5, 7], [8, 3, 9, 7, 2, 5, 8, 3, 9, 7, 2, 5, 8, 3, 9, 7, 2, 5], [9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9], [5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5], [2, 3, 6, 5, 3, 8, 2, 3, 6, 5, 3, 8, 2, 3, 6, 5, 3, 8], [9, 6, 8, 2, 8, 5, 9, 6, 8, 2, 8, 5, 9, 6, 8, 2, 8, 5], [7, 9, 2, 4, 5, 4, 7, 9, 2, 4, 5, 4, 7, 9, 2, 4, 5, 4], [5, 3, 9, 7, 2, 8, 5, 3, 9, 7, 2, 8, 5, 3, 9, 7, 2, 8], [9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9], [5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5], [8, 3, 6, 5, 3, 2, 8, 3, 6, 5, 3, 2, 8, 3, 6, 5, 3, 2], [5, 6, 8, 2, 8, 9, 5, 6, 8, 2, 8, 9, 5, 6, 8, 2, 8, 9], [4, 9, 2, 4, 5, 7, 4, 9, 2, 4, 5, 7, 4, 9, 2, 4, 5, 7], [8, 3, 9, 7, 2, 5, 8, 3, 9, 7, 2, 5, 8, 3, 9, 7, 2, 5], [9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9, 9, 4, 6, 9, 4, 9], [5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5, 5, 2, 7, 2, 6, 5]]}, {""input"": [[9, 7, 6, 3, 5, 9], [3, 6, 8, 7, 2, 3], [9, 3, 5, 4, 3, 8], [6, 2, 8, 2, 5, 6], [7, 3, 7, 9, 7, 2], [6, 9, 5, 6, 9, 5]], ""output"": [[9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9], [3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3], [9, 3, 5, 4, 3, 8, 9, 3, 5, 4, 3, 8, 9, 3, 5, 4, 3, 8], [6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6], [7, 3, 7, 9, 7, 2, 7, 3, 7, 9, 7, 2, 7, 3, 7, 9, 7, 2], [6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5], [9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9], [3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3], [8, 3, 5, 4, 3, 9, 8, 3, 5, 4, 3, 9, 8, 3, 5, 4, 3, 9], [6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6], [2, 3, 7, 9, 7, 7, 2, 3, 7, 9, 7, 7, 2, 3, 7, 9, 7, 7], [5, 9, 5, 6, 9, 6, 5, 9, 5, 6, 9, 6, 5, 9, 5, 6, 9, 6], [9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9, 9, 7, 6, 3, 5, 9], [3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3, 3, 6, 8, 7, 2, 3], [9, 3, 5, 4, 3, 8, 9, 3, 5, 4, 3, 8, 9, 3, 5, 4, 3, 8], [6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6, 6, 2, 8, 2, 5, 6], [7, 3, 7, 9, 7, 2, 7, 3, 7, 9, 7, 2, 7, 3, 7, 9, 7, 2], [6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5, 6, 9, 5]]}, {""input"": [[3, 7, 5, 6, 2, 5], [8, 3, 2, 4, 8, 2], [3, 2, 8, 7, 2, 4], [6, 3, 9, 5, 9, 7], [4, 6, 3, 8, 4, 9], [3, 9, 8, 6, 7, 5]], ""output"": [[3, 7, 5, 6, 2, 5, 3, 7, 5, 6, 2, 5, 3, 7, 5, 6, 2, 5], [8, 3, 2, 4, 8, 2, 8, 3, 2, 4, 8, 2, 8, 3, 2, 4, 8, 2], [3, 2, 8, 7, 2, 4, 3, 2, 8, 7, 2, 4, 3, 2, 8, 7, 2, 4], [6, 3, 9, 5, 9, 7, 6, 3, 9, 5, 9, 7, 6, 3, 9, 5, 9, 7], [4, 6, 3, 8, 4, 9, 4, 6, 3, 8, 4, 9, 4, 6, 3, 8, 4, 9], [3, 9, 8, 6, 7, 5, 3, 9, 8, 6, 7, 5, 3, 9, 8, 6, 7, 5], [5, 7, 5, 6, 2, 3, 5, 7, 5, 6, 2, 3, 5, 7, 5, 6, 2, 3], [2, 3, 2, 4, 8, 8, 2, 3, 2, 4, 8, 8, 2, 3, 2, 4, 8, 8], [4, 2, 8, 7, 2, 3, 4, 2, 8, 7, 2, 3, 4, 2, 8, 7, 2, 3], [7, 3, 9, 5, 9, 6, 7, 3, 9, 5, 9, 6, 7, 3, 9, 5, 9, 6], [9, 6, 3, 8, 4, 4, 9, 6, 3, 8, 4, 4, 9, 6, 3, 8, 4, 4], [5, 9, 8, 6, 7, 3, 5, 9, 8, 6, 7, 3, 5, 9, 8, 6, 7, 3], [3, 7, 5, 6, 2, 5, 3, 7, 5, 6, 2, 5, 3, 7, 5, 6, 2, 5], [8, 3, 2, 4, 8, 2, 8, 3, 2, 4, 8, 2, 8, 3, 2, 4, 8, 2], [3, 2, 8, 7, 2, 4, 3, 2, 8, 7, 2, 4, 3, 2, 8, 7, 2, 4], [6, 3, 9, 5, 9, 7, 6, 3, 9, 5, 9, 7, 6, 3, 9, 5, 9, 7], [4, 6, 3, 8, 4, 9, 4, 6, 3, 8, 4, 9, 4, 6, 3, 8, 4, 9], [3, 9, 8, 6, 7, 5, 3, 9, 8, 6, 7, 5, 3, 9, 8, 6, 7, 5]]}], ""test"": [{""input"": [[3, 9, 2, 9, 3, 2], [8, 4, 6, 5, 2, 3], [2, 9, 2, 3, 9, 6], [3, 4, 8, 7, 8, 4], [2, 5, 2, 4, 7, 3], [8, 6, 3, 6, 3, 9]], ""output"": [[3, 9, 2, 9, 3, 2, 3, 9, 2, 9, 3, 2, 3, 9, 2, 9, 3, 2], [8, 4, 6, 5, 2, 3, 8, 4, 6, 5, 2, 3, 8, 4, 6, 5, 2, 3], [2, 9, 2, 3, 9, 6, 2, 9, 2, 3, 9, 6, 2, 9, 2, 3, 9, 6], [3, 4, 8, 7, 8, 4, 3, 4, 8, 7, 8, 4, 3, 4, 8, 7, 8, 4], [2, 5, 2, 4, 7, 3, 2, 5, 2, 4, 7, 3, 2, 5, 2, 4, 7, 3], [8, 6, 3, 6, 3, 9, 8, 6, 3, 6, 3, 9, 8, 6, 3, 6, 3, 9], [2, 9, 2, 9, 3, 3, 2, 9, 2, 9, 3, 3, 2, 9, 2, 9, 3, 3], [3, 4, 6, 5, 2, 8, 3, 4, 6, 5, 2, 8, 3, 4, 6, 5, 2, 8], [6, 9, 2, 3, 9, 2, 6, 9, 2, 3, 9, 2, 6, 9, 2, 3, 9, 2], [4, 4, 8, 7, 8, 3, 4, 4, 8, 7, 8, 3, 4, 4, 8, 7, 8, 3], [3, 5, 2, 4, 7, 2, 3, 5, 2, 4, 7, 2, 3, 5, 2, 4, 7, 2], [9, 6, 3, 6, 3, 8, 9, 6, 3, 6, 3, 8, 9, 6, 3, 6, 3, 8], [3, 9, 2, 9, 3, 2, 3, 9, 2, 9, 3, 2, 3, 9, 2, 9, 3, 2], [8, 4, 6, 5, 2, 3, 8, 4, 6, 5, 2, 3, 8, 4, 6, 5, 2, 3], [2, 9, 2, 3, 9, 6, 2, 9, 2, 3, 9, 6, 2, 9, 2, 3, 9, 6], [3, 4, 8, 7, 8, 4, 3, 4, 8, 7, 8, 4, 3, 4, 8, 7, 8, 4], [2, 5, 2, 4, 7, 3, 2, 5, 2, 4, 7, 3, 2, 5, 2, 4, 7, 3], [8, 6, 3, 6, 3, 9, 8, 6, 3, 6, 3, 9, 8, 6, 3, 6, 3, 9]]}]}"
FJPhJU5N3EtS6YP5iSFpLj,2025-07-21T15:52:22.713616,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 6, 5, 3], [9, 4, 3, 9], [8, 5, 6, 3], [3, 8, 2, 7]], ""output"": [[2, 6, 5, 3, 2, 6, 5, 3, 2, 6, 5, 3], [9, 4, 3, 9, 9, 4, 3, 9, 9, 4, 3, 9], [8, 5, 6, 3, 8, 5, 6, 3, 8, 5, 6, 3], [3, 8, 2, 7, 3, 8, 2, 7, 3, 8, 2, 7], [3, 6, 5, 2, 3, 6, 5, 2, 3, 6, 5, 2], [9, 4, 3, 9, 9, 4, 3, 9, 9, 4, 3, 9], [3, 5, 6, 8, 3, 5, 6, 8, 3, 5, 6, 8], [7, 8, 2, 3, 7, 8, 2, 3, 7, 8, 2, 3], [2, 6, 5, 3, 2, 6, 5, 3, 2, 6, 5, 3], [9, 4, 3, 9, 9, 4, 3, 9, 9, 4, 3, 9], [8, 5, 6, 3, 8, 5, 6, 3, 8, 5, 6, 3], [3, 8, 2, 7, 3, 8, 2, 7, 3, 8, 2, 7]]}, {""input"": [[2, 8, 4, 2], [7, 2, 3, 8], [2, 5, 9, 2], [9, 6, 4, 3]], ""output"": [[2, 8, 4, 2, 2, 8, 4, 2, 2, 8, 4, 2], [7, 2, 3, 8, 7, 2, 3, 8, 7, 2, 3, 8], [2, 5, 9, 2, 2, 5, 9, 2, 2, 5, 9, 2], [9, 6, 4, 3, 9, 6, 4, 3, 9, 6, 4, 3], [2, 8, 4, 2, 2, 8, 4, 2, 2, 8, 4, 2], [8, 2, 3, 7, 8, 2, 3, 7, 8, 2, 3, 7], [2, 5, 9, 2, 2, 5, 9, 2, 2, 5, 9, 2], [3, 6, 4, 9, 3, 6, 4, 9, 3, 6, 4, 9], [2, 8, 4, 2, 2, 8, 4, 2, 2, 8, 4, 2], [7, 2, 3, 8, 7, 2, 3, 8, 7, 2, 3, 8], [2, 5, 9, 2, 2, 5, 9, 2, 2, 5, 9, 2], [9, 6, 4, 3, 9, 6, 4, 3, 9, 6, 4, 3]]}, {""input"": [[4, 7, 3, 5], [8, 5, 2, 7], [3, 8, 5, 8], [5, 3, 4, 3]], ""output"": [[4, 7, 3, 5, 4, 7, 3, 5, 4, 7, 3, 5], [8, 5, 2, 7, 8, 5, 2, 7, 8, 5, 2, 7], [3, 8, 5, 8, 3, 8, 5, 8, 3, 8, 5, 8], [5, 3, 4, 3, 5, 3, 4, 3, 5, 3, 4, 3], [5, 7, 3, 4, 5, 7, 3, 4, 5, 7, 3, 4], [7, 5, 2, 8, 7, 5, 2, 8, 7, 5, 2, 8], [8, 8, 5, 3, 8, 8, 5, 3, 8, 8, 5, 3], [3, 3, 4, 5, 3, 3, 4, 5, 3, 3, 4, 5], [4, 7, 3, 5, 4, 7, 3, 5, 4, 7, 3, 5], [8, 5, 2, 7, 8, 5, 2, 7, 8, 5, 2, 7], [3, 8, 5, 8, 3, 8, 5, 8, 3, 8, 5, 8], [5, 3, 4, 3, 5, 3, 4, 3, 5, 3, 4, 3]]}], ""test"": [{""input"": [[9, 3, 2, 6], [8, 2, 8, 9], [9, 6, 7, 2], [3, 2, 5, 7]], ""output"": [[9, 3, 2, 6, 9, 3, 2, 6, 9, 3, 2, 6], [8, 2, 8, 9, 8, 2, 8, 9, 8, 2, 8, 9], [9, 6, 7, 2, 9, 6, 7, 2, 9, 6, 7, 2], [3, 2, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7], [6, 3, 2, 9, 6, 3, 2, 9, 6, 3, 2, 9], [9, 2, 8, 8, 9, 2, 8, 8, 9, 2, 8, 8], [2, 6, 7, 9, 2, 6, 7, 9, 2, 6, 7, 9], [7, 2, 5, 3, 7, 2, 5, 3, 7, 2, 5, 3], [9, 3, 2, 6, 9, 3, 2, 6, 9, 3, 2, 6], [8, 2, 8, 9, 8, 2, 8, 9, 8, 2, 8, 9], [9, 6, 7, 2, 9, 6, 7, 2, 9, 6, 7, 2], [3, 2, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7]]}]}"
C2UvKNGMiPS2DNxEAHxPFv,2025-07-21T15:52:22.716392,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 9, 6, 4, 2, 9, 3], [4, 2, 5, 7, 4, 5, 7], [8, 9, 8, 4, 8, 3, 5], [6, 3, 2, 7, 5, 4, 8], [3, 5, 6, 5, 6, 5, 6], [9, 8, 2, 8, 3, 7, 4], [3, 2, 7, 6, 4, 2, 7]], ""output"": [[8, 9, 6, 4, 2, 9, 3, 8, 9, 6, 4, 2, 9, 3, 8, 9, 6, 4, 2, 9, 3], [4, 2, 5, 7, 4, 5, 7, 4, 2, 5, 7, 4, 5, 7, 4, 2, 5, 7, 4, 5, 7], [8, 9, 8, 4, 8, 3, 5, 8, 9, 8, 4, 8, 3, 5, 8, 9, 8, 4, 8, 3, 5], [6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5, 4, 8], [3, 5, 6, 5, 6, 5, 6, 3, 5, 6, 5, 6, 5, 6, 3, 5, 6, 5, 6, 5, 6], [9, 8, 2, 8, 3, 7, 4, 9, 8, 2, 8, 3, 7, 4, 9, 8, 2, 8, 3, 7, 4], [3, 2, 7, 6, 4, 2, 7, 3, 2, 7, 6, 4, 2, 7, 3, 2, 7, 6, 4, 2, 7], [3, 9, 6, 4, 2, 9, 8, 3, 9, 6, 4, 2, 9, 8, 3, 9, 6, 4, 2, 9, 8], [7, 2, 5, 7, 4, 5, 4, 7, 2, 5, 7, 4, 5, 4, 7, 2, 5, 7, 4, 5, 4], [5, 9, 8, 4, 8, 3, 8, 5, 9, 8, 4, 8, 3, 8, 5, 9, 8, 4, 8, 3, 8], [8, 3, 2, 7, 5, 4, 6, 8, 3, 2, 7, 5, 4, 6, 8, 3, 2, 7, 5, 4, 6], [6, 5, 6, 5, 6, 5, 3, 6, 5, 6, 5, 6, 5, 3, 6, 5, 6, 5, 6, 5, 3], [4, 8, 2, 8, 3, 7, 9, 4, 8, 2, 8, 3, 7, 9, 4, 8, 2, 8, 3, 7, 9], [7, 2, 7, 6, 4, 2, 3, 7, 2, 7, 6, 4, 2, 3, 7, 2, 7, 6, 4, 2, 3], [8, 9, 6, 4, 2, 9, 3, 8, 9, 6, 4, 2, 9, 3, 8, 9, 6, 4, 2, 9, 3], [4, 2, 5, 7, 4, 5, 7, 4, 2, 5, 7, 4, 5, 7, 4, 2, 5, 7, 4, 5, 7], [8, 9, 8, 4, 8, 3, 5, 8, 9, 8, 4, 8, 3, 5, 8, 9, 8, 4, 8, 3, 5], [6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5, 4, 8, 6, 3, 2, 7, 5, 4, 8], [3, 5, 6, 5, 6, 5, 6, 3, 5, 6, 5, 6, 5, 6, 3, 5, 6, 5, 6, 5, 6], [9, 8, 2, 8, 3, 7, 4, 9, 8, 2, 8, 3, 7, 4, 9, 8, 2, 8, 3, 7, 4], [3, 2, 7, 6, 4, 2, 7, 3, 2, 7, 6, 4, 2, 7, 3, 2, 7, 6, 4, 2, 7]]}, {""input"": [[2, 6, 7, 3, 7, 3, 5], [4, 8, 6, 4, 9, 7, 8], [9, 4, 7, 5, 2, 8, 7], [5, 2, 9, 7, 3, 5, 6], [4, 5, 4, 2, 4, 6, 4], [7, 8, 6, 3, 8, 9, 5], [3, 9, 2, 9, 6, 7, 6]], ""output"": [[2, 6, 7, 3, 7, 3, 5, 2, 6, 7, 3, 7, 3, 5, 2, 6, 7, 3, 7, 3, 5], [4, 8, 6, 4, 9, 7, 8, 4, 8, 6, 4, 9, 7, 8, 4, 8, 6, 4, 9, 7, 8], [9, 4, 7, 5, 2, 8, 7, 9, 4, 7, 5, 2, 8, 7, 9, 4, 7, 5, 2, 8, 7], [5, 2, 9, 7, 3, 5, 6, 5, 2, 9, 7, 3, 5, 6, 5, 2, 9, 7, 3, 5, 6], [4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4], [7, 8, 6, 3, 8, 9, 5, 7, 8, 6, 3, 8, 9, 5, 7, 8, 6, 3, 8, 9, 5], [3, 9, 2, 9, 6, 7, 6, 3, 9, 2, 9, 6, 7, 6, 3, 9, 2, 9, 6, 7, 6], [5, 6, 7, 3, 7, 3, 2, 5, 6, 7, 3, 7, 3, 2, 5, 6, 7, 3, 7, 3, 2], [8, 8, 6, 4, 9, 7, 4, 8, 8, 6, 4, 9, 7, 4, 8, 8, 6, 4, 9, 7, 4], [7, 4, 7, 5, 2, 8, 9, 7, 4, 7, 5, 2, 8, 9, 7, 4, 7, 5, 2, 8, 9], [6, 2, 9, 7, 3, 5, 5, 6, 2, 9, 7, 3, 5, 5, 6, 2, 9, 7, 3, 5, 5], [4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4], [5, 8, 6, 3, 8, 9, 7, 5, 8, 6, 3, 8, 9, 7, 5, 8, 6, 3, 8, 9, 7], [6, 9, 2, 9, 6, 7, 3, 6, 9, 2, 9, 6, 7, 3, 6, 9, 2, 9, 6, 7, 3], [2, 6, 7, 3, 7, 3, 5, 2, 6, 7, 3, 7, 3, 5, 2, 6, 7, 3, 7, 3, 5], [4, 8, 6, 4, 9, 7, 8, 4, 8, 6, 4, 9, 7, 8, 4, 8, 6, 4, 9, 7, 8], [9, 4, 7, 5, 2, 8, 7, 9, 4, 7, 5, 2, 8, 7, 9, 4, 7, 5, 2, 8, 7], [5, 2, 9, 7, 3, 5, 6, 5, 2, 9, 7, 3, 5, 6, 5, 2, 9, 7, 3, 5, 6], [4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4, 4, 5, 4, 2, 4, 6, 4], [7, 8, 6, 3, 8, 9, 5, 7, 8, 6, 3, 8, 9, 5, 7, 8, 6, 3, 8, 9, 5], [3, 9, 2, 9, 6, 7, 6, 3, 9, 2, 9, 6, 7, 6, 3, 9, 2, 9, 6, 7, 6]]}, {""input"": [[9, 5, 3, 9, 6, 9, 4], [7, 6, 2, 3, 7, 2, 7], [4, 8, 5, 4, 8, 9, 5], [7, 3, 4, 6, 9, 7, 8], [8, 2, 8, 9, 6, 3, 7], [4, 3, 5, 4, 9, 4, 9], [8, 5, 2, 9, 8, 3, 2]], ""output"": [[9, 5, 3, 9, 6, 9, 4, 9, 5, 3, 9, 6, 9, 4, 9, 5, 3, 9, 6, 9, 4], [7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7], [4, 8, 5, 4, 8, 9, 5, 4, 8, 5, 4, 8, 9, 5, 4, 8, 5, 4, 8, 9, 5], [7, 3, 4, 6, 9, 7, 8, 7, 3, 4, 6, 9, 7, 8, 7, 3, 4, 6, 9, 7, 8], [8, 2, 8, 9, 6, 3, 7, 8, 2, 8, 9, 6, 3, 7, 8, 2, 8, 9, 6, 3, 7], [4, 3, 5, 4, 9, 4, 9, 4, 3, 5, 4, 9, 4, 9, 4, 3, 5, 4, 9, 4, 9], [8, 5, 2, 9, 8, 3, 2, 8, 5, 2, 9, 8, 3, 2, 8, 5, 2, 9, 8, 3, 2], [4, 5, 3, 9, 6, 9, 9, 4, 5, 3, 9, 6, 9, 9, 4, 5, 3, 9, 6, 9, 9], [7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7], [5, 8, 5, 4, 8, 9, 4, 5, 8, 5, 4, 8, 9, 4, 5, 8, 5, 4, 8, 9, 4], [8, 3, 4, 6, 9, 7, 7, 8, 3, 4, 6, 9, 7, 7, 8, 3, 4, 6, 9, 7, 7], [7, 2, 8, 9, 6, 3, 8, 7, 2, 8, 9, 6, 3, 8, 7, 2, 8, 9, 6, 3, 8], [9, 3, 5, 4, 9, 4, 4, 9, 3, 5, 4, 9, 4, 4, 9, 3, 5, 4, 9, 4, 4], [2, 5, 2, 9, 8, 3, 8, 2, 5, 2, 9, 8, 3, 8, 2, 5, 2, 9, 8, 3, 8], [9, 5, 3, 9, 6, 9, 4, 9, 5, 3, 9, 6, 9, 4, 9, 5, 3, 9, 6, 9, 4], [7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7, 7, 6, 2, 3, 7, 2, 7], [4, 8, 5, 4, 8, 9, 5, 4, 8, 5, 4, 8, 9, 5, 4, 8, 5, 4, 8, 9, 5], [7, 3, 4, 6, 9, 7, 8, 7, 3, 4, 6, 9, 7, 8, 7, 3, 4, 6, 9, 7, 8], [8, 2, 8, 9, 6, 3, 7, 8, 2, 8, 9, 6, 3, 7, 8, 2, 8, 9, 6, 3, 7], [4, 3, 5, 4, 9, 4, 9, 4, 3, 5, 4, 9, 4, 9, 4, 3, 5, 4, 9, 4, 9], [8, 5, 2, 9, 8, 3, 2, 8, 5, 2, 9, 8, 3, 2, 8, 5, 2, 9, 8, 3, 2]]}], ""test"": [{""input"": [[4, 6, 8, 6, 3, 6, 8], [7, 4, 2, 4, 2, 7, 3], [2, 5, 9, 3, 5, 3, 5], [6, 4, 2, 7, 3, 7, 6], [7, 9, 4, 2, 5, 9, 8], [8, 4, 9, 7, 8, 7, 2], [5, 8, 3, 9, 5, 2, 5]], ""output"": [[4, 6, 8, 6, 3, 6, 8, 4, 6, 8, 6, 3, 6, 8, 4, 6, 8, 6, 3, 6, 8], [7, 4, 2, 4, 2, 7, 3, 7, 4, 2, 4, 2, 7, 3, 7, 4, 2, 4, 2, 7, 3], [2, 5, 9, 3, 5, 3, 5, 2, 5, 9, 3, 5, 3, 5, 2, 5, 9, 3, 5, 3, 5], [6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6], [7, 9, 4, 2, 5, 9, 8, 7, 9, 4, 2, 5, 9, 8, 7, 9, 4, 2, 5, 9, 8], [8, 4, 9, 7, 8, 7, 2, 8, 4, 9, 7, 8, 7, 2, 8, 4, 9, 7, 8, 7, 2], [5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5], [8, 6, 8, 6, 3, 6, 4, 8, 6, 8, 6, 3, 6, 4, 8, 6, 8, 6, 3, 6, 4], [3, 4, 2, 4, 2, 7, 7, 3, 4, 2, 4, 2, 7, 7, 3, 4, 2, 4, 2, 7, 7], [5, 5, 9, 3, 5, 3, 2, 5, 5, 9, 3, 5, 3, 2, 5, 5, 9, 3, 5, 3, 2], [6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6], [8, 9, 4, 2, 5, 9, 7, 8, 9, 4, 2, 5, 9, 7, 8, 9, 4, 2, 5, 9, 7], [2, 4, 9, 7, 8, 7, 8, 2, 4, 9, 7, 8, 7, 8, 2, 4, 9, 7, 8, 7, 8], [5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5], [4, 6, 8, 6, 3, 6, 8, 4, 6, 8, 6, 3, 6, 8, 4, 6, 8, 6, 3, 6, 8], [7, 4, 2, 4, 2, 7, 3, 7, 4, 2, 4, 2, 7, 3, 7, 4, 2, 4, 2, 7, 3], [2, 5, 9, 3, 5, 3, 5, 2, 5, 9, 3, 5, 3, 5, 2, 5, 9, 3, 5, 3, 5], [6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6, 6, 4, 2, 7, 3, 7, 6], [7, 9, 4, 2, 5, 9, 8, 7, 9, 4, 2, 5, 9, 8, 7, 9, 4, 2, 5, 9, 8], [8, 4, 9, 7, 8, 7, 2, 8, 4, 9, 7, 8, 7, 2, 8, 4, 9, 7, 8, 7, 2], [5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5, 5, 8, 3, 9, 5, 2, 5]]}]}"
cRCEgrDEvVdrsDo55sUqFf,2025-07-21T15:52:22.718801,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 6, 8, 4], [6, 4, 9, 2], [4, 3, 4, 7], [3, 6, 9, 8]], ""output"": [[8, 6, 8, 4, 8, 6, 8, 4, 8, 6, 8, 4], [6, 4, 9, 2, 6, 4, 9, 2, 6, 4, 9, 2], [4, 3, 4, 7, 4, 3, 4, 7, 4, 3, 4, 7], [3, 6, 9, 8, 3, 6, 9, 8, 3, 6, 9, 8], [4, 6, 8, 8, 4, 6, 8, 8, 4, 6, 8, 8], [2, 4, 9, 6, 2, 4, 9, 6, 2, 4, 9, 6], [7, 3, 4, 4, 7, 3, 4, 4, 7, 3, 4, 4], [8, 6, 9, 3, 8, 6, 9, 3, 8, 6, 9, 3], [8, 6, 8, 4, 8, 6, 8, 4, 8, 6, 8, 4], [6, 4, 9, 2, 6, 4, 9, 2, 6, 4, 9, 2], [4, 3, 4, 7, 4, 3, 4, 7, 4, 3, 4, 7], [3, 6, 9, 8, 3, 6, 9, 8, 3, 6, 9, 8]]}, {""input"": [[7, 9, 3, 7], [5, 4, 6, 9], [9, 3, 9, 3], [4, 5, 6, 5]], ""output"": [[7, 9, 3, 7, 7, 9, 3, 7, 7, 9, 3, 7], [5, 4, 6, 9, 5, 4, 6, 9, 5, 4, 6, 9], [9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3], [4, 5, 6, 5, 4, 5, 6, 5, 4, 5, 6, 5], [7, 9, 3, 7, 7, 9, 3, 7, 7, 9, 3, 7], [9, 4, 6, 5, 9, 4, 6, 5, 9, 4, 6, 5], [3, 3, 9, 9, 3, 3, 9, 9, 3, 3, 9, 9], [5, 5, 6, 4, 5, 5, 6, 4, 5, 5, 6, 4], [7, 9, 3, 7, 7, 9, 3, 7, 7, 9, 3, 7], [5, 4, 6, 9, 5, 4, 6, 9, 5, 4, 6, 9], [9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3], [4, 5, 6, 5, 4, 5, 6, 5, 4, 5, 6, 5]]}, {""input"": [[4, 7, 6, 3], [6, 2, 9, 2], [8, 3, 7, 3], [7, 9, 6, 4]], ""output"": [[4, 7, 6, 3, 4, 7, 6, 3, 4, 7, 6, 3], [6, 2, 9, 2, 6, 2, 9, 2, 6, 2, 9, 2], [8, 3, 7, 3, 8, 3, 7, 3, 8, 3, 7, 3], [7, 9, 6, 4, 7, 9, 6, 4, 7, 9, 6, 4], [3, 7, 6, 4, 3, 7, 6, 4, 3, 7, 6, 4], [2, 2, 9, 6, 2, 2, 9, 6, 2, 2, 9, 6], [3, 3, 7, 8, 3, 3, 7, 8, 3, 3, 7, 8], [4, 9, 6, 7, 4, 9, 6, 7, 4, 9, 6, 7], [4, 7, 6, 3, 4, 7, 6, 3, 4, 7, 6, 3], [6, 2, 9, 2, 6, 2, 9, 2, 6, 2, 9, 2], [8, 3, 7, 3, 8, 3, 7, 3, 8, 3, 7, 3], [7, 9, 6, 4, 7, 9, 6, 4, 7, 9, 6, 4]]}], ""test"": [{""input"": [[5, 6, 2, 4], [3, 7, 5, 6], [6, 4, 8, 2], [5, 9, 5, 6]], ""output"": [[5, 6, 2, 4, 5, 6, 2, 4, 5, 6, 2, 4], [3, 7, 5, 6, 3, 7, 5, 6, 3, 7, 5, 6], [6, 4, 8, 2, 6, 4, 8, 2, 6, 4, 8, 2], [5, 9, 5, 6, 5, 9, 5, 6, 5, 9, 5, 6], [4, 6, 2, 5, 4, 6, 2, 5, 4, 6, 2, 5], [6, 7, 5, 3, 6, 7, 5, 3, 6, 7, 5, 3], [2, 4, 8, 6, 2, 4, 8, 6, 2, 4, 8, 6], [6, 9, 5, 5, 6, 9, 5, 5, 6, 9, 5, 5], [5, 6, 2, 4, 5, 6, 2, 4, 5, 6, 2, 4], [3, 7, 5, 6, 3, 7, 5, 6, 3, 7, 5, 6], [6, 4, 8, 2, 6, 4, 8, 2, 6, 4, 8, 2], [5, 9, 5, 6, 5, 9, 5, 6, 5, 9, 5, 6]]}]}"
dn3yHvqLiHenmBTmqTmoHj,2025-07-21T15:52:22.721330,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 8, 2, 5, 8, 2], [3, 6, 3, 2, 4, 7], [2, 9, 6, 3, 8, 3], [7, 4, 5, 6, 7, 5], [2, 5, 8, 5, 4, 2], [5, 2, 9, 2, 6, 1]], ""output"": [[4, 8, 2, 5, 8, 2, 4, 8, 2, 5, 8, 2, 4, 8, 2, 5, 8, 2], [3, 6, 3, 2, 4, 7, 3, 6, 3, 2, 4, 7, 3, 6, 3, 2, 4, 7], [2, 9, 6, 3, 8, 3, 2, 9, 6, 3, 8, 3, 2, 9, 6, 3, 8, 3], [7, 4, 5, 6, 7, 5, 7, 4, 5, 6, 7, 5, 7, 4, 5, 6, 7, 5], [2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2], [5, 2, 9, 2, 6, 1, 5, 2, 9, 2, 6, 1, 5, 2, 9, 2, 6, 1], [2, 8, 2, 5, 8, 4, 2, 8, 2, 5, 8, 4, 2, 8, 2, 5, 8, 4], [7, 6, 3, 2, 4, 3, 7, 6, 3, 2, 4, 3, 7, 6, 3, 2, 4, 3], [3, 9, 6, 3, 8, 2, 3, 9, 6, 3, 8, 2, 3, 9, 6, 3, 8, 2], [5, 4, 5, 6, 7, 7, 5, 4, 5, 6, 7, 7, 5, 4, 5, 6, 7, 7], [2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2], [1, 2, 9, 2, 6, 5, 1, 2, 9, 2, 6, 5, 1, 2, 9, 2, 6, 5], [4, 8, 2, 5, 8, 2, 4, 8, 2, 5, 8, 2, 4, 8, 2, 5, 8, 2], [3, 6, 3, 2, 4, 7, 3, 6, 3, 2, 4, 7, 3, 6, 3, 2, 4, 7], [2, 9, 6, 3, 8, 3, 2, 9, 6, 3, 8, 3, 2, 9, 6, 3, 8, 3], [7, 4, 5, 6, 7, 5, 7, 4, 5, 6, 7, 5, 7, 4, 5, 6, 7, 5], [2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2, 2, 5, 8, 5, 4, 2], [5, 2, 9, 2, 6, 1, 5, 2, 9, 2, 6, 1, 5, 2, 9, 2, 6, 1]]}, {""input"": [[4, 5, 9, 7, 2, 3], [8, 7, 8, 6, 8, 9], [9, 3, 2, 3, 7, 8], [6, 4, 3, 2, 4, 2], [2, 7, 8, 5, 9, 5], [7, 5, 3, 7, 6, 1]], ""output"": [[4, 5, 9, 7, 2, 3, 4, 5, 9, 7, 2, 3, 4, 5, 9, 7, 2, 3], [8, 7, 8, 6, 8, 9, 8, 7, 8, 6, 8, 9, 8, 7, 8, 6, 8, 9], [9, 3, 2, 3, 7, 8, 9, 3, 2, 3, 7, 8, 9, 3, 2, 3, 7, 8], [6, 4, 3, 2, 4, 2, 6, 4, 3, 2, 4, 2, 6, 4, 3, 2, 4, 2], [2, 7, 8, 5, 9, 5, 2, 7, 8, 5, 9, 5, 2, 7, 8, 5, 9, 5], [7, 5, 3, 7, 6, 1, 7, 5, 3, 7, 6, 1, 7, 5, 3, 7, 6, 1], [3, 5, 9, 7, 2, 4, 3, 5, 9, 7, 2, 4, 3, 5, 9, 7, 2, 4], [9, 7, 8, 6, 8, 8, 9, 7, 8, 6, 8, 8, 9, 7, 8, 6, 8, 8], [8, 3, 2, 3, 7, 9, 8, 3, 2, 3, 7, 9, 8, 3, 2, 3, 7, 9], [2, 4, 3, 2, 4, 6, 2, 4, 3, 2, 4, 6, 2, 4, 3, 2, 4, 6], [5, 7, 8, 5, 9, 2, 5, 7, 8, 5, 9, 2, 5, 7, 8, 5, 9, 2], [1, 5, 3, 7, 6, 7, 1, 5, 3, 7, 6, 7, 1, 5, 3, 7, 6, 7], [4, 5, 9, 7, 2, 3, 4, 5, 9, 7, 2, 3, 4, 5, 9, 7, 2, 3], [8, 7, 8, 6, 8, 9, 8, 7, 8, 6, 8, 9, 8, 7, 8, 6, 8, 9], [9, 3, 2, 3, 7, 8, 9, 3, 2, 3, 7, 8, 9, 3, 2, 3, 7, 8], [6, 4, 3, 2, 4, 2, 6, 4, 3, 2, 4, 2, 6, 4, 3, 2, 4, 2], [2, 7, 8, 5, 9, 5, 2, 7, 8, 5, 9, 5, 2, 7, 8, 5, 9, 5], [7, 5, 3, 7, 6, 1, 7, 5, 3, 7, 6, 1, 7, 5, 3, 7, 6, 1]]}, {""input"": [[3, 4, 5, 2, 5, 6], [4, 7, 6, 3, 2, 4], [8, 6, 8, 9, 5, 2], [6, 8, 2, 5, 3, 4], [8, 6, 9, 8, 4, 3], [6, 3, 6, 7, 2, 6]], ""output"": [[3, 4, 5, 2, 5, 6, 3, 4, 5, 2, 5, 6, 3, 4, 5, 2, 5, 6], [4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4], [8, 6, 8, 9, 5, 2, 8, 6, 8, 9, 5, 2, 8, 6, 8, 9, 5, 2], [6, 8, 2, 5, 3, 4, 6, 8, 2, 5, 3, 4, 6, 8, 2, 5, 3, 4], [8, 6, 9, 8, 4, 3, 8, 6, 9, 8, 4, 3, 8, 6, 9, 8, 4, 3], [6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6], [6, 4, 5, 2, 5, 3, 6, 4, 5, 2, 5, 3, 6, 4, 5, 2, 5, 3], [4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4], [2, 6, 8, 9, 5, 8, 2, 6, 8, 9, 5, 8, 2, 6, 8, 9, 5, 8], [4, 8, 2, 5, 3, 6, 4, 8, 2, 5, 3, 6, 4, 8, 2, 5, 3, 6], [3, 6, 9, 8, 4, 8, 3, 6, 9, 8, 4, 8, 3, 6, 9, 8, 4, 8], [6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6], [3, 4, 5, 2, 5, 6, 3, 4, 5, 2, 5, 6, 3, 4, 5, 2, 5, 6], [4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4, 4, 7, 6, 3, 2, 4], [8, 6, 8, 9, 5, 2, 8, 6, 8, 9, 5, 2, 8, 6, 8, 9, 5, 2], [6, 8, 2, 5, 3, 4, 6, 8, 2, 5, 3, 4, 6, 8, 2, 5, 3, 4], [8, 6, 9, 8, 4, 3, 8, 6, 9, 8, 4, 3, 8, 6, 9, 8, 4, 3], [6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6, 6, 3, 6, 7, 2, 6]]}], ""test"": [{""input"": [[7, 9, 8, 9, 5, 3], [3, 7, 6, 8, 6, 7], [4, 6, 4, 7, 5, 8], [9, 8, 3, 8, 3, 2], [3, 2, 9, 4, 5, 4], [4, 5, 4, 6, 3, 2]], ""output"": [[7, 9, 8, 9, 5, 3, 7, 9, 8, 9, 5, 3, 7, 9, 8, 9, 5, 3], [3, 7, 6, 8, 6, 7, 3, 7, 6, 8, 6, 7, 3, 7, 6, 8, 6, 7], [4, 6, 4, 7, 5, 8, 4, 6, 4, 7, 5, 8, 4, 6, 4, 7, 5, 8], [9, 8, 3, 8, 3, 2, 9, 8, 3, 8, 3, 2, 9, 8, 3, 8, 3, 2], [3, 2, 9, 4, 5, 4, 3, 2, 9, 4, 5, 4, 3, 2, 9, 4, 5, 4], [4, 5, 4, 6, 3, 2, 4, 5, 4, 6, 3, 2, 4, 5, 4, 6, 3, 2], [3, 9, 8, 9, 5, 7, 3, 9, 8, 9, 5, 7, 3, 9, 8, 9, 5, 7], [7, 7, 6, 8, 6, 3, 7, 7, 6, 8, 6, 3, 7, 7, 6, 8, 6, 3], [8, 6, 4, 7, 5, 4, 8, 6, 4, 7, 5, 4, 8, 6, 4, 7, 5, 4], [2, 8, 3, 8, 3, 9, 2, 8, 3, 8, 3, 9, 2, 8, 3, 8, 3, 9], [4, 2, 9, 4, 5, 3, 4, 2, 9, 4, 5, 3, 4, 2, 9, 4, 5, 3], [2, 5, 4, 6, 3, 4, 2, 5, 4, 6, 3, 4, 2, 5, 4, 6, 3, 4], [7, 9, 8, 9, 5, 3, 7, 9, 8, 9, 5, 3, 7, 9, 8, 9, 5, 3], [3, 7, 6, 8, 6, 7, 3, 7, 6, 8, 6, 7, 3, 7, 6, 8, 6, 7], [4, 6, 4, 7, 5, 8, 4, 6, 4, 7, 5, 8, 4, 6, 4, 7, 5, 8], [9, 8, 3, 8, 3, 2, 9, 8, 3, 8, 3, 2, 9, 8, 3, 8, 3, 2], [3, 2, 9, 4, 5, 4, 3, 2, 9, 4, 5, 4, 3, 2, 9, 4, 5, 4], [4, 5, 4, 6, 3, 2, 4, 5, 4, 6, 3, 2, 4, 5, 4, 6, 3, 2]]}]}"
Lc9PCKmCzTZSnZJcBEaGj4,2025-07-21T15:52:22.723361,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 5, 7], [2, 9, 5], [5, 7, 6]], ""output"": [[6, 5, 7, 6, 5, 7, 6, 5, 7], [2, 9, 5, 2, 9, 5, 2, 9, 5], [5, 7, 6, 5, 7, 6, 5, 7, 6], [7, 5, 6, 7, 5, 6, 7, 5, 6], [5, 9, 2, 5, 9, 2, 5, 9, 2], [6, 7, 5, 6, 7, 5, 6, 7, 5], [6, 5, 7, 6, 5, 7, 6, 5, 7], [2, 9, 5, 2, 9, 5, 2, 9, 5], [5, 7, 6, 5, 7, 6, 5, 7, 6]]}, {""input"": [[8, 2, 4], [5, 4, 9], [8, 5, 1]], ""output"": [[8, 2, 4, 8, 2, 4, 8, 2, 4], [5, 4, 9, 5, 4, 9, 5, 4, 9], [8, 5, 1, 8, 5, 1, 8, 5, 1], [4, 2, 8, 4, 2, 8, 4, 2, 8], [9, 4, 5, 9, 4, 5, 9, 4, 5], [1, 5, 8, 1, 5, 8, 1, 5, 8], [8, 2, 4, 8, 2, 4, 8, 2, 4], [5, 4, 9, 5, 4, 9, 5, 4, 9], [8, 5, 1, 8, 5, 1, 8, 5, 1]]}, {""input"": [[6, 2, 8], [5, 4, 6], [2, 6, 2]], ""output"": [[6, 2, 8, 6, 2, 8, 6, 2, 8], [5, 4, 6, 5, 4, 6, 5, 4, 6], [2, 6, 2, 2, 6, 2, 2, 6, 2], [8, 2, 6, 8, 2, 6, 8, 2, 6], [6, 4, 5, 6, 4, 5, 6, 4, 5], [2, 6, 2, 2, 6, 2, 2, 6, 2], [6, 2, 8, 6, 2, 8, 6, 2, 8], [5, 4, 6, 5, 4, 6, 5, 4, 6], [2, 6, 2, 2, 6, 2, 2, 6, 2]]}], ""test"": [{""input"": [[4, 7, 5], [9, 5, 9], [7, 6, 8]], ""output"": [[4, 7, 5, 4, 7, 5, 4, 7, 5], [9, 5, 9, 9, 5, 9, 9, 5, 9], [7, 6, 8, 7, 6, 8, 7, 6, 8], [5, 7, 4, 5, 7, 4, 5, 7, 4], [9, 5, 9, 9, 5, 9, 9, 5, 9], [8, 6, 7, 8, 6, 7, 8, 6, 7], [4, 7, 5, 4, 7, 5, 4, 7, 5], [9, 5, 9, 9, 5, 9, 9, 5, 9], [7, 6, 8, 7, 6, 8, 7, 6, 8]]}]}"
R8yK72u2unmX6pXafYJxDT,2025-07-21T15:52:22.725462,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 2, 3, 8, 4], [6, 4, 6, 3, 2], [8, 6, 8, 4, 6], [5, 4, 3, 2, 7], [6, 3, 6, 5, 2]], ""output"": [[9, 2, 3, 8, 4, 9, 2, 3, 8, 4, 9, 2, 3, 8, 4], [6, 4, 6, 3, 2, 6, 4, 6, 3, 2, 6, 4, 6, 3, 2], [8, 6, 8, 4, 6, 8, 6, 8, 4, 6, 8, 6, 8, 4, 6], [5, 4, 3, 2, 7, 5, 4, 3, 2, 7, 5, 4, 3, 2, 7], [6, 3, 6, 5, 2, 6, 3, 6, 5, 2, 6, 3, 6, 5, 2], [4, 2, 3, 8, 9, 4, 2, 3, 8, 9, 4, 2, 3, 8, 9], [2, 4, 6, 3, 6, 2, 4, 6, 3, 6, 2, 4, 6, 3, 6], [6, 6, 8, 4, 8, 6, 6, 8, 4, 8, 6, 6, 8, 4, 8], [7, 4, 3, 2, 5, 7, 4, 3, 2, 5, 7, 4, 3, 2, 5], [2, 3, 6, 5, 6, 2, 3, 6, 5, 6, 2, 3, 6, 5, 6], [9, 2, 3, 8, 4, 9, 2, 3, 8, 4, 9, 2, 3, 8, 4], [6, 4, 6, 3, 2, 6, 4, 6, 3, 2, 6, 4, 6, 3, 2], [8, 6, 8, 4, 6, 8, 6, 8, 4, 6, 8, 6, 8, 4, 6], [5, 4, 3, 2, 7, 5, 4, 3, 2, 7, 5, 4, 3, 2, 7], [6, 3, 6, 5, 2, 6, 3, 6, 5, 2, 6, 3, 6, 5, 2]]}, {""input"": [[6, 9, 3, 6, 4], [5, 8, 5, 8, 7], [8, 2, 8, 4, 6], [4, 3, 5, 2, 4], [6, 4, 8, 4, 2]], ""output"": [[6, 9, 3, 6, 4, 6, 9, 3, 6, 4, 6, 9, 3, 6, 4], [5, 8, 5, 8, 7, 5, 8, 5, 8, 7, 5, 8, 5, 8, 7], [8, 2, 8, 4, 6, 8, 2, 8, 4, 6, 8, 2, 8, 4, 6], [4, 3, 5, 2, 4, 4, 3, 5, 2, 4, 4, 3, 5, 2, 4], [6, 4, 8, 4, 2, 6, 4, 8, 4, 2, 6, 4, 8, 4, 2], [4, 9, 3, 6, 6, 4, 9, 3, 6, 6, 4, 9, 3, 6, 6], [7, 8, 5, 8, 5, 7, 8, 5, 8, 5, 7, 8, 5, 8, 5], [6, 2, 8, 4, 8, 6, 2, 8, 4, 8, 6, 2, 8, 4, 8], [4, 3, 5, 2, 4, 4, 3, 5, 2, 4, 4, 3, 5, 2, 4], [2, 4, 8, 4, 6, 2, 4, 8, 4, 6, 2, 4, 8, 4, 6], [6, 9, 3, 6, 4, 6, 9, 3, 6, 4, 6, 9, 3, 6, 4], [5, 8, 5, 8, 7, 5, 8, 5, 8, 7, 5, 8, 5, 8, 7], [8, 2, 8, 4, 6, 8, 2, 8, 4, 6, 8, 2, 8, 4, 6], [4, 3, 5, 2, 4, 4, 3, 5, 2, 4, 4, 3, 5, 2, 4], [6, 4, 8, 4, 2, 6, 4, 8, 4, 2, 6, 4, 8, 4, 2]]}, {""input"": [[4, 2, 5, 2, 4], [2, 3, 8, 4, 3], [8, 4, 5, 6, 9], [4, 8, 4, 3, 4], [5, 6, 8, 4, 8]], ""output"": [[4, 2, 5, 2, 4, 4, 2, 5, 2, 4, 4, 2, 5, 2, 4], [2, 3, 8, 4, 3, 2, 3, 8, 4, 3, 2, 3, 8, 4, 3], [8, 4, 5, 6, 9, 8, 4, 5, 6, 9, 8, 4, 5, 6, 9], [4, 8, 4, 3, 4, 4, 8, 4, 3, 4, 4, 8, 4, 3, 4], [5, 6, 8, 4, 8, 5, 6, 8, 4, 8, 5, 6, 8, 4, 8], [4, 2, 5, 2, 4, 4, 2, 5, 2, 4, 4, 2, 5, 2, 4], [3, 3, 8, 4, 2, 3, 3, 8, 4, 2, 3, 3, 8, 4, 2], [9, 4, 5, 6, 8, 9, 4, 5, 6, 8, 9, 4, 5, 6, 8], [4, 8, 4, 3, 4, 4, 8, 4, 3, 4, 4, 8, 4, 3, 4], [8, 6, 8, 4, 5, 8, 6, 8, 4, 5, 8, 6, 8, 4, 5], [4, 2, 5, 2, 4, 4, 2, 5, 2, 4, 4, 2, 5, 2, 4], [2, 3, 8, 4, 3, 2, 3, 8, 4, 3, 2, 3, 8, 4, 3], [8, 4, 5, 6, 9, 8, 4, 5, 6, 9, 8, 4, 5, 6, 9], [4, 8, 4, 3, 4, 4, 8, 4, 3, 4, 4, 8, 4, 3, 4], [5, 6, 8, 4, 8, 5, 6, 8, 4, 8, 5, 6, 8, 4, 8]]}], ""test"": [{""input"": [[4, 6, 8, 2, 8], [7, 3, 2, 8, 4], [5, 7, 9, 7, 9], [9, 6, 3, 9, 7], [5, 2, 9, 5, 6]], ""output"": [[4, 6, 8, 2, 8, 4, 6, 8, 2, 8, 4, 6, 8, 2, 8], [7, 3, 2, 8, 4, 7, 3, 2, 8, 4, 7, 3, 2, 8, 4], [5, 7, 9, 7, 9, 5, 7, 9, 7, 9, 5, 7, 9, 7, 9], [9, 6, 3, 9, 7, 9, 6, 3, 9, 7, 9, 6, 3, 9, 7], [5, 2, 9, 5, 6, 5, 2, 9, 5, 6, 5, 2, 9, 5, 6], [8, 6, 8, 2, 4, 8, 6, 8, 2, 4, 8, 6, 8, 2, 4], [4, 3, 2, 8, 7, 4, 3, 2, 8, 7, 4, 3, 2, 8, 7], [9, 7, 9, 7, 5, 9, 7, 9, 7, 5, 9, 7, 9, 7, 5], [7, 6, 3, 9, 9, 7, 6, 3, 9, 9, 7, 6, 3, 9, 9], [6, 2, 9, 5, 5, 6, 2, 9, 5, 5, 6, 2, 9, 5, 5], [4, 6, 8, 2, 8, 4, 6, 8, 2, 8, 4, 6, 8, 2, 8], [7, 3, 2, 8, 4, 7, 3, 2, 8, 4, 7, 3, 2, 8, 4], [5, 7, 9, 7, 9, 5, 7, 9, 7, 9, 5, 7, 9, 7, 9], [9, 6, 3, 9, 7, 9, 6, 3, 9, 7, 9, 6, 3, 9, 7], [5, 2, 9, 5, 6, 5, 2, 9, 5, 6, 5, 2, 9, 5, 6]]}]}"
WaSHi2m6DvTxGCH8ZjMwnr,2025-07-21T15:52:22.728000,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 8, 6, 4, 6, 9], [4, 5, 2, 5, 8, 6], [8, 3, 6, 8, 2, 8], [9, 7, 3, 9, 8, 9], [4, 3, 8, 7, 2, 4], [8, 5, 6, 3, 9, 1]], ""output"": [[9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9], [4, 5, 2, 5, 8, 6, 4, 5, 2, 5, 8, 6, 4, 5, 2, 5, 8, 6], [8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8], [9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9], [4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4], [8, 5, 6, 3, 9, 1, 8, 5, 6, 3, 9, 1, 8, 5, 6, 3, 9, 1], [9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9], [6, 5, 2, 5, 8, 4, 6, 5, 2, 5, 8, 4, 6, 5, 2, 5, 8, 4], [8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8], [9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9], [4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4], [1, 5, 6, 3, 9, 8, 1, 5, 6, 3, 9, 8, 1, 5, 6, 3, 9, 8], [9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9, 9, 8, 6, 4, 6, 9], [4, 5, 2, 5, 8, 6, 4, 5, 2, 5, 8, 6, 4, 5, 2, 5, 8, 6], [8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8, 8, 3, 6, 8, 2, 8], [9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9, 9, 7, 3, 9, 8, 9], [4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4, 4, 3, 8, 7, 2, 4], [8, 5, 6, 3, 9, 1, 8, 5, 6, 3, 9, 1, 8, 5, 6, 3, 9, 1]]}, {""input"": [[8, 3, 7, 5, 8, 6], [3, 9, 5, 7, 2, 3], [5, 4, 9, 3, 9, 5], [6, 5, 6, 2, 3, 6], [9, 8, 2, 9, 2, 7], [8, 4, 9, 3, 7, 2]], ""output"": [[8, 3, 7, 5, 8, 6, 8, 3, 7, 5, 8, 6, 8, 3, 7, 5, 8, 6], [3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3], [5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5], [6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6], [9, 8, 2, 9, 2, 7, 9, 8, 2, 9, 2, 7, 9, 8, 2, 9, 2, 7], [8, 4, 9, 3, 7, 2, 8, 4, 9, 3, 7, 2, 8, 4, 9, 3, 7, 2], [6, 3, 7, 5, 8, 8, 6, 3, 7, 5, 8, 8, 6, 3, 7, 5, 8, 8], [3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3], [5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5], [6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6], [7, 8, 2, 9, 2, 9, 7, 8, 2, 9, 2, 9, 7, 8, 2, 9, 2, 9], [2, 4, 9, 3, 7, 8, 2, 4, 9, 3, 7, 8, 2, 4, 9, 3, 7, 8], [8, 3, 7, 5, 8, 6, 8, 3, 7, 5, 8, 6, 8, 3, 7, 5, 8, 6], [3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3, 3, 9, 5, 7, 2, 3], [5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5, 5, 4, 9, 3, 9, 5], [6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6, 6, 5, 6, 2, 3, 6], [9, 8, 2, 9, 2, 7, 9, 8, 2, 9, 2, 7, 9, 8, 2, 9, 2, 7], [8, 4, 9, 3, 7, 2, 8, 4, 9, 3, 7, 2, 8, 4, 9, 3, 7, 2]]}, {""input"": [[8, 4, 2, 3, 5, 4], [9, 2, 6, 7, 6, 2], [8, 5, 3, 5, 7, 8], [4, 7, 2, 7, 4, 6], [9, 5, 7, 9, 7, 9], [6, 3, 8, 5, 8, 7]], ""output"": [[8, 4, 2, 3, 5, 4, 8, 4, 2, 3, 5, 4, 8, 4, 2, 3, 5, 4], [9, 2, 6, 7, 6, 2, 9, 2, 6, 7, 6, 2, 9, 2, 6, 7, 6, 2], [8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8], [4, 7, 2, 7, 4, 6, 4, 7, 2, 7, 4, 6, 4, 7, 2, 7, 4, 6], [9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9], [6, 3, 8, 5, 8, 7, 6, 3, 8, 5, 8, 7, 6, 3, 8, 5, 8, 7], [4, 4, 2, 3, 5, 8, 4, 4, 2, 3, 5, 8, 4, 4, 2, 3, 5, 8], [2, 2, 6, 7, 6, 9, 2, 2, 6, 7, 6, 9, 2, 2, 6, 7, 6, 9], [8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8], [6, 7, 2, 7, 4, 4, 6, 7, 2, 7, 4, 4, 6, 7, 2, 7, 4, 4], [9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9], [7, 3, 8, 5, 8, 6, 7, 3, 8, 5, 8, 6, 7, 3, 8, 5, 8, 6], [8, 4, 2, 3, 5, 4, 8, 4, 2, 3, 5, 4, 8, 4, 2, 3, 5, 4], [9, 2, 6, 7, 6, 2, 9, 2, 6, 7, 6, 2, 9, 2, 6, 7, 6, 2], [8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8, 8, 5, 3, 5, 7, 8], [4, 7, 2, 7, 4, 6, 4, 7, 2, 7, 4, 6, 4, 7, 2, 7, 4, 6], [9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9, 9, 5, 7, 9, 7, 9], [6, 3, 8, 5, 8, 7, 6, 3, 8, 5, 8, 7, 6, 3, 8, 5, 8, 7]]}], ""test"": [{""input"": [[9, 7, 8, 9, 6, 2], [2, 9, 3, 6, 4, 6], [7, 6, 2, 4, 5, 8], [9, 5, 3, 8, 9, 7], [6, 8, 6, 3, 8, 2], [4, 3, 2, 7, 6, 5]], ""output"": [[9, 7, 8, 9, 6, 2, 9, 7, 8, 9, 6, 2, 9, 7, 8, 9, 6, 2], [2, 9, 3, 6, 4, 6, 2, 9, 3, 6, 4, 6, 2, 9, 3, 6, 4, 6], [7, 6, 2, 4, 5, 8, 7, 6, 2, 4, 5, 8, 7, 6, 2, 4, 5, 8], [9, 5, 3, 8, 9, 7, 9, 5, 3, 8, 9, 7, 9, 5, 3, 8, 9, 7], [6, 8, 6, 3, 8, 2, 6, 8, 6, 3, 8, 2, 6, 8, 6, 3, 8, 2], [4, 3, 2, 7, 6, 5, 4, 3, 2, 7, 6, 5, 4, 3, 2, 7, 6, 5], [2, 7, 8, 9, 6, 9, 2, 7, 8, 9, 6, 9, 2, 7, 8, 9, 6, 9], [6, 9, 3, 6, 4, 2, 6, 9, 3, 6, 4, 2, 6, 9, 3, 6, 4, 2], [8, 6, 2, 4, 5, 7, 8, 6, 2, 4, 5, 7, 8, 6, 2, 4, 5, 7], [7, 5, 3, 8, 9, 9, 7, 5, 3, 8, 9, 9, 7, 5, 3, 8, 9, 9], [2, 8, 6, 3, 8, 6, 2, 8, 6, 3, 8, 6, 2, 8, 6, 3, 8, 6], [5, 3, 2, 7, 6, 4, 5, 3, 2, 7, 6, 4, 5, 3, 2, 7, 6, 4], [9, 7, 8, 9, 6, 2, 9, 7, 8, 9, 6, 2, 9, 7, 8, 9, 6, 2], [2, 9, 3, 6, 4, 6, 2, 9, 3, 6, 4, 6, 2, 9, 3, 6, 4, 6], [7, 6, 2, 4, 5, 8, 7, 6, 2, 4, 5, 8, 7, 6, 2, 4, 5, 8], [9, 5, 3, 8, 9, 7, 9, 5, 3, 8, 9, 7, 9, 5, 3, 8, 9, 7], [6, 8, 6, 3, 8, 2, 6, 8, 6, 3, 8, 2, 6, 8, 6, 3, 8, 2], [4, 3, 2, 7, 6, 5, 4, 3, 2, 7, 6, 5, 4, 3, 2, 7, 6, 5]]}]}"
eC7QS2r7vg88bUfjukVCCV,2025-07-21T15:52:22.730424,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 7, 6, 2, 4], [8, 2, 9, 4, 9], [4, 6, 2, 9, 4], [3, 4, 8, 7, 9], [5, 8, 9, 8, 1]], ""output"": [[9, 7, 6, 2, 4, 9, 7, 6, 2, 4, 9, 7, 6, 2, 4], [8, 2, 9, 4, 9, 8, 2, 9, 4, 9, 8, 2, 9, 4, 9], [4, 6, 2, 9, 4, 4, 6, 2, 9, 4, 4, 6, 2, 9, 4], [3, 4, 8, 7, 9, 3, 4, 8, 7, 9, 3, 4, 8, 7, 9], [5, 8, 9, 8, 1, 5, 8, 9, 8, 1, 5, 8, 9, 8, 1], [4, 7, 6, 2, 9, 4, 7, 6, 2, 9, 4, 7, 6, 2, 9], [9, 2, 9, 4, 8, 9, 2, 9, 4, 8, 9, 2, 9, 4, 8], [4, 6, 2, 9, 4, 4, 6, 2, 9, 4, 4, 6, 2, 9, 4], [9, 4, 8, 7, 3, 9, 4, 8, 7, 3, 9, 4, 8, 7, 3], [1, 8, 9, 8, 5, 1, 8, 9, 8, 5, 1, 8, 9, 8, 5], [9, 7, 6, 2, 4, 9, 7, 6, 2, 4, 9, 7, 6, 2, 4], [8, 2, 9, 4, 9, 8, 2, 9, 4, 9, 8, 2, 9, 4, 9], [4, 6, 2, 9, 4, 4, 6, 2, 9, 4, 4, 6, 2, 9, 4], [3, 4, 8, 7, 9, 3, 4, 8, 7, 9, 3, 4, 8, 7, 9], [5, 8, 9, 8, 1, 5, 8, 9, 8, 1, 5, 8, 9, 8, 1]]}, {""input"": [[2, 3, 5, 6, 5], [8, 7, 4, 2, 8], [5, 2, 7, 6, 9], [2, 3, 6, 3, 2], [3, 4, 3, 6, 1]], ""output"": [[2, 3, 5, 6, 5, 2, 3, 5, 6, 5, 2, 3, 5, 6, 5], [8, 7, 4, 2, 8, 8, 7, 4, 2, 8, 8, 7, 4, 2, 8], [5, 2, 7, 6, 9, 5, 2, 7, 6, 9, 5, 2, 7, 6, 9], [2, 3, 6, 3, 2, 2, 3, 6, 3, 2, 2, 3, 6, 3, 2], [3, 4, 3, 6, 1, 3, 4, 3, 6, 1, 3, 4, 3, 6, 1], [5, 3, 5, 6, 2, 5, 3, 5, 6, 2, 5, 3, 5, 6, 2], [8, 7, 4, 2, 8, 8, 7, 4, 2, 8, 8, 7, 4, 2, 8], [9, 2, 7, 6, 5, 9, 2, 7, 6, 5, 9, 2, 7, 6, 5], [2, 3, 6, 3, 2, 2, 3, 6, 3, 2, 2, 3, 6, 3, 2], [1, 4, 3, 6, 3, 1, 4, 3, 6, 3, 1, 4, 3, 6, 3], [2, 3, 5, 6, 5, 2, 3, 5, 6, 5, 2, 3, 5, 6, 5], [8, 7, 4, 2, 8, 8, 7, 4, 2, 8, 8, 7, 4, 2, 8], [5, 2, 7, 6, 9, 5, 2, 7, 6, 9, 5, 2, 7, 6, 9], [2, 3, 6, 3, 2, 2, 3, 6, 3, 2, 2, 3, 6, 3, 2], [3, 4, 3, 6, 1, 3, 4, 3, 6, 1, 3, 4, 3, 6, 1]]}, {""input"": [[2, 9, 6, 9, 5], [9, 8, 2, 4, 8], [4, 7, 8, 5, 4], [7, 2, 7, 2, 9], [4, 7, 5, 4, 5]], ""output"": [[2, 9, 6, 9, 5, 2, 9, 6, 9, 5, 2, 9, 6, 9, 5], [9, 8, 2, 4, 8, 9, 8, 2, 4, 8, 9, 8, 2, 4, 8], [4, 7, 8, 5, 4, 4, 7, 8, 5, 4, 4, 7, 8, 5, 4], [7, 2, 7, 2, 9, 7, 2, 7, 2, 9, 7, 2, 7, 2, 9], [4, 7, 5, 4, 5, 4, 7, 5, 4, 5, 4, 7, 5, 4, 5], [5, 9, 6, 9, 2, 5, 9, 6, 9, 2, 5, 9, 6, 9, 2], [8, 8, 2, 4, 9, 8, 8, 2, 4, 9, 8, 8, 2, 4, 9], [4, 7, 8, 5, 4, 4, 7, 8, 5, 4, 4, 7, 8, 5, 4], [9, 2, 7, 2, 7, 9, 2, 7, 2, 7, 9, 2, 7, 2, 7], [5, 7, 5, 4, 4, 5, 7, 5, 4, 4, 5, 7, 5, 4, 4], [2, 9, 6, 9, 5, 2, 9, 6, 9, 5, 2, 9, 6, 9, 5], [9, 8, 2, 4, 8, 9, 8, 2, 4, 8, 9, 8, 2, 4, 8], [4, 7, 8, 5, 4, 4, 7, 8, 5, 4, 4, 7, 8, 5, 4], [7, 2, 7, 2, 9, 7, 2, 7, 2, 9, 7, 2, 7, 2, 9], [4, 7, 5, 4, 5, 4, 7, 5, 4, 5, 4, 7, 5, 4, 5]]}], ""test"": [{""input"": [[5, 8, 7, 3, 6], [7, 5, 2, 7, 9], [4, 6, 8, 5, 2], [9, 3, 4, 9, 5], [7, 6, 8, 6, 7]], ""output"": [[5, 8, 7, 3, 6, 5, 8, 7, 3, 6, 5, 8, 7, 3, 6], [7, 5, 2, 7, 9, 7, 5, 2, 7, 9, 7, 5, 2, 7, 9], [4, 6, 8, 5, 2, 4, 6, 8, 5, 2, 4, 6, 8, 5, 2], [9, 3, 4, 9, 5, 9, 3, 4, 9, 5, 9, 3, 4, 9, 5], [7, 6, 8, 6, 7, 7, 6, 8, 6, 7, 7, 6, 8, 6, 7], [6, 8, 7, 3, 5, 6, 8, 7, 3, 5, 6, 8, 7, 3, 5], [9, 5, 2, 7, 7, 9, 5, 2, 7, 7, 9, 5, 2, 7, 7], [2, 6, 8, 5, 4, 2, 6, 8, 5, 4, 2, 6, 8, 5, 4], [5, 3, 4, 9, 9, 5, 3, 4, 9, 9, 5, 3, 4, 9, 9], [7, 6, 8, 6, 7, 7, 6, 8, 6, 7, 7, 6, 8, 6, 7], [5, 8, 7, 3, 6, 5, 8, 7, 3, 6, 5, 8, 7, 3, 6], [7, 5, 2, 7, 9, 7, 5, 2, 7, 9, 7, 5, 2, 7, 9], [4, 6, 8, 5, 2, 4, 6, 8, 5, 2, 4, 6, 8, 5, 2], [9, 3, 4, 9, 5, 9, 3, 4, 9, 5, 9, 3, 4, 9, 5], [7, 6, 8, 6, 7, 7, 6, 8, 6, 7, 7, 6, 8, 6, 7]]}]}"
F2MQTiHmMQLTb3tvdhSHXu,2025-07-21T15:52:22.733334,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 3, 8, 9, 4, 3, 9], [8, 4, 6, 2, 6, 7, 8], [4, 8, 2, 4, 9, 3, 9], [5, 3, 9, 2, 4, 6, 3], [3, 2, 4, 5, 9, 2, 9], [2, 4, 5, 9, 8, 6, 5], [9, 3, 2, 5, 9, 3, 1]], ""output"": [[4, 3, 8, 9, 4, 3, 9, 4, 3, 8, 9, 4, 3, 9, 4, 3, 8, 9, 4, 3, 9], [8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8], [4, 8, 2, 4, 9, 3, 9, 4, 8, 2, 4, 9, 3, 9, 4, 8, 2, 4, 9, 3, 9], [5, 3, 9, 2, 4, 6, 3, 5, 3, 9, 2, 4, 6, 3, 5, 3, 9, 2, 4, 6, 3], [3, 2, 4, 5, 9, 2, 9, 3, 2, 4, 5, 9, 2, 9, 3, 2, 4, 5, 9, 2, 9], [2, 4, 5, 9, 8, 6, 5, 2, 4, 5, 9, 8, 6, 5, 2, 4, 5, 9, 8, 6, 5], [9, 3, 2, 5, 9, 3, 1, 9, 3, 2, 5, 9, 3, 1, 9, 3, 2, 5, 9, 3, 1], [9, 3, 8, 9, 4, 3, 4, 9, 3, 8, 9, 4, 3, 4, 9, 3, 8, 9, 4, 3, 4], [8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8], [9, 8, 2, 4, 9, 3, 4, 9, 8, 2, 4, 9, 3, 4, 9, 8, 2, 4, 9, 3, 4], [3, 3, 9, 2, 4, 6, 5, 3, 3, 9, 2, 4, 6, 5, 3, 3, 9, 2, 4, 6, 5], [9, 2, 4, 5, 9, 2, 3, 9, 2, 4, 5, 9, 2, 3, 9, 2, 4, 5, 9, 2, 3], [5, 4, 5, 9, 8, 6, 2, 5, 4, 5, 9, 8, 6, 2, 5, 4, 5, 9, 8, 6, 2], [1, 3, 2, 5, 9, 3, 9, 1, 3, 2, 5, 9, 3, 9, 1, 3, 2, 5, 9, 3, 9], [4, 3, 8, 9, 4, 3, 9, 4, 3, 8, 9, 4, 3, 9, 4, 3, 8, 9, 4, 3, 9], [8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8, 8, 4, 6, 2, 6, 7, 8], [4, 8, 2, 4, 9, 3, 9, 4, 8, 2, 4, 9, 3, 9, 4, 8, 2, 4, 9, 3, 9], [5, 3, 9, 2, 4, 6, 3, 5, 3, 9, 2, 4, 6, 3, 5, 3, 9, 2, 4, 6, 3], [3, 2, 4, 5, 9, 2, 9, 3, 2, 4, 5, 9, 2, 9, 3, 2, 4, 5, 9, 2, 9], [2, 4, 5, 9, 8, 6, 5, 2, 4, 5, 9, 8, 6, 5, 2, 4, 5, 9, 8, 6, 5], [9, 3, 2, 5, 9, 3, 1, 9, 3, 2, 5, 9, 3, 1, 9, 3, 2, 5, 9, 3, 1]]}, {""input"": [[5, 6, 3, 7, 2, 3, 4], [4, 3, 4, 9, 5, 6, 9], [8, 4, 2, 6, 8, 5, 4], [6, 9, 6, 2, 6, 4, 9], [7, 5, 8, 4, 2, 6, 8], [9, 8, 5, 2, 6, 4, 3], [8, 5, 3, 5, 7, 5, 7]], ""output"": [[5, 6, 3, 7, 2, 3, 4, 5, 6, 3, 7, 2, 3, 4, 5, 6, 3, 7, 2, 3, 4], [4, 3, 4, 9, 5, 6, 9, 4, 3, 4, 9, 5, 6, 9, 4, 3, 4, 9, 5, 6, 9], [8, 4, 2, 6, 8, 5, 4, 8, 4, 2, 6, 8, 5, 4, 8, 4, 2, 6, 8, 5, 4], [6, 9, 6, 2, 6, 4, 9, 6, 9, 6, 2, 6, 4, 9, 6, 9, 6, 2, 6, 4, 9], [7, 5, 8, 4, 2, 6, 8, 7, 5, 8, 4, 2, 6, 8, 7, 5, 8, 4, 2, 6, 8], [9, 8, 5, 2, 6, 4, 3, 9, 8, 5, 2, 6, 4, 3, 9, 8, 5, 2, 6, 4, 3], [8, 5, 3, 5, 7, 5, 7, 8, 5, 3, 5, 7, 5, 7, 8, 5, 3, 5, 7, 5, 7], [4, 6, 3, 7, 2, 3, 5, 4, 6, 3, 7, 2, 3, 5, 4, 6, 3, 7, 2, 3, 5], [9, 3, 4, 9, 5, 6, 4, 9, 3, 4, 9, 5, 6, 4, 9, 3, 4, 9, 5, 6, 4], [4, 4, 2, 6, 8, 5, 8, 4, 4, 2, 6, 8, 5, 8, 4, 4, 2, 6, 8, 5, 8], [9, 9, 6, 2, 6, 4, 6, 9, 9, 6, 2, 6, 4, 6, 9, 9, 6, 2, 6, 4, 6], [8, 5, 8, 4, 2, 6, 7, 8, 5, 8, 4, 2, 6, 7, 8, 5, 8, 4, 2, 6, 7], [3, 8, 5, 2, 6, 4, 9, 3, 8, 5, 2, 6, 4, 9, 3, 8, 5, 2, 6, 4, 9], [7, 5, 3, 5, 7, 5, 8, 7, 5, 3, 5, 7, 5, 8, 7, 5, 3, 5, 7, 5, 8], [5, 6, 3, 7, 2, 3, 4, 5, 6, 3, 7, 2, 3, 4, 5, 6, 3, 7, 2, 3, 4], [4, 3, 4, 9, 5, 6, 9, 4, 3, 4, 9, 5, 6, 9, 4, 3, 4, 9, 5, 6, 9], [8, 4, 2, 6, 8, 5, 4, 8, 4, 2, 6, 8, 5, 4, 8, 4, 2, 6, 8, 5, 4], [6, 9, 6, 2, 6, 4, 9, 6, 9, 6, 2, 6, 4, 9, 6, 9, 6, 2, 6, 4, 9], [7, 5, 8, 4, 2, 6, 8, 7, 5, 8, 4, 2, 6, 8, 7, 5, 8, 4, 2, 6, 8], [9, 8, 5, 2, 6, 4, 3, 9, 8, 5, 2, 6, 4, 3, 9, 8, 5, 2, 6, 4, 3], [8, 5, 3, 5, 7, 5, 7, 8, 5, 3, 5, 7, 5, 7, 8, 5, 3, 5, 7, 5, 7]]}, {""input"": [[7, 8, 3, 2, 4, 9, 8], [6, 4, 9, 6, 7, 6, 2], [7, 5, 7, 9, 4, 5, 4], [8, 7, 3, 2, 6, 4, 6], [5, 3, 5, 7, 3, 5, 8], [2, 8, 9, 3, 6, 4, 9], [5, 2, 8, 7, 8, 9, 8]], ""output"": [[7, 8, 3, 2, 4, 9, 8, 7, 8, 3, 2, 4, 9, 8, 7, 8, 3, 2, 4, 9, 8], [6, 4, 9, 6, 7, 6, 2, 6, 4, 9, 6, 7, 6, 2, 6, 4, 9, 6, 7, 6, 2], [7, 5, 7, 9, 4, 5, 4, 7, 5, 7, 9, 4, 5, 4, 7, 5, 7, 9, 4, 5, 4], [8, 7, 3, 2, 6, 4, 6, 8, 7, 3, 2, 6, 4, 6, 8, 7, 3, 2, 6, 4, 6], [5, 3, 5, 7, 3, 5, 8, 5, 3, 5, 7, 3, 5, 8, 5, 3, 5, 7, 3, 5, 8], [2, 8, 9, 3, 6, 4, 9, 2, 8, 9, 3, 6, 4, 9, 2, 8, 9, 3, 6, 4, 9], [5, 2, 8, 7, 8, 9, 8, 5, 2, 8, 7, 8, 9, 8, 5, 2, 8, 7, 8, 9, 8], [8, 8, 3, 2, 4, 9, 7, 8, 8, 3, 2, 4, 9, 7, 8, 8, 3, 2, 4, 9, 7], [2, 4, 9, 6, 7, 6, 6, 2, 4, 9, 6, 7, 6, 6, 2, 4, 9, 6, 7, 6, 6], [4, 5, 7, 9, 4, 5, 7, 4, 5, 7, 9, 4, 5, 7, 4, 5, 7, 9, 4, 5, 7], [6, 7, 3, 2, 6, 4, 8, 6, 7, 3, 2, 6, 4, 8, 6, 7, 3, 2, 6, 4, 8], [8, 3, 5, 7, 3, 5, 5, 8, 3, 5, 7, 3, 5, 5, 8, 3, 5, 7, 3, 5, 5], [9, 8, 9, 3, 6, 4, 2, 9, 8, 9, 3, 6, 4, 2, 9, 8, 9, 3, 6, 4, 2], [8, 2, 8, 7, 8, 9, 5, 8, 2, 8, 7, 8, 9, 5, 8, 2, 8, 7, 8, 9, 5], [7, 8, 3, 2, 4, 9, 8, 7, 8, 3, 2, 4, 9, 8, 7, 8, 3, 2, 4, 9, 8], [6, 4, 9, 6, 7, 6, 2, 6, 4, 9, 6, 7, 6, 2, 6, 4, 9, 6, 7, 6, 2], [7, 5, 7, 9, 4, 5, 4, 7, 5, 7, 9, 4, 5, 4, 7, 5, 7, 9, 4, 5, 4], [8, 7, 3, 2, 6, 4, 6, 8, 7, 3, 2, 6, 4, 6, 8, 7, 3, 2, 6, 4, 6], [5, 3, 5, 7, 3, 5, 8, 5, 3, 5, 7, 3, 5, 8, 5, 3, 5, 7, 3, 5, 8], [2, 8, 9, 3, 6, 4, 9, 2, 8, 9, 3, 6, 4, 9, 2, 8, 9, 3, 6, 4, 9], [5, 2, 8, 7, 8, 9, 8, 5, 2, 8, 7, 8, 9, 8, 5, 2, 8, 7, 8, 9, 8]]}], ""test"": [{""input"": [[9, 3, 4, 7, 8, 6, 4], [8, 4, 6, 3, 6, 9, 8], [3, 8, 7, 9, 5, 2, 7], [6, 9, 8, 7, 8, 4, 3], [3, 5, 6, 9, 5, 8, 4], [4, 7, 4, 7, 3, 9, 3], [5, 2, 7, 2, 8, 5, 6]], ""output"": [[9, 3, 4, 7, 8, 6, 4, 9, 3, 4, 7, 8, 6, 4, 9, 3, 4, 7, 8, 6, 4], [8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8], [3, 8, 7, 9, 5, 2, 7, 3, 8, 7, 9, 5, 2, 7, 3, 8, 7, 9, 5, 2, 7], [6, 9, 8, 7, 8, 4, 3, 6, 9, 8, 7, 8, 4, 3, 6, 9, 8, 7, 8, 4, 3], [3, 5, 6, 9, 5, 8, 4, 3, 5, 6, 9, 5, 8, 4, 3, 5, 6, 9, 5, 8, 4], [4, 7, 4, 7, 3, 9, 3, 4, 7, 4, 7, 3, 9, 3, 4, 7, 4, 7, 3, 9, 3], [5, 2, 7, 2, 8, 5, 6, 5, 2, 7, 2, 8, 5, 6, 5, 2, 7, 2, 8, 5, 6], [4, 3, 4, 7, 8, 6, 9, 4, 3, 4, 7, 8, 6, 9, 4, 3, 4, 7, 8, 6, 9], [8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8], [7, 8, 7, 9, 5, 2, 3, 7, 8, 7, 9, 5, 2, 3, 7, 8, 7, 9, 5, 2, 3], [3, 9, 8, 7, 8, 4, 6, 3, 9, 8, 7, 8, 4, 6, 3, 9, 8, 7, 8, 4, 6], [4, 5, 6, 9, 5, 8, 3, 4, 5, 6, 9, 5, 8, 3, 4, 5, 6, 9, 5, 8, 3], [3, 7, 4, 7, 3, 9, 4, 3, 7, 4, 7, 3, 9, 4, 3, 7, 4, 7, 3, 9, 4], [6, 2, 7, 2, 8, 5, 5, 6, 2, 7, 2, 8, 5, 5, 6, 2, 7, 2, 8, 5, 5], [9, 3, 4, 7, 8, 6, 4, 9, 3, 4, 7, 8, 6, 4, 9, 3, 4, 7, 8, 6, 4], [8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8, 8, 4, 6, 3, 6, 9, 8], [3, 8, 7, 9, 5, 2, 7, 3, 8, 7, 9, 5, 2, 7, 3, 8, 7, 9, 5, 2, 7], [6, 9, 8, 7, 8, 4, 3, 6, 9, 8, 7, 8, 4, 3, 6, 9, 8, 7, 8, 4, 3], [3, 5, 6, 9, 5, 8, 4, 3, 5, 6, 9, 5, 8, 4, 3, 5, 6, 9, 5, 8, 4], [4, 7, 4, 7, 3, 9, 3, 4, 7, 4, 7, 3, 9, 3, 4, 7, 4, 7, 3, 9, 3], [5, 2, 7, 2, 8, 5, 6, 5, 2, 7, 2, 8, 5, 6, 5, 2, 7, 2, 8, 5, 6]]}]}"
C43DgD6UNZaSpcynuk2v5p,2025-07-21T15:52:22.735969,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 3, 6, 8, 3], [8, 7, 5, 4, 5], [7, 8, 2, 5, 3], [8, 9, 7, 3, 2], [5, 2, 9, 5, 3]], ""output"": [[9, 3, 6, 8, 3, 9, 3, 6, 8, 3, 9, 3, 6, 8, 3], [8, 7, 5, 4, 5, 8, 7, 5, 4, 5, 8, 7, 5, 4, 5], [7, 8, 2, 5, 3, 7, 8, 2, 5, 3, 7, 8, 2, 5, 3], [8, 9, 7, 3, 2, 8, 9, 7, 3, 2, 8, 9, 7, 3, 2], [5, 2, 9, 5, 3, 5, 2, 9, 5, 3, 5, 2, 9, 5, 3], [3, 3, 6, 8, 9, 3, 3, 6, 8, 9, 3, 3, 6, 8, 9], [5, 7, 5, 4, 8, 5, 7, 5, 4, 8, 5, 7, 5, 4, 8], [3, 8, 2, 5, 7, 3, 8, 2, 5, 7, 3, 8, 2, 5, 7], [2, 9, 7, 3, 8, 2, 9, 7, 3, 8, 2, 9, 7, 3, 8], [3, 2, 9, 5, 5, 3, 2, 9, 5, 5, 3, 2, 9, 5, 5], [9, 3, 6, 8, 3, 9, 3, 6, 8, 3, 9, 3, 6, 8, 3], [8, 7, 5, 4, 5, 8, 7, 5, 4, 5, 8, 7, 5, 4, 5], [7, 8, 2, 5, 3, 7, 8, 2, 5, 3, 7, 8, 2, 5, 3], [8, 9, 7, 3, 2, 8, 9, 7, 3, 2, 8, 9, 7, 3, 2], [5, 2, 9, 5, 3, 5, 2, 9, 5, 3, 5, 2, 9, 5, 3]]}, {""input"": [[8, 2, 5, 6, 7], [2, 4, 6, 3, 2], [7, 6, 4, 6, 3], [9, 7, 9, 5, 8], [8, 6, 2, 4, 7]], ""output"": [[8, 2, 5, 6, 7, 8, 2, 5, 6, 7, 8, 2, 5, 6, 7], [2, 4, 6, 3, 2, 2, 4, 6, 3, 2, 2, 4, 6, 3, 2], [7, 6, 4, 6, 3, 7, 6, 4, 6, 3, 7, 6, 4, 6, 3], [9, 7, 9, 5, 8, 9, 7, 9, 5, 8, 9, 7, 9, 5, 8], [8, 6, 2, 4, 7, 8, 6, 2, 4, 7, 8, 6, 2, 4, 7], [7, 2, 5, 6, 8, 7, 2, 5, 6, 8, 7, 2, 5, 6, 8], [2, 4, 6, 3, 2, 2, 4, 6, 3, 2, 2, 4, 6, 3, 2], [3, 6, 4, 6, 7, 3, 6, 4, 6, 7, 3, 6, 4, 6, 7], [8, 7, 9, 5, 9, 8, 7, 9, 5, 9, 8, 7, 9, 5, 9], [7, 6, 2, 4, 8, 7, 6, 2, 4, 8, 7, 6, 2, 4, 8], [8, 2, 5, 6, 7, 8, 2, 5, 6, 7, 8, 2, 5, 6, 7], [2, 4, 6, 3, 2, 2, 4, 6, 3, 2, 2, 4, 6, 3, 2], [7, 6, 4, 6, 3, 7, 6, 4, 6, 3, 7, 6, 4, 6, 3], [9, 7, 9, 5, 8, 9, 7, 9, 5, 8, 9, 7, 9, 5, 8], [8, 6, 2, 4, 7, 8, 6, 2, 4, 7, 8, 6, 2, 4, 7]]}, {""input"": [[3, 4, 2, 6, 7], [6, 5, 7, 5, 2], [8, 4, 5, 7, 8], [5, 2, 9, 4, 6], [8, 9, 7, 5, 7]], ""output"": [[3, 4, 2, 6, 7, 3, 4, 2, 6, 7, 3, 4, 2, 6, 7], [6, 5, 7, 5, 2, 6, 5, 7, 5, 2, 6, 5, 7, 5, 2], [8, 4, 5, 7, 8, 8, 4, 5, 7, 8, 8, 4, 5, 7, 8], [5, 2, 9, 4, 6, 5, 2, 9, 4, 6, 5, 2, 9, 4, 6], [8, 9, 7, 5, 7, 8, 9, 7, 5, 7, 8, 9, 7, 5, 7], [7, 4, 2, 6, 3, 7, 4, 2, 6, 3, 7, 4, 2, 6, 3], [2, 5, 7, 5, 6, 2, 5, 7, 5, 6, 2, 5, 7, 5, 6], [8, 4, 5, 7, 8, 8, 4, 5, 7, 8, 8, 4, 5, 7, 8], [6, 2, 9, 4, 5, 6, 2, 9, 4, 5, 6, 2, 9, 4, 5], [7, 9, 7, 5, 8, 7, 9, 7, 5, 8, 7, 9, 7, 5, 8], [3, 4, 2, 6, 7, 3, 4, 2, 6, 7, 3, 4, 2, 6, 7], [6, 5, 7, 5, 2, 6, 5, 7, 5, 2, 6, 5, 7, 5, 2], [8, 4, 5, 7, 8, 8, 4, 5, 7, 8, 8, 4, 5, 7, 8], [5, 2, 9, 4, 6, 5, 2, 9, 4, 6, 5, 2, 9, 4, 6], [8, 9, 7, 5, 7, 8, 9, 7, 5, 7, 8, 9, 7, 5, 7]]}], ""test"": [{""input"": [[3, 5, 9, 5, 8], [5, 3, 4, 7, 5], [4, 8, 3, 9, 7], [7, 9, 5, 2, 6], [9, 7, 9, 6, 2]], ""output"": [[3, 5, 9, 5, 8, 3, 5, 9, 5, 8, 3, 5, 9, 5, 8], [5, 3, 4, 7, 5, 5, 3, 4, 7, 5, 5, 3, 4, 7, 5], [4, 8, 3, 9, 7, 4, 8, 3, 9, 7, 4, 8, 3, 9, 7], [7, 9, 5, 2, 6, 7, 9, 5, 2, 6, 7, 9, 5, 2, 6], [9, 7, 9, 6, 2, 9, 7, 9, 6, 2, 9, 7, 9, 6, 2], [8, 5, 9, 5, 3, 8, 5, 9, 5, 3, 8, 5, 9, 5, 3], [5, 3, 4, 7, 5, 5, 3, 4, 7, 5, 5, 3, 4, 7, 5], [7, 8, 3, 9, 4, 7, 8, 3, 9, 4, 7, 8, 3, 9, 4], [6, 9, 5, 2, 7, 6, 9, 5, 2, 7, 6, 9, 5, 2, 7], [2, 7, 9, 6, 9, 2, 7, 9, 6, 9, 2, 7, 9, 6, 9], [3, 5, 9, 5, 8, 3, 5, 9, 5, 8, 3, 5, 9, 5, 8], [5, 3, 4, 7, 5, 5, 3, 4, 7, 5, 5, 3, 4, 7, 5], [4, 8, 3, 9, 7, 4, 8, 3, 9, 7, 4, 8, 3, 9, 7], [7, 9, 5, 2, 6, 7, 9, 5, 2, 6, 7, 9, 5, 2, 6], [9, 7, 9, 6, 2, 9, 7, 9, 6, 2, 9, 7, 9, 6, 2]]}]}"
9stVs3ycieSTZyDgg9K8yP,2025-07-21T15:52:22.739574,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 4, 3, 8, 3, 2], [7, 6, 5, 3, 8, 6], [5, 3, 6, 5, 3, 8], [3, 4, 9, 8, 5, 3], [2, 8, 4, 7, 4, 9], [3, 4, 9, 2, 6, 8]], ""output"": [[8, 4, 3, 8, 3, 2, 8, 4, 3, 8, 3, 2, 8, 4, 3, 8, 3, 2], [7, 6, 5, 3, 8, 6, 7, 6, 5, 3, 8, 6, 7, 6, 5, 3, 8, 6], [5, 3, 6, 5, 3, 8, 5, 3, 6, 5, 3, 8, 5, 3, 6, 5, 3, 8], [3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3], [2, 8, 4, 7, 4, 9, 2, 8, 4, 7, 4, 9, 2, 8, 4, 7, 4, 9], [3, 4, 9, 2, 6, 8, 3, 4, 9, 2, 6, 8, 3, 4, 9, 2, 6, 8], [2, 4, 3, 8, 3, 8, 2, 4, 3, 8, 3, 8, 2, 4, 3, 8, 3, 8], [6, 6, 5, 3, 8, 7, 6, 6, 5, 3, 8, 7, 6, 6, 5, 3, 8, 7], [8, 3, 6, 5, 3, 5, 8, 3, 6, 5, 3, 5, 8, 3, 6, 5, 3, 5], [3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3], [9, 8, 4, 7, 4, 2, 9, 8, 4, 7, 4, 2, 9, 8, 4, 7, 4, 2], [8, 4, 9, 2, 6, 3, 8, 4, 9, 2, 6, 3, 8, 4, 9, 2, 6, 3], [8, 4, 3, 8, 3, 2, 8, 4, 3, 8, 3, 2, 8, 4, 3, 8, 3, 2], [7, 6, 5, 3, 8, 6, 7, 6, 5, 3, 8, 6, 7, 6, 5, 3, 8, 6], [5, 3, 6, 5, 3, 8, 5, 3, 6, 5, 3, 8, 5, 3, 6, 5, 3, 8], [3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3, 3, 4, 9, 8, 5, 3], [2, 8, 4, 7, 4, 9, 2, 8, 4, 7, 4, 9, 2, 8, 4, 7, 4, 9], [3, 4, 9, 2, 6, 8, 3, 4, 9, 2, 6, 8, 3, 4, 9, 2, 6, 8]]}, {""input"": [[6, 5, 3, 7, 9, 3], [2, 8, 6, 2, 8, 6], [6, 5, 8, 9, 6, 7], [7, 8, 4, 8, 5, 6], [2, 6, 3, 5, 6, 3], [6, 8, 6, 8, 4, 9]], ""output"": [[6, 5, 3, 7, 9, 3, 6, 5, 3, 7, 9, 3, 6, 5, 3, 7, 9, 3], [2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6], [6, 5, 8, 9, 6, 7, 6, 5, 8, 9, 6, 7, 6, 5, 8, 9, 6, 7], [7, 8, 4, 8, 5, 6, 7, 8, 4, 8, 5, 6, 7, 8, 4, 8, 5, 6], [2, 6, 3, 5, 6, 3, 2, 6, 3, 5, 6, 3, 2, 6, 3, 5, 6, 3], [6, 8, 6, 8, 4, 9, 6, 8, 6, 8, 4, 9, 6, 8, 6, 8, 4, 9], [3, 5, 3, 7, 9, 6, 3, 5, 3, 7, 9, 6, 3, 5, 3, 7, 9, 6], [6, 8, 6, 2, 8, 2, 6, 8, 6, 2, 8, 2, 6, 8, 6, 2, 8, 2], [7, 5, 8, 9, 6, 6, 7, 5, 8, 9, 6, 6, 7, 5, 8, 9, 6, 6], [6, 8, 4, 8, 5, 7, 6, 8, 4, 8, 5, 7, 6, 8, 4, 8, 5, 7], [3, 6, 3, 5, 6, 2, 3, 6, 3, 5, 6, 2, 3, 6, 3, 5, 6, 2], [9, 8, 6, 8, 4, 6, 9, 8, 6, 8, 4, 6, 9, 8, 6, 8, 4, 6], [6, 5, 3, 7, 9, 3, 6, 5, 3, 7, 9, 3, 6, 5, 3, 7, 9, 3], [2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6, 2, 8, 6], [6, 5, 8, 9, 6, 7, 6, 5, 8, 9, 6, 7, 6, 5, 8, 9, 6, 7], [7, 8, 4, 8, 5, 6, 7, 8, 4, 8, 5, 6, 7, 8, 4, 8, 5, 6], [2, 6, 3, 5, 6, 3, 2, 6, 3, 5, 6, 3, 2, 6, 3, 5, 6, 3], [6, 8, 6, 8, 4, 9, 6, 8, 6, 8, 4, 9, 6, 8, 6, 8, 4, 9]]}, {""input"": [[2, 8, 9, 8, 9, 2], [7, 4, 2, 6, 2, 7], [4, 6, 3, 7, 9, 2], [9, 5, 6, 5, 8, 4], [8, 9, 7, 2, 6, 2], [9, 5, 3, 4, 9, 6]], ""output"": [[2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2], [7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7], [4, 6, 3, 7, 9, 2, 4, 6, 3, 7, 9, 2, 4, 6, 3, 7, 9, 2], [9, 5, 6, 5, 8, 4, 9, 5, 6, 5, 8, 4, 9, 5, 6, 5, 8, 4], [8, 9, 7, 2, 6, 2, 8, 9, 7, 2, 6, 2, 8, 9, 7, 2, 6, 2], [9, 5, 3, 4, 9, 6, 9, 5, 3, 4, 9, 6, 9, 5, 3, 4, 9, 6], [2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2], [7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7], [2, 6, 3, 7, 9, 4, 2, 6, 3, 7, 9, 4, 2, 6, 3, 7, 9, 4], [4, 5, 6, 5, 8, 9, 4, 5, 6, 5, 8, 9, 4, 5, 6, 5, 8, 9], [2, 9, 7, 2, 6, 8, 2, 9, 7, 2, 6, 8, 2, 9, 7, 2, 6, 8], [6, 5, 3, 4, 9, 9, 6, 5, 3, 4, 9, 9, 6, 5, 3, 4, 9, 9], [2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2, 2, 8, 9, 8, 9, 2], [7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7, 7, 4, 2, 6, 2, 7], [4, 6, 3, 7, 9, 2, 4, 6, 3, 7, 9, 2, 4, 6, 3, 7, 9, 2], [9, 5, 6, 5, 8, 4, 9, 5, 6, 5, 8, 4, 9, 5, 6, 5, 8, 4], [8, 9, 7, 2, 6, 2, 8, 9, 7, 2, 6, 2, 8, 9, 7, 2, 6, 2], [9, 5, 3, 4, 9, 6, 9, 5, 3, 4, 9, 6, 9, 5, 3, 4, 9, 6]]}], ""test"": [{""input"": [[3, 6, 4, 7, 4, 8], [5, 9, 6, 3, 7, 9], [3, 4, 9, 7, 8, 7], [2, 6, 4, 6, 4, 2], [7, 2, 7, 8, 7, 6], [9, 4, 5, 7, 3, 4]], ""output"": [[3, 6, 4, 7, 4, 8, 3, 6, 4, 7, 4, 8, 3, 6, 4, 7, 4, 8], [5, 9, 6, 3, 7, 9, 5, 9, 6, 3, 7, 9, 5, 9, 6, 3, 7, 9], [3, 4, 9, 7, 8, 7, 3, 4, 9, 7, 8, 7, 3, 4, 9, 7, 8, 7], [2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2], [7, 2, 7, 8, 7, 6, 7, 2, 7, 8, 7, 6, 7, 2, 7, 8, 7, 6], [9, 4, 5, 7, 3, 4, 9, 4, 5, 7, 3, 4, 9, 4, 5, 7, 3, 4], [8, 6, 4, 7, 4, 3, 8, 6, 4, 7, 4, 3, 8, 6, 4, 7, 4, 3], [9, 9, 6, 3, 7, 5, 9, 9, 6, 3, 7, 5, 9, 9, 6, 3, 7, 5], [7, 4, 9, 7, 8, 3, 7, 4, 9, 7, 8, 3, 7, 4, 9, 7, 8, 3], [2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2], [6, 2, 7, 8, 7, 7, 6, 2, 7, 8, 7, 7, 6, 2, 7, 8, 7, 7], [4, 4, 5, 7, 3, 9, 4, 4, 5, 7, 3, 9, 4, 4, 5, 7, 3, 9], [3, 6, 4, 7, 4, 8, 3, 6, 4, 7, 4, 8, 3, 6, 4, 7, 4, 8], [5, 9, 6, 3, 7, 9, 5, 9, 6, 3, 7, 9, 5, 9, 6, 3, 7, 9], [3, 4, 9, 7, 8, 7, 3, 4, 9, 7, 8, 7, 3, 4, 9, 7, 8, 7], [2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2, 2, 6, 4, 6, 4, 2], [7, 2, 7, 8, 7, 6, 7, 2, 7, 8, 7, 6, 7, 2, 7, 8, 7, 6], [9, 4, 5, 7, 3, 4, 9, 4, 5, 7, 3, 4, 9, 4, 5, 7, 3, 4]]}]}"
9zkH4k6bmhwiLkQZsnHWoS,2025-07-21T15:52:22.742585,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 5, 8, 4, 7, 3, 5], [7, 9, 3, 7, 2, 8, 9], [5, 7, 2, 8, 5, 4, 8], [7, 5, 9, 7, 9, 2, 6], [2, 4, 2, 5, 6, 8, 7], [9, 7, 8, 9, 8, 7, 4], [6, 9, 4, 8, 9, 6, 5]], ""output"": [[3, 5, 8, 4, 7, 3, 5, 3, 5, 8, 4, 7, 3, 5, 3, 5, 8, 4, 7, 3, 5], [7, 9, 3, 7, 2, 8, 9, 7, 9, 3, 7, 2, 8, 9, 7, 9, 3, 7, 2, 8, 9], [5, 7, 2, 8, 5, 4, 8, 5, 7, 2, 8, 5, 4, 8, 5, 7, 2, 8, 5, 4, 8], [7, 5, 9, 7, 9, 2, 6, 7, 5, 9, 7, 9, 2, 6, 7, 5, 9, 7, 9, 2, 6], [2, 4, 2, 5, 6, 8, 7, 2, 4, 2, 5, 6, 8, 7, 2, 4, 2, 5, 6, 8, 7], [9, 7, 8, 9, 8, 7, 4, 9, 7, 8, 9, 8, 7, 4, 9, 7, 8, 9, 8, 7, 4], [6, 9, 4, 8, 9, 6, 5, 6, 9, 4, 8, 9, 6, 5, 6, 9, 4, 8, 9, 6, 5], [5, 5, 8, 4, 7, 3, 3, 5, 5, 8, 4, 7, 3, 3, 5, 5, 8, 4, 7, 3, 3], [9, 9, 3, 7, 2, 8, 7, 9, 9, 3, 7, 2, 8, 7, 9, 9, 3, 7, 2, 8, 7], [8, 7, 2, 8, 5, 4, 5, 8, 7, 2, 8, 5, 4, 5, 8, 7, 2, 8, 5, 4, 5], [6, 5, 9, 7, 9, 2, 7, 6, 5, 9, 7, 9, 2, 7, 6, 5, 9, 7, 9, 2, 7], [7, 4, 2, 5, 6, 8, 2, 7, 4, 2, 5, 6, 8, 2, 7, 4, 2, 5, 6, 8, 2], [4, 7, 8, 9, 8, 7, 9, 4, 7, 8, 9, 8, 7, 9, 4, 7, 8, 9, 8, 7, 9], [5, 9, 4, 8, 9, 6, 6, 5, 9, 4, 8, 9, 6, 6, 5, 9, 4, 8, 9, 6, 6], [3, 5, 8, 4, 7, 3, 5, 3, 5, 8, 4, 7, 3, 5, 3, 5, 8, 4, 7, 3, 5], [7, 9, 3, 7, 2, 8, 9, 7, 9, 3, 7, 2, 8, 9, 7, 9, 3, 7, 2, 8, 9], [5, 7, 2, 8, 5, 4, 8, 5, 7, 2, 8, 5, 4, 8, 5, 7, 2, 8, 5, 4, 8], [7, 5, 9, 7, 9, 2, 6, 7, 5, 9, 7, 9, 2, 6, 7, 5, 9, 7, 9, 2, 6], [2, 4, 2, 5, 6, 8, 7, 2, 4, 2, 5, 6, 8, 7, 2, 4, 2, 5, 6, 8, 7], [9, 7, 8, 9, 8, 7, 4, 9, 7, 8, 9, 8, 7, 4, 9, 7, 8, 9, 8, 7, 4], [6, 9, 4, 8, 9, 6, 5, 6, 9, 4, 8, 9, 6, 5, 6, 9, 4, 8, 9, 6, 5]]}, {""input"": [[5, 4, 3, 7, 3, 7, 3], [7, 6, 9, 5, 9, 3, 4], [8, 9, 3, 2, 8, 4, 3], [4, 3, 4, 6, 7, 8, 2], [8, 9, 6, 4, 6, 5, 8], [4, 5, 4, 6, 7, 9, 3], [7, 9, 7, 3, 6, 5, 7]], ""output"": [[5, 4, 3, 7, 3, 7, 3, 5, 4, 3, 7, 3, 7, 3, 5, 4, 3, 7, 3, 7, 3], [7, 6, 9, 5, 9, 3, 4, 7, 6, 9, 5, 9, 3, 4, 7, 6, 9, 5, 9, 3, 4], [8, 9, 3, 2, 8, 4, 3, 8, 9, 3, 2, 8, 4, 3, 8, 9, 3, 2, 8, 4, 3], [4, 3, 4, 6, 7, 8, 2, 4, 3, 4, 6, 7, 8, 2, 4, 3, 4, 6, 7, 8, 2], [8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8], [4, 5, 4, 6, 7, 9, 3, 4, 5, 4, 6, 7, 9, 3, 4, 5, 4, 6, 7, 9, 3], [7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7], [3, 4, 3, 7, 3, 7, 5, 3, 4, 3, 7, 3, 7, 5, 3, 4, 3, 7, 3, 7, 5], [4, 6, 9, 5, 9, 3, 7, 4, 6, 9, 5, 9, 3, 7, 4, 6, 9, 5, 9, 3, 7], [3, 9, 3, 2, 8, 4, 8, 3, 9, 3, 2, 8, 4, 8, 3, 9, 3, 2, 8, 4, 8], [2, 3, 4, 6, 7, 8, 4, 2, 3, 4, 6, 7, 8, 4, 2, 3, 4, 6, 7, 8, 4], [8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8], [3, 5, 4, 6, 7, 9, 4, 3, 5, 4, 6, 7, 9, 4, 3, 5, 4, 6, 7, 9, 4], [7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7], [5, 4, 3, 7, 3, 7, 3, 5, 4, 3, 7, 3, 7, 3, 5, 4, 3, 7, 3, 7, 3], [7, 6, 9, 5, 9, 3, 4, 7, 6, 9, 5, 9, 3, 4, 7, 6, 9, 5, 9, 3, 4], [8, 9, 3, 2, 8, 4, 3, 8, 9, 3, 2, 8, 4, 3, 8, 9, 3, 2, 8, 4, 3], [4, 3, 4, 6, 7, 8, 2, 4, 3, 4, 6, 7, 8, 2, 4, 3, 4, 6, 7, 8, 2], [8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8, 8, 9, 6, 4, 6, 5, 8], [4, 5, 4, 6, 7, 9, 3, 4, 5, 4, 6, 7, 9, 3, 4, 5, 4, 6, 7, 9, 3], [7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7, 7, 9, 7, 3, 6, 5, 7]]}, {""input"": [[7, 5, 2, 6, 2, 9, 8], [4, 2, 4, 3, 8, 5, 3], [6, 4, 6, 7, 6, 8, 2], [5, 7, 2, 9, 7, 5, 9], [7, 6, 4, 3, 4, 3, 8], [6, 2, 8, 5, 7, 2, 6], [4, 5, 9, 4, 9, 7, 1]], ""output"": [[7, 5, 2, 6, 2, 9, 8, 7, 5, 2, 6, 2, 9, 8, 7, 5, 2, 6, 2, 9, 8], [4, 2, 4, 3, 8, 5, 3, 4, 2, 4, 3, 8, 5, 3, 4, 2, 4, 3, 8, 5, 3], [6, 4, 6, 7, 6, 8, 2, 6, 4, 6, 7, 6, 8, 2, 6, 4, 6, 7, 6, 8, 2], [5, 7, 2, 9, 7, 5, 9, 5, 7, 2, 9, 7, 5, 9, 5, 7, 2, 9, 7, 5, 9], [7, 6, 4, 3, 4, 3, 8, 7, 6, 4, 3, 4, 3, 8, 7, 6, 4, 3, 4, 3, 8], [6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6], [4, 5, 9, 4, 9, 7, 1, 4, 5, 9, 4, 9, 7, 1, 4, 5, 9, 4, 9, 7, 1], [8, 5, 2, 6, 2, 9, 7, 8, 5, 2, 6, 2, 9, 7, 8, 5, 2, 6, 2, 9, 7], [3, 2, 4, 3, 8, 5, 4, 3, 2, 4, 3, 8, 5, 4, 3, 2, 4, 3, 8, 5, 4], [2, 4, 6, 7, 6, 8, 6, 2, 4, 6, 7, 6, 8, 6, 2, 4, 6, 7, 6, 8, 6], [9, 7, 2, 9, 7, 5, 5, 9, 7, 2, 9, 7, 5, 5, 9, 7, 2, 9, 7, 5, 5], [8, 6, 4, 3, 4, 3, 7, 8, 6, 4, 3, 4, 3, 7, 8, 6, 4, 3, 4, 3, 7], [6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6], [1, 5, 9, 4, 9, 7, 4, 1, 5, 9, 4, 9, 7, 4, 1, 5, 9, 4, 9, 7, 4], [7, 5, 2, 6, 2, 9, 8, 7, 5, 2, 6, 2, 9, 8, 7, 5, 2, 6, 2, 9, 8], [4, 2, 4, 3, 8, 5, 3, 4, 2, 4, 3, 8, 5, 3, 4, 2, 4, 3, 8, 5, 3], [6, 4, 6, 7, 6, 8, 2, 6, 4, 6, 7, 6, 8, 2, 6, 4, 6, 7, 6, 8, 2], [5, 7, 2, 9, 7, 5, 9, 5, 7, 2, 9, 7, 5, 9, 5, 7, 2, 9, 7, 5, 9], [7, 6, 4, 3, 4, 3, 8, 7, 6, 4, 3, 4, 3, 8, 7, 6, 4, 3, 4, 3, 8], [6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6, 6, 2, 8, 5, 7, 2, 6], [4, 5, 9, 4, 9, 7, 1, 4, 5, 9, 4, 9, 7, 1, 4, 5, 9, 4, 9, 7, 1]]}], ""test"": [{""input"": [[4, 7, 8, 7, 3, 7, 5], [6, 3, 4, 8, 7, 6, 7], [3, 5, 2, 4, 3, 2, 4], [8, 7, 9, 5, 6, 4, 7], [3, 2, 5, 7, 3, 2, 4], [6, 7, 4, 6, 9, 4, 6], [9, 2, 6, 9, 4, 9, 2]], ""output"": [[4, 7, 8, 7, 3, 7, 5, 4, 7, 8, 7, 3, 7, 5, 4, 7, 8, 7, 3, 7, 5], [6, 3, 4, 8, 7, 6, 7, 6, 3, 4, 8, 7, 6, 7, 6, 3, 4, 8, 7, 6, 7], [3, 5, 2, 4, 3, 2, 4, 3, 5, 2, 4, 3, 2, 4, 3, 5, 2, 4, 3, 2, 4], [8, 7, 9, 5, 6, 4, 7, 8, 7, 9, 5, 6, 4, 7, 8, 7, 9, 5, 6, 4, 7], [3, 2, 5, 7, 3, 2, 4, 3, 2, 5, 7, 3, 2, 4, 3, 2, 5, 7, 3, 2, 4], [6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6], [9, 2, 6, 9, 4, 9, 2, 9, 2, 6, 9, 4, 9, 2, 9, 2, 6, 9, 4, 9, 2], [5, 7, 8, 7, 3, 7, 4, 5, 7, 8, 7, 3, 7, 4, 5, 7, 8, 7, 3, 7, 4], [7, 3, 4, 8, 7, 6, 6, 7, 3, 4, 8, 7, 6, 6, 7, 3, 4, 8, 7, 6, 6], [4, 5, 2, 4, 3, 2, 3, 4, 5, 2, 4, 3, 2, 3, 4, 5, 2, 4, 3, 2, 3], [7, 7, 9, 5, 6, 4, 8, 7, 7, 9, 5, 6, 4, 8, 7, 7, 9, 5, 6, 4, 8], [4, 2, 5, 7, 3, 2, 3, 4, 2, 5, 7, 3, 2, 3, 4, 2, 5, 7, 3, 2, 3], [6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6], [2, 2, 6, 9, 4, 9, 9, 2, 2, 6, 9, 4, 9, 9, 2, 2, 6, 9, 4, 9, 9], [4, 7, 8, 7, 3, 7, 5, 4, 7, 8, 7, 3, 7, 5, 4, 7, 8, 7, 3, 7, 5], [6, 3, 4, 8, 7, 6, 7, 6, 3, 4, 8, 7, 6, 7, 6, 3, 4, 8, 7, 6, 7], [3, 5, 2, 4, 3, 2, 4, 3, 5, 2, 4, 3, 2, 4, 3, 5, 2, 4, 3, 2, 4], [8, 7, 9, 5, 6, 4, 7, 8, 7, 9, 5, 6, 4, 7, 8, 7, 9, 5, 6, 4, 7], [3, 2, 5, 7, 3, 2, 4, 3, 2, 5, 7, 3, 2, 4, 3, 2, 5, 7, 3, 2, 4], [6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6, 6, 7, 4, 6, 9, 4, 6], [9, 2, 6, 9, 4, 9, 2, 9, 2, 6, 9, 4, 9, 2, 9, 2, 6, 9, 4, 9, 2]]}]}"
2o6vgnYmAHPxTXPaxL3iUs,2025-07-21T15:52:22.746027,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 8, 9, 4, 8, 4, 8], [8, 6, 4, 5, 6, 2, 6], [5, 3, 6, 2, 7, 9, 8], [3, 5, 8, 6, 8, 5, 3], [9, 6, 7, 3, 4, 6, 4], [3, 9, 8, 2, 7, 2, 7], [9, 5, 9, 6, 8, 9, 5]], ""output"": [[5, 8, 9, 4, 8, 4, 8, 5, 8, 9, 4, 8, 4, 8, 5, 8, 9, 4, 8, 4, 8], [8, 6, 4, 5, 6, 2, 6, 8, 6, 4, 5, 6, 2, 6, 8, 6, 4, 5, 6, 2, 6], [5, 3, 6, 2, 7, 9, 8, 5, 3, 6, 2, 7, 9, 8, 5, 3, 6, 2, 7, 9, 8], [3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3], [9, 6, 7, 3, 4, 6, 4, 9, 6, 7, 3, 4, 6, 4, 9, 6, 7, 3, 4, 6, 4], [3, 9, 8, 2, 7, 2, 7, 3, 9, 8, 2, 7, 2, 7, 3, 9, 8, 2, 7, 2, 7], [9, 5, 9, 6, 8, 9, 5, 9, 5, 9, 6, 8, 9, 5, 9, 5, 9, 6, 8, 9, 5], [8, 8, 9, 4, 8, 4, 5, 8, 8, 9, 4, 8, 4, 5, 8, 8, 9, 4, 8, 4, 5], [6, 6, 4, 5, 6, 2, 8, 6, 6, 4, 5, 6, 2, 8, 6, 6, 4, 5, 6, 2, 8], [8, 3, 6, 2, 7, 9, 5, 8, 3, 6, 2, 7, 9, 5, 8, 3, 6, 2, 7, 9, 5], [3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3], [4, 6, 7, 3, 4, 6, 9, 4, 6, 7, 3, 4, 6, 9, 4, 6, 7, 3, 4, 6, 9], [7, 9, 8, 2, 7, 2, 3, 7, 9, 8, 2, 7, 2, 3, 7, 9, 8, 2, 7, 2, 3], [5, 5, 9, 6, 8, 9, 9, 5, 5, 9, 6, 8, 9, 9, 5, 5, 9, 6, 8, 9, 9], [5, 8, 9, 4, 8, 4, 8, 5, 8, 9, 4, 8, 4, 8, 5, 8, 9, 4, 8, 4, 8], [8, 6, 4, 5, 6, 2, 6, 8, 6, 4, 5, 6, 2, 6, 8, 6, 4, 5, 6, 2, 6], [5, 3, 6, 2, 7, 9, 8, 5, 3, 6, 2, 7, 9, 8, 5, 3, 6, 2, 7, 9, 8], [3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3, 3, 5, 8, 6, 8, 5, 3], [9, 6, 7, 3, 4, 6, 4, 9, 6, 7, 3, 4, 6, 4, 9, 6, 7, 3, 4, 6, 4], [3, 9, 8, 2, 7, 2, 7, 3, 9, 8, 2, 7, 2, 7, 3, 9, 8, 2, 7, 2, 7], [9, 5, 9, 6, 8, 9, 5, 9, 5, 9, 6, 8, 9, 5, 9, 5, 9, 6, 8, 9, 5]]}, {""input"": [[9, 3, 5, 7, 4, 8, 9], [4, 2, 7, 9, 8, 5, 8], [5, 3, 5, 3, 6, 3, 4], [9, 5, 4, 6, 2, 4, 2], [7, 2, 6, 2, 9, 3, 5], [3, 9, 3, 7, 8, 4, 7], [6, 2, 8, 6, 4, 8, 2]], ""output"": [[9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9], [4, 2, 7, 9, 8, 5, 8, 4, 2, 7, 9, 8, 5, 8, 4, 2, 7, 9, 8, 5, 8], [5, 3, 5, 3, 6, 3, 4, 5, 3, 5, 3, 6, 3, 4, 5, 3, 5, 3, 6, 3, 4], [9, 5, 4, 6, 2, 4, 2, 9, 5, 4, 6, 2, 4, 2, 9, 5, 4, 6, 2, 4, 2], [7, 2, 6, 2, 9, 3, 5, 7, 2, 6, 2, 9, 3, 5, 7, 2, 6, 2, 9, 3, 5], [3, 9, 3, 7, 8, 4, 7, 3, 9, 3, 7, 8, 4, 7, 3, 9, 3, 7, 8, 4, 7], [6, 2, 8, 6, 4, 8, 2, 6, 2, 8, 6, 4, 8, 2, 6, 2, 8, 6, 4, 8, 2], [9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9], [8, 2, 7, 9, 8, 5, 4, 8, 2, 7, 9, 8, 5, 4, 8, 2, 7, 9, 8, 5, 4], [4, 3, 5, 3, 6, 3, 5, 4, 3, 5, 3, 6, 3, 5, 4, 3, 5, 3, 6, 3, 5], [2, 5, 4, 6, 2, 4, 9, 2, 5, 4, 6, 2, 4, 9, 2, 5, 4, 6, 2, 4, 9], [5, 2, 6, 2, 9, 3, 7, 5, 2, 6, 2, 9, 3, 7, 5, 2, 6, 2, 9, 3, 7], [7, 9, 3, 7, 8, 4, 3, 7, 9, 3, 7, 8, 4, 3, 7, 9, 3, 7, 8, 4, 3], [2, 2, 8, 6, 4, 8, 6, 2, 2, 8, 6, 4, 8, 6, 2, 2, 8, 6, 4, 8, 6], [9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9, 9, 3, 5, 7, 4, 8, 9], [4, 2, 7, 9, 8, 5, 8, 4, 2, 7, 9, 8, 5, 8, 4, 2, 7, 9, 8, 5, 8], [5, 3, 5, 3, 6, 3, 4, 5, 3, 5, 3, 6, 3, 4, 5, 3, 5, 3, 6, 3, 4], [9, 5, 4, 6, 2, 4, 2, 9, 5, 4, 6, 2, 4, 2, 9, 5, 4, 6, 2, 4, 2], [7, 2, 6, 2, 9, 3, 5, 7, 2, 6, 2, 9, 3, 5, 7, 2, 6, 2, 9, 3, 5], [3, 9, 3, 7, 8, 4, 7, 3, 9, 3, 7, 8, 4, 7, 3, 9, 3, 7, 8, 4, 7], [6, 2, 8, 6, 4, 8, 2, 6, 2, 8, 6, 4, 8, 2, 6, 2, 8, 6, 4, 8, 2]]}, {""input"": [[2, 7, 3, 2, 8, 9, 3], [9, 6, 7, 3, 2, 8, 2], [5, 3, 5, 4, 3, 7, 8], [8, 4, 2, 3, 5, 2, 6], [7, 8, 9, 7, 2, 4, 8], [9, 4, 5, 6, 9, 8, 6], [3, 5, 2, 9, 3, 5, 8]], ""output"": [[2, 7, 3, 2, 8, 9, 3, 2, 7, 3, 2, 8, 9, 3, 2, 7, 3, 2, 8, 9, 3], [9, 6, 7, 3, 2, 8, 2, 9, 6, 7, 3, 2, 8, 2, 9, 6, 7, 3, 2, 8, 2], [5, 3, 5, 4, 3, 7, 8, 5, 3, 5, 4, 3, 7, 8, 5, 3, 5, 4, 3, 7, 8], [8, 4, 2, 3, 5, 2, 6, 8, 4, 2, 3, 5, 2, 6, 8, 4, 2, 3, 5, 2, 6], [7, 8, 9, 7, 2, 4, 8, 7, 8, 9, 7, 2, 4, 8, 7, 8, 9, 7, 2, 4, 8], [9, 4, 5, 6, 9, 8, 6, 9, 4, 5, 6, 9, 8, 6, 9, 4, 5, 6, 9, 8, 6], [3, 5, 2, 9, 3, 5, 8, 3, 5, 2, 9, 3, 5, 8, 3, 5, 2, 9, 3, 5, 8], [3, 7, 3, 2, 8, 9, 2, 3, 7, 3, 2, 8, 9, 2, 3, 7, 3, 2, 8, 9, 2], [2, 6, 7, 3, 2, 8, 9, 2, 6, 7, 3, 2, 8, 9, 2, 6, 7, 3, 2, 8, 9], [8, 3, 5, 4, 3, 7, 5, 8, 3, 5, 4, 3, 7, 5, 8, 3, 5, 4, 3, 7, 5], [6, 4, 2, 3, 5, 2, 8, 6, 4, 2, 3, 5, 2, 8, 6, 4, 2, 3, 5, 2, 8], [8, 8, 9, 7, 2, 4, 7, 8, 8, 9, 7, 2, 4, 7, 8, 8, 9, 7, 2, 4, 7], [6, 4, 5, 6, 9, 8, 9, 6, 4, 5, 6, 9, 8, 9, 6, 4, 5, 6, 9, 8, 9], [8, 5, 2, 9, 3, 5, 3, 8, 5, 2, 9, 3, 5, 3, 8, 5, 2, 9, 3, 5, 3], [2, 7, 3, 2, 8, 9, 3, 2, 7, 3, 2, 8, 9, 3, 2, 7, 3, 2, 8, 9, 3], [9, 6, 7, 3, 2, 8, 2, 9, 6, 7, 3, 2, 8, 2, 9, 6, 7, 3, 2, 8, 2], [5, 3, 5, 4, 3, 7, 8, 5, 3, 5, 4, 3, 7, 8, 5, 3, 5, 4, 3, 7, 8], [8, 4, 2, 3, 5, 2, 6, 8, 4, 2, 3, 5, 2, 6, 8, 4, 2, 3, 5, 2, 6], [7, 8, 9, 7, 2, 4, 8, 7, 8, 9, 7, 2, 4, 8, 7, 8, 9, 7, 2, 4, 8], [9, 4, 5, 6, 9, 8, 6, 9, 4, 5, 6, 9, 8, 6, 9, 4, 5, 6, 9, 8, 6], [3, 5, 2, 9, 3, 5, 8, 3, 5, 2, 9, 3, 5, 8, 3, 5, 2, 9, 3, 5, 8]]}], ""test"": [{""input"": [[5, 8, 4, 2, 5, 3, 7], [6, 9, 2, 7, 9, 2, 3], [9, 3, 6, 8, 6, 9, 2], [4, 8, 4, 7, 4, 6, 8], [8, 7, 3, 9, 5, 7, 9], [6, 8, 6, 8, 6, 2, 7], [9, 3, 4, 2, 3, 7, 1]], ""output"": [[5, 8, 4, 2, 5, 3, 7, 5, 8, 4, 2, 5, 3, 7, 5, 8, 4, 2, 5, 3, 7], [6, 9, 2, 7, 9, 2, 3, 6, 9, 2, 7, 9, 2, 3, 6, 9, 2, 7, 9, 2, 3], [9, 3, 6, 8, 6, 9, 2, 9, 3, 6, 8, 6, 9, 2, 9, 3, 6, 8, 6, 9, 2], [4, 8, 4, 7, 4, 6, 8, 4, 8, 4, 7, 4, 6, 8, 4, 8, 4, 7, 4, 6, 8], [8, 7, 3, 9, 5, 7, 9, 8, 7, 3, 9, 5, 7, 9, 8, 7, 3, 9, 5, 7, 9], [6, 8, 6, 8, 6, 2, 7, 6, 8, 6, 8, 6, 2, 7, 6, 8, 6, 8, 6, 2, 7], [9, 3, 4, 2, 3, 7, 1, 9, 3, 4, 2, 3, 7, 1, 9, 3, 4, 2, 3, 7, 1], [7, 8, 4, 2, 5, 3, 5, 7, 8, 4, 2, 5, 3, 5, 7, 8, 4, 2, 5, 3, 5], [3, 9, 2, 7, 9, 2, 6, 3, 9, 2, 7, 9, 2, 6, 3, 9, 2, 7, 9, 2, 6], [2, 3, 6, 8, 6, 9, 9, 2, 3, 6, 8, 6, 9, 9, 2, 3, 6, 8, 6, 9, 9], [8, 8, 4, 7, 4, 6, 4, 8, 8, 4, 7, 4, 6, 4, 8, 8, 4, 7, 4, 6, 4], [9, 7, 3, 9, 5, 7, 8, 9, 7, 3, 9, 5, 7, 8, 9, 7, 3, 9, 5, 7, 8], [7, 8, 6, 8, 6, 2, 6, 7, 8, 6, 8, 6, 2, 6, 7, 8, 6, 8, 6, 2, 6], [1, 3, 4, 2, 3, 7, 9, 1, 3, 4, 2, 3, 7, 9, 1, 3, 4, 2, 3, 7, 9], [5, 8, 4, 2, 5, 3, 7, 5, 8, 4, 2, 5, 3, 7, 5, 8, 4, 2, 5, 3, 7], [6, 9, 2, 7, 9, 2, 3, 6, 9, 2, 7, 9, 2, 3, 6, 9, 2, 7, 9, 2, 3], [9, 3, 6, 8, 6, 9, 2, 9, 3, 6, 8, 6, 9, 2, 9, 3, 6, 8, 6, 9, 2], [4, 8, 4, 7, 4, 6, 8, 4, 8, 4, 7, 4, 6, 8, 4, 8, 4, 7, 4, 6, 8], [8, 7, 3, 9, 5, 7, 9, 8, 7, 3, 9, 5, 7, 9, 8, 7, 3, 9, 5, 7, 9], [6, 8, 6, 8, 6, 2, 7, 6, 8, 6, 8, 6, 2, 7, 6, 8, 6, 8, 6, 2, 7], [9, 3, 4, 2, 3, 7, 1, 9, 3, 4, 2, 3, 7, 1, 9, 3, 4, 2, 3, 7, 1]]}]}"
NaoTksAwFW988kuKFFJZig,2025-07-21T15:52:22.749181,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 5, 7], [8, 2, 3], [2, 3, 7]], ""output"": [[7, 5, 7, 7, 5, 7, 7, 5, 7], [8, 2, 3, 8, 2, 3, 8, 2, 3], [2, 3, 7, 2, 3, 7, 2, 3, 7], [7, 5, 7, 7, 5, 7, 7, 5, 7], [3, 2, 8, 3, 2, 8, 3, 2, 8], [7, 3, 2, 7, 3, 2, 7, 3, 2], [7, 5, 7, 7, 5, 7, 7, 5, 7], [8, 2, 3, 8, 2, 3, 8, 2, 3], [2, 3, 7, 2, 3, 7, 2, 3, 7]]}, {""input"": [[9, 3, 5], [5, 7, 3], [8, 4, 1]], ""output"": [[9, 3, 5, 9, 3, 5, 9, 3, 5], [5, 7, 3, 5, 7, 3, 5, 7, 3], [8, 4, 1, 8, 4, 1, 8, 4, 1], [5, 3, 9, 5, 3, 9, 5, 3, 9], [3, 7, 5, 3, 7, 5, 3, 7, 5], [1, 4, 8, 1, 4, 8, 1, 4, 8], [9, 3, 5, 9, 3, 5, 9, 3, 5], [5, 7, 3, 5, 7, 3, 5, 7, 3], [8, 4, 1, 8, 4, 1, 8, 4, 1]]}, {""input"": [[8, 6, 4], [2, 9, 7], [6, 7, 3]], ""output"": [[8, 6, 4, 8, 6, 4, 8, 6, 4], [2, 9, 7, 2, 9, 7, 2, 9, 7], [6, 7, 3, 6, 7, 3, 6, 7, 3], [4, 6, 8, 4, 6, 8, 4, 6, 8], [7, 9, 2, 7, 9, 2, 7, 9, 2], [3, 7, 6, 3, 7, 6, 3, 7, 6], [8, 6, 4, 8, 6, 4, 8, 6, 4], [2, 9, 7, 2, 9, 7, 2, 9, 7], [6, 7, 3, 6, 7, 3, 6, 7, 3]]}], ""test"": [{""input"": [[8, 9, 5], [3, 4, 7], [7, 9, 4]], ""output"": [[8, 9, 5, 8, 9, 5, 8, 9, 5], [3, 4, 7, 3, 4, 7, 3, 4, 7], [7, 9, 4, 7, 9, 4, 7, 9, 4], [5, 9, 8, 5, 9, 8, 5, 9, 8], [7, 4, 3, 7, 4, 3, 7, 4, 3], [4, 9, 7, 4, 9, 7, 4, 9, 7], [8, 9, 5, 8, 9, 5, 8, 9, 5], [3, 4, 7, 3, 4, 7, 3, 4, 7], [7, 9, 4, 7, 9, 4, 7, 9, 4]]}]}"
oDa2svD7WRc47hDN9RdGyu,2025-07-21T15:52:22.751647,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 4], [6, 5]], ""output"": [[2, 4, 2, 4, 2, 4], [6, 5, 6, 5, 6, 5], [4, 2, 4, 2, 4, 2], [5, 6, 5, 6, 5, 6], [2, 4, 2, 4, 2, 4], [6, 5, 6, 5, 6, 5]]}, {""input"": [[3, 4], [2, 5]], ""output"": [[3, 4, 3, 4, 3, 4], [2, 5, 2, 5, 2, 5], [4, 3, 4, 3, 4, 3], [5, 2, 5, 2, 5, 2], [3, 4, 3, 4, 3, 4], [2, 5, 2, 5, 2, 5]]}, {""input"": [[7, 4], [8, 6]], ""output"": [[7, 4, 7, 4, 7, 4], [8, 6, 8, 6, 8, 6], [4, 7, 4, 7, 4, 7], [6, 8, 6, 8, 6, 8], [7, 4, 7, 4, 7, 4], [8, 6, 8, 6, 8, 6]]}], ""test"": [{""input"": [[3, 4], [7, 8]], ""output"": [[3, 4, 3, 4, 3, 4], [7, 8, 7, 8, 7, 8], [4, 3, 4, 3, 4, 3], [8, 7, 8, 7, 8, 7], [3, 4, 3, 4, 3, 4], [7, 8, 7, 8, 7, 8]]}]}"
7iLVr7w6nRoLMXmKXLcV7o,2025-07-21T15:52:22.754250,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 7], [5, 2]], ""output"": [[3, 7, 3, 7, 3, 7], [5, 2, 5, 2, 5, 2], [7, 3, 7, 3, 7, 3], [2, 5, 2, 5, 2, 5], [3, 7, 3, 7, 3, 7], [5, 2, 5, 2, 5, 2]]}, {""input"": [[2, 8], [6, 4]], ""output"": [[2, 8, 2, 8, 2, 8], [6, 4, 6, 4, 6, 4], [8, 2, 8, 2, 8, 2], [4, 6, 4, 6, 4, 6], [2, 8, 2, 8, 2, 8], [6, 4, 6, 4, 6, 4]]}, {""input"": [[8, 6], [3, 7]], ""output"": [[8, 6, 8, 6, 8, 6], [3, 7, 3, 7, 3, 7], [6, 8, 6, 8, 6, 8], [7, 3, 7, 3, 7, 3], [8, 6, 8, 6, 8, 6], [3, 7, 3, 7, 3, 7]]}], ""test"": [{""input"": [[7, 4], [4, 7]], ""output"": [[7, 4, 7, 4, 7, 4], [4, 7, 4, 7, 4, 7], [4, 7, 4, 7, 4, 7], [7, 4, 7, 4, 7, 4], [7, 4, 7, 4, 7, 4], [4, 7, 4, 7, 4, 7]]}]}"
8vjVNyABmgAiBQB7nYH5D5,2025-07-21T15:52:22.757974,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 7, 3, 5, 9, 8, 5], [5, 6, 2, 7, 3, 9, 8], [2, 8, 9, 5, 8, 2, 4], [5, 6, 2, 8, 6, 9, 7], [3, 5, 6, 2, 9, 4, 2], [2, 8, 4, 6, 7, 2, 4], [7, 9, 8, 3, 6, 5, 8]], ""output"": [[6, 7, 3, 5, 9, 8, 5, 6, 7, 3, 5, 9, 8, 5, 6, 7, 3, 5, 9, 8, 5], [5, 6, 2, 7, 3, 9, 8, 5, 6, 2, 7, 3, 9, 8, 5, 6, 2, 7, 3, 9, 8], [2, 8, 9, 5, 8, 2, 4, 2, 8, 9, 5, 8, 2, 4, 2, 8, 9, 5, 8, 2, 4], [5, 6, 2, 8, 6, 9, 7, 5, 6, 2, 8, 6, 9, 7, 5, 6, 2, 8, 6, 9, 7], [3, 5, 6, 2, 9, 4, 2, 3, 5, 6, 2, 9, 4, 2, 3, 5, 6, 2, 9, 4, 2], [2, 8, 4, 6, 7, 2, 4, 2, 8, 4, 6, 7, 2, 4, 2, 8, 4, 6, 7, 2, 4], [7, 9, 8, 3, 6, 5, 8, 7, 9, 8, 3, 6, 5, 8, 7, 9, 8, 3, 6, 5, 8], [5, 7, 3, 5, 9, 8, 6, 5, 7, 3, 5, 9, 8, 6, 5, 7, 3, 5, 9, 8, 6], [8, 6, 2, 7, 3, 9, 5, 8, 6, 2, 7, 3, 9, 5, 8, 6, 2, 7, 3, 9, 5], [4, 8, 9, 5, 8, 2, 2, 4, 8, 9, 5, 8, 2, 2, 4, 8, 9, 5, 8, 2, 2], [7, 6, 2, 8, 6, 9, 5, 7, 6, 2, 8, 6, 9, 5, 7, 6, 2, 8, 6, 9, 5], [2, 5, 6, 2, 9, 4, 3, 2, 5, 6, 2, 9, 4, 3, 2, 5, 6, 2, 9, 4, 3], [4, 8, 4, 6, 7, 2, 2, 4, 8, 4, 6, 7, 2, 2, 4, 8, 4, 6, 7, 2, 2], [8, 9, 8, 3, 6, 5, 7, 8, 9, 8, 3, 6, 5, 7, 8, 9, 8, 3, 6, 5, 7], [6, 7, 3, 5, 9, 8, 5, 6, 7, 3, 5, 9, 8, 5, 6, 7, 3, 5, 9, 8, 5], [5, 6, 2, 7, 3, 9, 8, 5, 6, 2, 7, 3, 9, 8, 5, 6, 2, 7, 3, 9, 8], [2, 8, 9, 5, 8, 2, 4, 2, 8, 9, 5, 8, 2, 4, 2, 8, 9, 5, 8, 2, 4], [5, 6, 2, 8, 6, 9, 7, 5, 6, 2, 8, 6, 9, 7, 5, 6, 2, 8, 6, 9, 7], [3, 5, 6, 2, 9, 4, 2, 3, 5, 6, 2, 9, 4, 2, 3, 5, 6, 2, 9, 4, 2], [2, 8, 4, 6, 7, 2, 4, 2, 8, 4, 6, 7, 2, 4, 2, 8, 4, 6, 7, 2, 4], [7, 9, 8, 3, 6, 5, 8, 7, 9, 8, 3, 6, 5, 8, 7, 9, 8, 3, 6, 5, 8]]}, {""input"": [[3, 2, 3, 4, 9, 6, 7], [4, 6, 2, 7, 5, 9, 8], [9, 8, 5, 2, 9, 4, 7], [2, 4, 7, 9, 3, 5, 9], [5, 3, 6, 2, 9, 7, 3], [6, 2, 9, 7, 5, 3, 6], [3, 6, 5, 3, 8, 6, 5]], ""output"": [[3, 2, 3, 4, 9, 6, 7, 3, 2, 3, 4, 9, 6, 7, 3, 2, 3, 4, 9, 6, 7], [4, 6, 2, 7, 5, 9, 8, 4, 6, 2, 7, 5, 9, 8, 4, 6, 2, 7, 5, 9, 8], [9, 8, 5, 2, 9, 4, 7, 9, 8, 5, 2, 9, 4, 7, 9, 8, 5, 2, 9, 4, 7], [2, 4, 7, 9, 3, 5, 9, 2, 4, 7, 9, 3, 5, 9, 2, 4, 7, 9, 3, 5, 9], [5, 3, 6, 2, 9, 7, 3, 5, 3, 6, 2, 9, 7, 3, 5, 3, 6, 2, 9, 7, 3], [6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6], [3, 6, 5, 3, 8, 6, 5, 3, 6, 5, 3, 8, 6, 5, 3, 6, 5, 3, 8, 6, 5], [7, 2, 3, 4, 9, 6, 3, 7, 2, 3, 4, 9, 6, 3, 7, 2, 3, 4, 9, 6, 3], [8, 6, 2, 7, 5, 9, 4, 8, 6, 2, 7, 5, 9, 4, 8, 6, 2, 7, 5, 9, 4], [7, 8, 5, 2, 9, 4, 9, 7, 8, 5, 2, 9, 4, 9, 7, 8, 5, 2, 9, 4, 9], [9, 4, 7, 9, 3, 5, 2, 9, 4, 7, 9, 3, 5, 2, 9, 4, 7, 9, 3, 5, 2], [3, 3, 6, 2, 9, 7, 5, 3, 3, 6, 2, 9, 7, 5, 3, 3, 6, 2, 9, 7, 5], [6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6], [5, 6, 5, 3, 8, 6, 3, 5, 6, 5, 3, 8, 6, 3, 5, 6, 5, 3, 8, 6, 3], [3, 2, 3, 4, 9, 6, 7, 3, 2, 3, 4, 9, 6, 7, 3, 2, 3, 4, 9, 6, 7], [4, 6, 2, 7, 5, 9, 8, 4, 6, 2, 7, 5, 9, 8, 4, 6, 2, 7, 5, 9, 8], [9, 8, 5, 2, 9, 4, 7, 9, 8, 5, 2, 9, 4, 7, 9, 8, 5, 2, 9, 4, 7], [2, 4, 7, 9, 3, 5, 9, 2, 4, 7, 9, 3, 5, 9, 2, 4, 7, 9, 3, 5, 9], [5, 3, 6, 2, 9, 7, 3, 5, 3, 6, 2, 9, 7, 3, 5, 3, 6, 2, 9, 7, 3], [6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6, 6, 2, 9, 7, 5, 3, 6], [3, 6, 5, 3, 8, 6, 5, 3, 6, 5, 3, 8, 6, 5, 3, 6, 5, 3, 8, 6, 5]]}, {""input"": [[2, 7, 6, 3, 8, 7, 5], [6, 4, 8, 5, 6, 2, 7], [4, 8, 9, 2, 4, 6, 8], [5, 2, 8, 5, 8, 5, 7], [4, 8, 9, 8, 2, 4, 8], [7, 3, 4, 7, 5, 6, 2], [5, 7, 6, 5, 2, 5, 9]], ""output"": [[2, 7, 6, 3, 8, 7, 5, 2, 7, 6, 3, 8, 7, 5, 2, 7, 6, 3, 8, 7, 5], [6, 4, 8, 5, 6, 2, 7, 6, 4, 8, 5, 6, 2, 7, 6, 4, 8, 5, 6, 2, 7], [4, 8, 9, 2, 4, 6, 8, 4, 8, 9, 2, 4, 6, 8, 4, 8, 9, 2, 4, 6, 8], [5, 2, 8, 5, 8, 5, 7, 5, 2, 8, 5, 8, 5, 7, 5, 2, 8, 5, 8, 5, 7], [4, 8, 9, 8, 2, 4, 8, 4, 8, 9, 8, 2, 4, 8, 4, 8, 9, 8, 2, 4, 8], [7, 3, 4, 7, 5, 6, 2, 7, 3, 4, 7, 5, 6, 2, 7, 3, 4, 7, 5, 6, 2], [5, 7, 6, 5, 2, 5, 9, 5, 7, 6, 5, 2, 5, 9, 5, 7, 6, 5, 2, 5, 9], [5, 7, 6, 3, 8, 7, 2, 5, 7, 6, 3, 8, 7, 2, 5, 7, 6, 3, 8, 7, 2], [7, 4, 8, 5, 6, 2, 6, 7, 4, 8, 5, 6, 2, 6, 7, 4, 8, 5, 6, 2, 6], [8, 8, 9, 2, 4, 6, 4, 8, 8, 9, 2, 4, 6, 4, 8, 8, 9, 2, 4, 6, 4], [7, 2, 8, 5, 8, 5, 5, 7, 2, 8, 5, 8, 5, 5, 7, 2, 8, 5, 8, 5, 5], [8, 8, 9, 8, 2, 4, 4, 8, 8, 9, 8, 2, 4, 4, 8, 8, 9, 8, 2, 4, 4], [2, 3, 4, 7, 5, 6, 7, 2, 3, 4, 7, 5, 6, 7, 2, 3, 4, 7, 5, 6, 7], [9, 7, 6, 5, 2, 5, 5, 9, 7, 6, 5, 2, 5, 5, 9, 7, 6, 5, 2, 5, 5], [2, 7, 6, 3, 8, 7, 5, 2, 7, 6, 3, 8, 7, 5, 2, 7, 6, 3, 8, 7, 5], [6, 4, 8, 5, 6, 2, 7, 6, 4, 8, 5, 6, 2, 7, 6, 4, 8, 5, 6, 2, 7], [4, 8, 9, 2, 4, 6, 8, 4, 8, 9, 2, 4, 6, 8, 4, 8, 9, 2, 4, 6, 8], [5, 2, 8, 5, 8, 5, 7, 5, 2, 8, 5, 8, 5, 7, 5, 2, 8, 5, 8, 5, 7], [4, 8, 9, 8, 2, 4, 8, 4, 8, 9, 8, 2, 4, 8, 4, 8, 9, 8, 2, 4, 8], [7, 3, 4, 7, 5, 6, 2, 7, 3, 4, 7, 5, 6, 2, 7, 3, 4, 7, 5, 6, 2], [5, 7, 6, 5, 2, 5, 9, 5, 7, 6, 5, 2, 5, 9, 5, 7, 6, 5, 2, 5, 9]]}], ""test"": [{""input"": [[5, 8, 6, 4, 8, 7, 5], [4, 9, 3, 5, 9, 5, 8], [3, 8, 7, 2, 6, 3, 6], [2, 6, 2, 4, 3, 8, 3], [3, 4, 9, 7, 6, 2, 7], [4, 7, 5, 4, 7, 4, 9], [9, 8, 9, 8, 9, 5, 7]], ""output"": [[5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5], [4, 9, 3, 5, 9, 5, 8, 4, 9, 3, 5, 9, 5, 8, 4, 9, 3, 5, 9, 5, 8], [3, 8, 7, 2, 6, 3, 6, 3, 8, 7, 2, 6, 3, 6, 3, 8, 7, 2, 6, 3, 6], [2, 6, 2, 4, 3, 8, 3, 2, 6, 2, 4, 3, 8, 3, 2, 6, 2, 4, 3, 8, 3], [3, 4, 9, 7, 6, 2, 7, 3, 4, 9, 7, 6, 2, 7, 3, 4, 9, 7, 6, 2, 7], [4, 7, 5, 4, 7, 4, 9, 4, 7, 5, 4, 7, 4, 9, 4, 7, 5, 4, 7, 4, 9], [9, 8, 9, 8, 9, 5, 7, 9, 8, 9, 8, 9, 5, 7, 9, 8, 9, 8, 9, 5, 7], [5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5], [8, 9, 3, 5, 9, 5, 4, 8, 9, 3, 5, 9, 5, 4, 8, 9, 3, 5, 9, 5, 4], [6, 8, 7, 2, 6, 3, 3, 6, 8, 7, 2, 6, 3, 3, 6, 8, 7, 2, 6, 3, 3], [3, 6, 2, 4, 3, 8, 2, 3, 6, 2, 4, 3, 8, 2, 3, 6, 2, 4, 3, 8, 2], [7, 4, 9, 7, 6, 2, 3, 7, 4, 9, 7, 6, 2, 3, 7, 4, 9, 7, 6, 2, 3], [9, 7, 5, 4, 7, 4, 4, 9, 7, 5, 4, 7, 4, 4, 9, 7, 5, 4, 7, 4, 4], [7, 8, 9, 8, 9, 5, 9, 7, 8, 9, 8, 9, 5, 9, 7, 8, 9, 8, 9, 5, 9], [5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5, 5, 8, 6, 4, 8, 7, 5], [4, 9, 3, 5, 9, 5, 8, 4, 9, 3, 5, 9, 5, 8, 4, 9, 3, 5, 9, 5, 8], [3, 8, 7, 2, 6, 3, 6, 3, 8, 7, 2, 6, 3, 6, 3, 8, 7, 2, 6, 3, 6], [2, 6, 2, 4, 3, 8, 3, 2, 6, 2, 4, 3, 8, 3, 2, 6, 2, 4, 3, 8, 3], [3, 4, 9, 7, 6, 2, 7, 3, 4, 9, 7, 6, 2, 7, 3, 4, 9, 7, 6, 2, 7], [4, 7, 5, 4, 7, 4, 9, 4, 7, 5, 4, 7, 4, 9, 4, 7, 5, 4, 7, 4, 9], [9, 8, 9, 8, 9, 5, 7, 9, 8, 9, 8, 9, 5, 7, 9, 8, 9, 8, 9, 5, 7]]}]}"
NKag7vB2dkhS3jv7P8uQdX,2025-07-21T15:52:22.762139,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 3, 7, 6, 7, 9, 3], [3, 8, 9, 3, 4, 5, 8], [6, 7, 8, 7, 2, 7, 4], [4, 2, 3, 5, 4, 3, 8], [6, 5, 2, 6, 2, 6, 7], [9, 4, 8, 2, 7, 2, 3], [3, 7, 4, 7, 3, 6, 4]], ""output"": [[9, 3, 7, 6, 7, 9, 3, 9, 3, 7, 6, 7, 9, 3, 9, 3, 7, 6, 7, 9, 3], [3, 8, 9, 3, 4, 5, 8, 3, 8, 9, 3, 4, 5, 8, 3, 8, 9, 3, 4, 5, 8], [6, 7, 8, 7, 2, 7, 4, 6, 7, 8, 7, 2, 7, 4, 6, 7, 8, 7, 2, 7, 4], [4, 2, 3, 5, 4, 3, 8, 4, 2, 3, 5, 4, 3, 8, 4, 2, 3, 5, 4, 3, 8], [6, 5, 2, 6, 2, 6, 7, 6, 5, 2, 6, 2, 6, 7, 6, 5, 2, 6, 2, 6, 7], [9, 4, 8, 2, 7, 2, 3, 9, 4, 8, 2, 7, 2, 3, 9, 4, 8, 2, 7, 2, 3], [3, 7, 4, 7, 3, 6, 4, 3, 7, 4, 7, 3, 6, 4, 3, 7, 4, 7, 3, 6, 4], [3, 3, 7, 6, 7, 9, 9, 3, 3, 7, 6, 7, 9, 9, 3, 3, 7, 6, 7, 9, 9], [8, 8, 9, 3, 4, 5, 3, 8, 8, 9, 3, 4, 5, 3, 8, 8, 9, 3, 4, 5, 3], [4, 7, 8, 7, 2, 7, 6, 4, 7, 8, 7, 2, 7, 6, 4, 7, 8, 7, 2, 7, 6], [8, 2, 3, 5, 4, 3, 4, 8, 2, 3, 5, 4, 3, 4, 8, 2, 3, 5, 4, 3, 4], [7, 5, 2, 6, 2, 6, 6, 7, 5, 2, 6, 2, 6, 6, 7, 5, 2, 6, 2, 6, 6], [3, 4, 8, 2, 7, 2, 9, 3, 4, 8, 2, 7, 2, 9, 3, 4, 8, 2, 7, 2, 9], [4, 7, 4, 7, 3, 6, 3, 4, 7, 4, 7, 3, 6, 3, 4, 7, 4, 7, 3, 6, 3], [9, 3, 7, 6, 7, 9, 3, 9, 3, 7, 6, 7, 9, 3, 9, 3, 7, 6, 7, 9, 3], [3, 8, 9, 3, 4, 5, 8, 3, 8, 9, 3, 4, 5, 8, 3, 8, 9, 3, 4, 5, 8], [6, 7, 8, 7, 2, 7, 4, 6, 7, 8, 7, 2, 7, 4, 6, 7, 8, 7, 2, 7, 4], [4, 2, 3, 5, 4, 3, 8, 4, 2, 3, 5, 4, 3, 8, 4, 2, 3, 5, 4, 3, 8], [6, 5, 2, 6, 2, 6, 7, 6, 5, 2, 6, 2, 6, 7, 6, 5, 2, 6, 2, 6, 7], [9, 4, 8, 2, 7, 2, 3, 9, 4, 8, 2, 7, 2, 3, 9, 4, 8, 2, 7, 2, 3], [3, 7, 4, 7, 3, 6, 4, 3, 7, 4, 7, 3, 6, 4, 3, 7, 4, 7, 3, 6, 4]]}, {""input"": [[7, 6, 2, 7, 9, 4, 3], [2, 4, 3, 6, 3, 2, 8], [6, 8, 4, 8, 4, 9, 3], [5, 9, 2, 4, 7, 8, 6], [6, 2, 5, 3, 9, 6, 8], [4, 8, 3, 7, 3, 2, 9], [3, 2, 4, 6, 8, 7, 4]], ""output"": [[7, 6, 2, 7, 9, 4, 3, 7, 6, 2, 7, 9, 4, 3, 7, 6, 2, 7, 9, 4, 3], [2, 4, 3, 6, 3, 2, 8, 2, 4, 3, 6, 3, 2, 8, 2, 4, 3, 6, 3, 2, 8], [6, 8, 4, 8, 4, 9, 3, 6, 8, 4, 8, 4, 9, 3, 6, 8, 4, 8, 4, 9, 3], [5, 9, 2, 4, 7, 8, 6, 5, 9, 2, 4, 7, 8, 6, 5, 9, 2, 4, 7, 8, 6], [6, 2, 5, 3, 9, 6, 8, 6, 2, 5, 3, 9, 6, 8, 6, 2, 5, 3, 9, 6, 8], [4, 8, 3, 7, 3, 2, 9, 4, 8, 3, 7, 3, 2, 9, 4, 8, 3, 7, 3, 2, 9], [3, 2, 4, 6, 8, 7, 4, 3, 2, 4, 6, 8, 7, 4, 3, 2, 4, 6, 8, 7, 4], [3, 6, 2, 7, 9, 4, 7, 3, 6, 2, 7, 9, 4, 7, 3, 6, 2, 7, 9, 4, 7], [8, 4, 3, 6, 3, 2, 2, 8, 4, 3, 6, 3, 2, 2, 8, 4, 3, 6, 3, 2, 2], [3, 8, 4, 8, 4, 9, 6, 3, 8, 4, 8, 4, 9, 6, 3, 8, 4, 8, 4, 9, 6], [6, 9, 2, 4, 7, 8, 5, 6, 9, 2, 4, 7, 8, 5, 6, 9, 2, 4, 7, 8, 5], [8, 2, 5, 3, 9, 6, 6, 8, 2, 5, 3, 9, 6, 6, 8, 2, 5, 3, 9, 6, 6], [9, 8, 3, 7, 3, 2, 4, 9, 8, 3, 7, 3, 2, 4, 9, 8, 3, 7, 3, 2, 4], [4, 2, 4, 6, 8, 7, 3, 4, 2, 4, 6, 8, 7, 3, 4, 2, 4, 6, 8, 7, 3], [7, 6, 2, 7, 9, 4, 3, 7, 6, 2, 7, 9, 4, 3, 7, 6, 2, 7, 9, 4, 3], [2, 4, 3, 6, 3, 2, 8, 2, 4, 3, 6, 3, 2, 8, 2, 4, 3, 6, 3, 2, 8], [6, 8, 4, 8, 4, 9, 3, 6, 8, 4, 8, 4, 9, 3, 6, 8, 4, 8, 4, 9, 3], [5, 9, 2, 4, 7, 8, 6, 5, 9, 2, 4, 7, 8, 6, 5, 9, 2, 4, 7, 8, 6], [6, 2, 5, 3, 9, 6, 8, 6, 2, 5, 3, 9, 6, 8, 6, 2, 5, 3, 9, 6, 8], [4, 8, 3, 7, 3, 2, 9, 4, 8, 3, 7, 3, 2, 9, 4, 8, 3, 7, 3, 2, 9], [3, 2, 4, 6, 8, 7, 4, 3, 2, 4, 6, 8, 7, 4, 3, 2, 4, 6, 8, 7, 4]]}, {""input"": [[7, 4, 5, 2, 9, 4, 2], [8, 5, 4, 3, 5, 3, 8], [2, 6, 9, 2, 3, 4, 2], [5, 7, 5, 4, 6, 5, 8], [3, 8, 2, 9, 5, 7, 9], [5, 6, 3, 6, 8, 3, 5], [8, 4, 8, 2, 7, 4, 9]], ""output"": [[7, 4, 5, 2, 9, 4, 2, 7, 4, 5, 2, 9, 4, 2, 7, 4, 5, 2, 9, 4, 2], [8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8], [2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2], [5, 7, 5, 4, 6, 5, 8, 5, 7, 5, 4, 6, 5, 8, 5, 7, 5, 4, 6, 5, 8], [3, 8, 2, 9, 5, 7, 9, 3, 8, 2, 9, 5, 7, 9, 3, 8, 2, 9, 5, 7, 9], [5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5], [8, 4, 8, 2, 7, 4, 9, 8, 4, 8, 2, 7, 4, 9, 8, 4, 8, 2, 7, 4, 9], [2, 4, 5, 2, 9, 4, 7, 2, 4, 5, 2, 9, 4, 7, 2, 4, 5, 2, 9, 4, 7], [8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8], [2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2], [8, 7, 5, 4, 6, 5, 5, 8, 7, 5, 4, 6, 5, 5, 8, 7, 5, 4, 6, 5, 5], [9, 8, 2, 9, 5, 7, 3, 9, 8, 2, 9, 5, 7, 3, 9, 8, 2, 9, 5, 7, 3], [5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5], [9, 4, 8, 2, 7, 4, 8, 9, 4, 8, 2, 7, 4, 8, 9, 4, 8, 2, 7, 4, 8], [7, 4, 5, 2, 9, 4, 2, 7, 4, 5, 2, 9, 4, 2, 7, 4, 5, 2, 9, 4, 2], [8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8, 8, 5, 4, 3, 5, 3, 8], [2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2, 2, 6, 9, 2, 3, 4, 2], [5, 7, 5, 4, 6, 5, 8, 5, 7, 5, 4, 6, 5, 8, 5, 7, 5, 4, 6, 5, 8], [3, 8, 2, 9, 5, 7, 9, 3, 8, 2, 9, 5, 7, 9, 3, 8, 2, 9, 5, 7, 9], [5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5, 5, 6, 3, 6, 8, 3, 5], [8, 4, 8, 2, 7, 4, 9, 8, 4, 8, 2, 7, 4, 9, 8, 4, 8, 2, 7, 4, 9]]}], ""test"": [{""input"": [[4, 5, 3, 5, 2, 4, 3], [2, 9, 8, 9, 5, 8, 9], [5, 4, 5, 8, 2, 3, 2], [4, 9, 6, 5, 3, 8, 7], [3, 7, 3, 4, 8, 9, 6], [4, 8, 4, 9, 5, 4, 3], [5, 6, 3, 8, 7, 2, 9]], ""output"": [[4, 5, 3, 5, 2, 4, 3, 4, 5, 3, 5, 2, 4, 3, 4, 5, 3, 5, 2, 4, 3], [2, 9, 8, 9, 5, 8, 9, 2, 9, 8, 9, 5, 8, 9, 2, 9, 8, 9, 5, 8, 9], [5, 4, 5, 8, 2, 3, 2, 5, 4, 5, 8, 2, 3, 2, 5, 4, 5, 8, 2, 3, 2], [4, 9, 6, 5, 3, 8, 7, 4, 9, 6, 5, 3, 8, 7, 4, 9, 6, 5, 3, 8, 7], [3, 7, 3, 4, 8, 9, 6, 3, 7, 3, 4, 8, 9, 6, 3, 7, 3, 4, 8, 9, 6], [4, 8, 4, 9, 5, 4, 3, 4, 8, 4, 9, 5, 4, 3, 4, 8, 4, 9, 5, 4, 3], [5, 6, 3, 8, 7, 2, 9, 5, 6, 3, 8, 7, 2, 9, 5, 6, 3, 8, 7, 2, 9], [3, 5, 3, 5, 2, 4, 4, 3, 5, 3, 5, 2, 4, 4, 3, 5, 3, 5, 2, 4, 4], [9, 9, 8, 9, 5, 8, 2, 9, 9, 8, 9, 5, 8, 2, 9, 9, 8, 9, 5, 8, 2], [2, 4, 5, 8, 2, 3, 5, 2, 4, 5, 8, 2, 3, 5, 2, 4, 5, 8, 2, 3, 5], [7, 9, 6, 5, 3, 8, 4, 7, 9, 6, 5, 3, 8, 4, 7, 9, 6, 5, 3, 8, 4], [6, 7, 3, 4, 8, 9, 3, 6, 7, 3, 4, 8, 9, 3, 6, 7, 3, 4, 8, 9, 3], [3, 8, 4, 9, 5, 4, 4, 3, 8, 4, 9, 5, 4, 4, 3, 8, 4, 9, 5, 4, 4], [9, 6, 3, 8, 7, 2, 5, 9, 6, 3, 8, 7, 2, 5, 9, 6, 3, 8, 7, 2, 5], [4, 5, 3, 5, 2, 4, 3, 4, 5, 3, 5, 2, 4, 3, 4, 5, 3, 5, 2, 4, 3], [2, 9, 8, 9, 5, 8, 9, 2, 9, 8, 9, 5, 8, 9, 2, 9, 8, 9, 5, 8, 9], [5, 4, 5, 8, 2, 3, 2, 5, 4, 5, 8, 2, 3, 2, 5, 4, 5, 8, 2, 3, 2], [4, 9, 6, 5, 3, 8, 7, 4, 9, 6, 5, 3, 8, 7, 4, 9, 6, 5, 3, 8, 7], [3, 7, 3, 4, 8, 9, 6, 3, 7, 3, 4, 8, 9, 6, 3, 7, 3, 4, 8, 9, 6], [4, 8, 4, 9, 5, 4, 3, 4, 8, 4, 9, 5, 4, 3, 4, 8, 4, 9, 5, 4, 3], [5, 6, 3, 8, 7, 2, 9, 5, 6, 3, 8, 7, 2, 9, 5, 6, 3, 8, 7, 2, 9]]}]}"
VPxKXz7FA2BkA6ozDgzgKk,2025-07-21T15:52:22.766658,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 8, 3, 7, 5, 7, 6], [8, 9, 2, 8, 4, 9, 5], [3, 5, 3, 6, 3, 4, 9], [6, 7, 5, 8, 4, 7, 4], [3, 5, 8, 5, 3, 5, 3], [7, 6, 2, 9, 6, 3, 6], [5, 7, 9, 2, 4, 7, 5]], ""output"": [[9, 8, 3, 7, 5, 7, 6, 9, 8, 3, 7, 5, 7, 6, 9, 8, 3, 7, 5, 7, 6], [8, 9, 2, 8, 4, 9, 5, 8, 9, 2, 8, 4, 9, 5, 8, 9, 2, 8, 4, 9, 5], [3, 5, 3, 6, 3, 4, 9, 3, 5, 3, 6, 3, 4, 9, 3, 5, 3, 6, 3, 4, 9], [6, 7, 5, 8, 4, 7, 4, 6, 7, 5, 8, 4, 7, 4, 6, 7, 5, 8, 4, 7, 4], [3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3], [7, 6, 2, 9, 6, 3, 6, 7, 6, 2, 9, 6, 3, 6, 7, 6, 2, 9, 6, 3, 6], [5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5], [6, 8, 3, 7, 5, 7, 9, 6, 8, 3, 7, 5, 7, 9, 6, 8, 3, 7, 5, 7, 9], [5, 9, 2, 8, 4, 9, 8, 5, 9, 2, 8, 4, 9, 8, 5, 9, 2, 8, 4, 9, 8], [9, 5, 3, 6, 3, 4, 3, 9, 5, 3, 6, 3, 4, 3, 9, 5, 3, 6, 3, 4, 3], [4, 7, 5, 8, 4, 7, 6, 4, 7, 5, 8, 4, 7, 6, 4, 7, 5, 8, 4, 7, 6], [3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3], [6, 6, 2, 9, 6, 3, 7, 6, 6, 2, 9, 6, 3, 7, 6, 6, 2, 9, 6, 3, 7], [5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5], [9, 8, 3, 7, 5, 7, 6, 9, 8, 3, 7, 5, 7, 6, 9, 8, 3, 7, 5, 7, 6], [8, 9, 2, 8, 4, 9, 5, 8, 9, 2, 8, 4, 9, 5, 8, 9, 2, 8, 4, 9, 5], [3, 5, 3, 6, 3, 4, 9, 3, 5, 3, 6, 3, 4, 9, 3, 5, 3, 6, 3, 4, 9], [6, 7, 5, 8, 4, 7, 4, 6, 7, 5, 8, 4, 7, 4, 6, 7, 5, 8, 4, 7, 4], [3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3, 3, 5, 8, 5, 3, 5, 3], [7, 6, 2, 9, 6, 3, 6, 7, 6, 2, 9, 6, 3, 6, 7, 6, 2, 9, 6, 3, 6], [5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5, 5, 7, 9, 2, 4, 7, 5]]}, {""input"": [[6, 3, 5, 9, 7, 2, 4], [7, 6, 7, 5, 3, 8, 7], [4, 2, 8, 9, 2, 5, 3], [2, 9, 5, 8, 6, 7, 4], [4, 2, 8, 5, 9, 4, 2], [5, 3, 5, 8, 6, 2, 7], [4, 6, 3, 5, 7, 5, 3]], ""output"": [[6, 3, 5, 9, 7, 2, 4, 6, 3, 5, 9, 7, 2, 4, 6, 3, 5, 9, 7, 2, 4], [7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7], [4, 2, 8, 9, 2, 5, 3, 4, 2, 8, 9, 2, 5, 3, 4, 2, 8, 9, 2, 5, 3], [2, 9, 5, 8, 6, 7, 4, 2, 9, 5, 8, 6, 7, 4, 2, 9, 5, 8, 6, 7, 4], [4, 2, 8, 5, 9, 4, 2, 4, 2, 8, 5, 9, 4, 2, 4, 2, 8, 5, 9, 4, 2], [5, 3, 5, 8, 6, 2, 7, 5, 3, 5, 8, 6, 2, 7, 5, 3, 5, 8, 6, 2, 7], [4, 6, 3, 5, 7, 5, 3, 4, 6, 3, 5, 7, 5, 3, 4, 6, 3, 5, 7, 5, 3], [4, 3, 5, 9, 7, 2, 6, 4, 3, 5, 9, 7, 2, 6, 4, 3, 5, 9, 7, 2, 6], [7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7], [3, 2, 8, 9, 2, 5, 4, 3, 2, 8, 9, 2, 5, 4, 3, 2, 8, 9, 2, 5, 4], [4, 9, 5, 8, 6, 7, 2, 4, 9, 5, 8, 6, 7, 2, 4, 9, 5, 8, 6, 7, 2], [2, 2, 8, 5, 9, 4, 4, 2, 2, 8, 5, 9, 4, 4, 2, 2, 8, 5, 9, 4, 4], [7, 3, 5, 8, 6, 2, 5, 7, 3, 5, 8, 6, 2, 5, 7, 3, 5, 8, 6, 2, 5], [3, 6, 3, 5, 7, 5, 4, 3, 6, 3, 5, 7, 5, 4, 3, 6, 3, 5, 7, 5, 4], [6, 3, 5, 9, 7, 2, 4, 6, 3, 5, 9, 7, 2, 4, 6, 3, 5, 9, 7, 2, 4], [7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7, 7, 6, 7, 5, 3, 8, 7], [4, 2, 8, 9, 2, 5, 3, 4, 2, 8, 9, 2, 5, 3, 4, 2, 8, 9, 2, 5, 3], [2, 9, 5, 8, 6, 7, 4, 2, 9, 5, 8, 6, 7, 4, 2, 9, 5, 8, 6, 7, 4], [4, 2, 8, 5, 9, 4, 2, 4, 2, 8, 5, 9, 4, 2, 4, 2, 8, 5, 9, 4, 2], [5, 3, 5, 8, 6, 2, 7, 5, 3, 5, 8, 6, 2, 7, 5, 3, 5, 8, 6, 2, 7], [4, 6, 3, 5, 7, 5, 3, 4, 6, 3, 5, 7, 5, 3, 4, 6, 3, 5, 7, 5, 3]]}, {""input"": [[5, 4, 8, 7, 4, 9, 6], [9, 5, 9, 6, 7, 8, 9], [2, 6, 7, 4, 6, 4, 8], [3, 5, 2, 5, 4, 8, 3], [4, 2, 9, 6, 8, 7, 9], [3, 8, 7, 8, 6, 5, 4], [5, 6, 2, 6, 5, 2, 6]], ""output"": [[5, 4, 8, 7, 4, 9, 6, 5, 4, 8, 7, 4, 9, 6, 5, 4, 8, 7, 4, 9, 6], [9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9], [2, 6, 7, 4, 6, 4, 8, 2, 6, 7, 4, 6, 4, 8, 2, 6, 7, 4, 6, 4, 8], [3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3], [4, 2, 9, 6, 8, 7, 9, 4, 2, 9, 6, 8, 7, 9, 4, 2, 9, 6, 8, 7, 9], [3, 8, 7, 8, 6, 5, 4, 3, 8, 7, 8, 6, 5, 4, 3, 8, 7, 8, 6, 5, 4], [5, 6, 2, 6, 5, 2, 6, 5, 6, 2, 6, 5, 2, 6, 5, 6, 2, 6, 5, 2, 6], [6, 4, 8, 7, 4, 9, 5, 6, 4, 8, 7, 4, 9, 5, 6, 4, 8, 7, 4, 9, 5], [9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9], [8, 6, 7, 4, 6, 4, 2, 8, 6, 7, 4, 6, 4, 2, 8, 6, 7, 4, 6, 4, 2], [3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3], [9, 2, 9, 6, 8, 7, 4, 9, 2, 9, 6, 8, 7, 4, 9, 2, 9, 6, 8, 7, 4], [4, 8, 7, 8, 6, 5, 3, 4, 8, 7, 8, 6, 5, 3, 4, 8, 7, 8, 6, 5, 3], [6, 6, 2, 6, 5, 2, 5, 6, 6, 2, 6, 5, 2, 5, 6, 6, 2, 6, 5, 2, 5], [5, 4, 8, 7, 4, 9, 6, 5, 4, 8, 7, 4, 9, 6, 5, 4, 8, 7, 4, 9, 6], [9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9, 9, 5, 9, 6, 7, 8, 9], [2, 6, 7, 4, 6, 4, 8, 2, 6, 7, 4, 6, 4, 8, 2, 6, 7, 4, 6, 4, 8], [3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3, 3, 5, 2, 5, 4, 8, 3], [4, 2, 9, 6, 8, 7, 9, 4, 2, 9, 6, 8, 7, 9, 4, 2, 9, 6, 8, 7, 9], [3, 8, 7, 8, 6, 5, 4, 3, 8, 7, 8, 6, 5, 4, 3, 8, 7, 8, 6, 5, 4], [5, 6, 2, 6, 5, 2, 6, 5, 6, 2, 6, 5, 2, 6, 5, 6, 2, 6, 5, 2, 6]]}], ""test"": [{""input"": [[5, 3, 9, 8, 4, 8, 4], [7, 8, 3, 4, 8, 5, 6], [9, 7, 6, 5, 2, 8, 9], [8, 4, 7, 2, 9, 6, 2], [9, 8, 9, 3, 5, 4, 3], [7, 4, 2, 4, 3, 6, 2], [9, 5, 7, 2, 5, 3, 6]], ""output"": [[5, 3, 9, 8, 4, 8, 4, 5, 3, 9, 8, 4, 8, 4, 5, 3, 9, 8, 4, 8, 4], [7, 8, 3, 4, 8, 5, 6, 7, 8, 3, 4, 8, 5, 6, 7, 8, 3, 4, 8, 5, 6], [9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9], [8, 4, 7, 2, 9, 6, 2, 8, 4, 7, 2, 9, 6, 2, 8, 4, 7, 2, 9, 6, 2], [9, 8, 9, 3, 5, 4, 3, 9, 8, 9, 3, 5, 4, 3, 9, 8, 9, 3, 5, 4, 3], [7, 4, 2, 4, 3, 6, 2, 7, 4, 2, 4, 3, 6, 2, 7, 4, 2, 4, 3, 6, 2], [9, 5, 7, 2, 5, 3, 6, 9, 5, 7, 2, 5, 3, 6, 9, 5, 7, 2, 5, 3, 6], [4, 3, 9, 8, 4, 8, 5, 4, 3, 9, 8, 4, 8, 5, 4, 3, 9, 8, 4, 8, 5], [6, 8, 3, 4, 8, 5, 7, 6, 8, 3, 4, 8, 5, 7, 6, 8, 3, 4, 8, 5, 7], [9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9], [2, 4, 7, 2, 9, 6, 8, 2, 4, 7, 2, 9, 6, 8, 2, 4, 7, 2, 9, 6, 8], [3, 8, 9, 3, 5, 4, 9, 3, 8, 9, 3, 5, 4, 9, 3, 8, 9, 3, 5, 4, 9], [2, 4, 2, 4, 3, 6, 7, 2, 4, 2, 4, 3, 6, 7, 2, 4, 2, 4, 3, 6, 7], [6, 5, 7, 2, 5, 3, 9, 6, 5, 7, 2, 5, 3, 9, 6, 5, 7, 2, 5, 3, 9], [5, 3, 9, 8, 4, 8, 4, 5, 3, 9, 8, 4, 8, 4, 5, 3, 9, 8, 4, 8, 4], [7, 8, 3, 4, 8, 5, 6, 7, 8, 3, 4, 8, 5, 6, 7, 8, 3, 4, 8, 5, 6], [9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9, 9, 7, 6, 5, 2, 8, 9], [8, 4, 7, 2, 9, 6, 2, 8, 4, 7, 2, 9, 6, 2, 8, 4, 7, 2, 9, 6, 2], [9, 8, 9, 3, 5, 4, 3, 9, 8, 9, 3, 5, 4, 3, 9, 8, 9, 3, 5, 4, 3], [7, 4, 2, 4, 3, 6, 2, 7, 4, 2, 4, 3, 6, 2, 7, 4, 2, 4, 3, 6, 2], [9, 5, 7, 2, 5, 3, 6, 9, 5, 7, 2, 5, 3, 6, 9, 5, 7, 2, 5, 3, 6]]}]}"
AhVyGNu2djVtadpGJtk529,2025-07-21T15:52:22.769803,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 4, 5, 2], [7, 9, 3, 4], [6, 8, 5, 9], [5, 4, 9, 8]], ""output"": [[3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2], [7, 9, 3, 4, 7, 9, 3, 4, 7, 9, 3, 4], [6, 8, 5, 9, 6, 8, 5, 9, 6, 8, 5, 9], [5, 4, 9, 8, 5, 4, 9, 8, 5, 4, 9, 8], [2, 4, 5, 3, 2, 4, 5, 3, 2, 4, 5, 3], [4, 9, 3, 7, 4, 9, 3, 7, 4, 9, 3, 7], [9, 8, 5, 6, 9, 8, 5, 6, 9, 8, 5, 6], [8, 4, 9, 5, 8, 4, 9, 5, 8, 4, 9, 5], [3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2], [7, 9, 3, 4, 7, 9, 3, 4, 7, 9, 3, 4], [6, 8, 5, 9, 6, 8, 5, 9, 6, 8, 5, 9], [5, 4, 9, 8, 5, 4, 9, 8, 5, 4, 9, 8]]}, {""input"": [[2, 3, 9, 4], [9, 2, 7, 6], [2, 5, 8, 7], [8, 7, 3, 6]], ""output"": [[2, 3, 9, 4, 2, 3, 9, 4, 2, 3, 9, 4], [9, 2, 7, 6, 9, 2, 7, 6, 9, 2, 7, 6], [2, 5, 8, 7, 2, 5, 8, 7, 2, 5, 8, 7], [8, 7, 3, 6, 8, 7, 3, 6, 8, 7, 3, 6], [4, 3, 9, 2, 4, 3, 9, 2, 4, 3, 9, 2], [6, 2, 7, 9, 6, 2, 7, 9, 6, 2, 7, 9], [7, 5, 8, 2, 7, 5, 8, 2, 7, 5, 8, 2], [6, 7, 3, 8, 6, 7, 3, 8, 6, 7, 3, 8], [2, 3, 9, 4, 2, 3, 9, 4, 2, 3, 9, 4], [9, 2, 7, 6, 9, 2, 7, 6, 9, 2, 7, 6], [2, 5, 8, 7, 2, 5, 8, 7, 2, 5, 8, 7], [8, 7, 3, 6, 8, 7, 3, 6, 8, 7, 3, 6]]}, {""input"": [[5, 6, 9, 4], [2, 3, 7, 8], [7, 9, 5, 2], [6, 4, 8, 1]], ""output"": [[5, 6, 9, 4, 5, 6, 9, 4, 5, 6, 9, 4], [2, 3, 7, 8, 2, 3, 7, 8, 2, 3, 7, 8], [7, 9, 5, 2, 7, 9, 5, 2, 7, 9, 5, 2], [6, 4, 8, 1, 6, 4, 8, 1, 6, 4, 8, 1], [4, 6, 9, 5, 4, 6, 9, 5, 4, 6, 9, 5], [8, 3, 7, 2, 8, 3, 7, 2, 8, 3, 7, 2], [2, 9, 5, 7, 2, 9, 5, 7, 2, 9, 5, 7], [1, 4, 8, 6, 1, 4, 8, 6, 1, 4, 8, 6], [5, 6, 9, 4, 5, 6, 9, 4, 5, 6, 9, 4], [2, 3, 7, 8, 2, 3, 7, 8, 2, 3, 7, 8], [7, 9, 5, 2, 7, 9, 5, 2, 7, 9, 5, 2], [6, 4, 8, 1, 6, 4, 8, 1, 6, 4, 8, 1]]}], ""test"": [{""input"": [[2, 5, 3, 4], [7, 6, 5, 7], [2, 9, 6, 3], [9, 8, 2, 1]], ""output"": [[2, 5, 3, 4, 2, 5, 3, 4, 2, 5, 3, 4], [7, 6, 5, 7, 7, 6, 5, 7, 7, 6, 5, 7], [2, 9, 6, 3, 2, 9, 6, 3, 2, 9, 6, 3], [9, 8, 2, 1, 9, 8, 2, 1, 9, 8, 2, 1], [4, 5, 3, 2, 4, 5, 3, 2, 4, 5, 3, 2], [7, 6, 5, 7, 7, 6, 5, 7, 7, 6, 5, 7], [3, 9, 6, 2, 3, 9, 6, 2, 3, 9, 6, 2], [1, 8, 2, 9, 1, 8, 2, 9, 1, 8, 2, 9], [2, 5, 3, 4, 2, 5, 3, 4, 2, 5, 3, 4], [7, 6, 5, 7, 7, 6, 5, 7, 7, 6, 5, 7], [2, 9, 6, 3, 2, 9, 6, 3, 2, 9, 6, 3], [9, 8, 2, 1, 9, 8, 2, 1, 9, 8, 2, 1]]}]}"
EmUvnEhgKRdiYN7N6oXBuK,2025-07-21T15:52:22.772757,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 9, 7, 9, 8, 5], [7, 8, 2, 5, 6, 4], [2, 7, 3, 2, 7, 6], [9, 3, 2, 4, 9, 7], [3, 7, 8, 6, 7, 3], [4, 5, 7, 5, 2, 4]], ""output"": [[2, 9, 7, 9, 8, 5, 2, 9, 7, 9, 8, 5, 2, 9, 7, 9, 8, 5], [7, 8, 2, 5, 6, 4, 7, 8, 2, 5, 6, 4, 7, 8, 2, 5, 6, 4], [2, 7, 3, 2, 7, 6, 2, 7, 3, 2, 7, 6, 2, 7, 3, 2, 7, 6], [9, 3, 2, 4, 9, 7, 9, 3, 2, 4, 9, 7, 9, 3, 2, 4, 9, 7], [3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3], [4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4], [5, 9, 7, 9, 8, 2, 5, 9, 7, 9, 8, 2, 5, 9, 7, 9, 8, 2], [4, 8, 2, 5, 6, 7, 4, 8, 2, 5, 6, 7, 4, 8, 2, 5, 6, 7], [6, 7, 3, 2, 7, 2, 6, 7, 3, 2, 7, 2, 6, 7, 3, 2, 7, 2], [7, 3, 2, 4, 9, 9, 7, 3, 2, 4, 9, 9, 7, 3, 2, 4, 9, 9], [3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3], [4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4], [2, 9, 7, 9, 8, 5, 2, 9, 7, 9, 8, 5, 2, 9, 7, 9, 8, 5], [7, 8, 2, 5, 6, 4, 7, 8, 2, 5, 6, 4, 7, 8, 2, 5, 6, 4], [2, 7, 3, 2, 7, 6, 2, 7, 3, 2, 7, 6, 2, 7, 3, 2, 7, 6], [9, 3, 2, 4, 9, 7, 9, 3, 2, 4, 9, 7, 9, 3, 2, 4, 9, 7], [3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3, 3, 7, 8, 6, 7, 3], [4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4, 4, 5, 7, 5, 2, 4]]}, {""input"": [[7, 6, 5, 3, 6, 7], [6, 5, 4, 5, 7, 9], [9, 2, 9, 2, 6, 3], [4, 3, 5, 8, 9, 5], [8, 7, 9, 4, 7, 6], [5, 3, 2, 6, 3, 5]], ""output"": [[7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7], [6, 5, 4, 5, 7, 9, 6, 5, 4, 5, 7, 9, 6, 5, 4, 5, 7, 9], [9, 2, 9, 2, 6, 3, 9, 2, 9, 2, 6, 3, 9, 2, 9, 2, 6, 3], [4, 3, 5, 8, 9, 5, 4, 3, 5, 8, 9, 5, 4, 3, 5, 8, 9, 5], [8, 7, 9, 4, 7, 6, 8, 7, 9, 4, 7, 6, 8, 7, 9, 4, 7, 6], [5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5], [7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7], [9, 5, 4, 5, 7, 6, 9, 5, 4, 5, 7, 6, 9, 5, 4, 5, 7, 6], [3, 2, 9, 2, 6, 9, 3, 2, 9, 2, 6, 9, 3, 2, 9, 2, 6, 9], [5, 3, 5, 8, 9, 4, 5, 3, 5, 8, 9, 4, 5, 3, 5, 8, 9, 4], [6, 7, 9, 4, 7, 8, 6, 7, 9, 4, 7, 8, 6, 7, 9, 4, 7, 8], [5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5], [7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7, 7, 6, 5, 3, 6, 7], [6, 5, 4, 5, 7, 9, 6, 5, 4, 5, 7, 9, 6, 5, 4, 5, 7, 9], [9, 2, 9, 2, 6, 3, 9, 2, 9, 2, 6, 3, 9, 2, 9, 2, 6, 3], [4, 3, 5, 8, 9, 5, 4, 3, 5, 8, 9, 5, 4, 3, 5, 8, 9, 5], [8, 7, 9, 4, 7, 6, 8, 7, 9, 4, 7, 6, 8, 7, 9, 4, 7, 6], [5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5, 5, 3, 2, 6, 3, 5]]}, {""input"": [[2, 9, 5, 3, 5, 7], [5, 4, 8, 6, 7, 5], [4, 6, 9, 8, 5, 8], [2, 3, 2, 5, 8, 9], [5, 9, 8, 3, 4, 3], [3, 5, 6, 8, 2, 1]], ""output"": [[2, 9, 5, 3, 5, 7, 2, 9, 5, 3, 5, 7, 2, 9, 5, 3, 5, 7], [5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5], [4, 6, 9, 8, 5, 8, 4, 6, 9, 8, 5, 8, 4, 6, 9, 8, 5, 8], [2, 3, 2, 5, 8, 9, 2, 3, 2, 5, 8, 9, 2, 3, 2, 5, 8, 9], [5, 9, 8, 3, 4, 3, 5, 9, 8, 3, 4, 3, 5, 9, 8, 3, 4, 3], [3, 5, 6, 8, 2, 1, 3, 5, 6, 8, 2, 1, 3, 5, 6, 8, 2, 1], [7, 9, 5, 3, 5, 2, 7, 9, 5, 3, 5, 2, 7, 9, 5, 3, 5, 2], [5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5], [8, 6, 9, 8, 5, 4, 8, 6, 9, 8, 5, 4, 8, 6, 9, 8, 5, 4], [9, 3, 2, 5, 8, 2, 9, 3, 2, 5, 8, 2, 9, 3, 2, 5, 8, 2], [3, 9, 8, 3, 4, 5, 3, 9, 8, 3, 4, 5, 3, 9, 8, 3, 4, 5], [1, 5, 6, 8, 2, 3, 1, 5, 6, 8, 2, 3, 1, 5, 6, 8, 2, 3], [2, 9, 5, 3, 5, 7, 2, 9, 5, 3, 5, 7, 2, 9, 5, 3, 5, 7], [5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5, 5, 4, 8, 6, 7, 5], [4, 6, 9, 8, 5, 8, 4, 6, 9, 8, 5, 8, 4, 6, 9, 8, 5, 8], [2, 3, 2, 5, 8, 9, 2, 3, 2, 5, 8, 9, 2, 3, 2, 5, 8, 9], [5, 9, 8, 3, 4, 3, 5, 9, 8, 3, 4, 3, 5, 9, 8, 3, 4, 3], [3, 5, 6, 8, 2, 1, 3, 5, 6, 8, 2, 1, 3, 5, 6, 8, 2, 1]]}], ""test"": [{""input"": [[2, 4, 7, 6, 9, 6], [9, 7, 5, 9, 7, 5], [7, 9, 8, 7, 4, 8], [2, 8, 2, 5, 3, 6], [6, 9, 6, 2, 8, 9], [9, 2, 7, 9, 3, 5]], ""output"": [[2, 4, 7, 6, 9, 6, 2, 4, 7, 6, 9, 6, 2, 4, 7, 6, 9, 6], [9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5], [7, 9, 8, 7, 4, 8, 7, 9, 8, 7, 4, 8, 7, 9, 8, 7, 4, 8], [2, 8, 2, 5, 3, 6, 2, 8, 2, 5, 3, 6, 2, 8, 2, 5, 3, 6], [6, 9, 6, 2, 8, 9, 6, 9, 6, 2, 8, 9, 6, 9, 6, 2, 8, 9], [9, 2, 7, 9, 3, 5, 9, 2, 7, 9, 3, 5, 9, 2, 7, 9, 3, 5], [6, 4, 7, 6, 9, 2, 6, 4, 7, 6, 9, 2, 6, 4, 7, 6, 9, 2], [5, 7, 5, 9, 7, 9, 5, 7, 5, 9, 7, 9, 5, 7, 5, 9, 7, 9], [8, 9, 8, 7, 4, 7, 8, 9, 8, 7, 4, 7, 8, 9, 8, 7, 4, 7], [6, 8, 2, 5, 3, 2, 6, 8, 2, 5, 3, 2, 6, 8, 2, 5, 3, 2], [9, 9, 6, 2, 8, 6, 9, 9, 6, 2, 8, 6, 9, 9, 6, 2, 8, 6], [5, 2, 7, 9, 3, 9, 5, 2, 7, 9, 3, 9, 5, 2, 7, 9, 3, 9], [2, 4, 7, 6, 9, 6, 2, 4, 7, 6, 9, 6, 2, 4, 7, 6, 9, 6], [9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5, 9, 7, 5], [7, 9, 8, 7, 4, 8, 7, 9, 8, 7, 4, 8, 7, 9, 8, 7, 4, 8], [2, 8, 2, 5, 3, 6, 2, 8, 2, 5, 3, 6, 2, 8, 2, 5, 3, 6], [6, 9, 6, 2, 8, 9, 6, 9, 6, 2, 8, 9, 6, 9, 6, 2, 8, 9], [9, 2, 7, 9, 3, 5, 9, 2, 7, 9, 3, 5, 9, 2, 7, 9, 3, 5]]}]}"
htWdg6sU5zEMsuM9d68d7B,2025-07-21T15:52:22.775951,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 4, 8, 7, 3, 2], [7, 9, 2, 9, 2, 4], [6, 5, 8, 2, 9, 2], [5, 3, 4, 5, 6, 3], [9, 7, 5, 6, 8, 9], [3, 4, 7, 3, 2, 5]], ""output"": [[9, 4, 8, 7, 3, 2, 9, 4, 8, 7, 3, 2, 9, 4, 8, 7, 3, 2], [7, 9, 2, 9, 2, 4, 7, 9, 2, 9, 2, 4, 7, 9, 2, 9, 2, 4], [6, 5, 8, 2, 9, 2, 6, 5, 8, 2, 9, 2, 6, 5, 8, 2, 9, 2], [5, 3, 4, 5, 6, 3, 5, 3, 4, 5, 6, 3, 5, 3, 4, 5, 6, 3], [9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9], [3, 4, 7, 3, 2, 5, 3, 4, 7, 3, 2, 5, 3, 4, 7, 3, 2, 5], [2, 4, 8, 7, 3, 9, 2, 4, 8, 7, 3, 9, 2, 4, 8, 7, 3, 9], [4, 9, 2, 9, 2, 7, 4, 9, 2, 9, 2, 7, 4, 9, 2, 9, 2, 7], [2, 5, 8, 2, 9, 6, 2, 5, 8, 2, 9, 6, 2, 5, 8, 2, 9, 6], [3, 3, 4, 5, 6, 5, 3, 3, 4, 5, 6, 5, 3, 3, 4, 5, 6, 5], [9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9], [5, 4, 7, 3, 2, 3, 5, 4, 7, 3, 2, 3, 5, 4, 7, 3, 2, 3], [9, 4, 8, 7, 3, 2, 9, 4, 8, 7, 3, 2, 9, 4, 8, 7, 3, 2], [7, 9, 2, 9, 2, 4, 7, 9, 2, 9, 2, 4, 7, 9, 2, 9, 2, 4], [6, 5, 8, 2, 9, 2, 6, 5, 8, 2, 9, 2, 6, 5, 8, 2, 9, 2], [5, 3, 4, 5, 6, 3, 5, 3, 4, 5, 6, 3, 5, 3, 4, 5, 6, 3], [9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9, 9, 7, 5, 6, 8, 9], [3, 4, 7, 3, 2, 5, 3, 4, 7, 3, 2, 5, 3, 4, 7, 3, 2, 5]]}, {""input"": [[9, 5, 2, 8, 2, 7], [6, 3, 5, 9, 4, 2], [3, 6, 3, 5, 8, 9], [5, 8, 2, 7, 3, 8], [7, 9, 6, 4, 9, 6], [3, 2, 4, 5, 8, 2]], ""output"": [[9, 5, 2, 8, 2, 7, 9, 5, 2, 8, 2, 7, 9, 5, 2, 8, 2, 7], [6, 3, 5, 9, 4, 2, 6, 3, 5, 9, 4, 2, 6, 3, 5, 9, 4, 2], [3, 6, 3, 5, 8, 9, 3, 6, 3, 5, 8, 9, 3, 6, 3, 5, 8, 9], [5, 8, 2, 7, 3, 8, 5, 8, 2, 7, 3, 8, 5, 8, 2, 7, 3, 8], [7, 9, 6, 4, 9, 6, 7, 9, 6, 4, 9, 6, 7, 9, 6, 4, 9, 6], [3, 2, 4, 5, 8, 2, 3, 2, 4, 5, 8, 2, 3, 2, 4, 5, 8, 2], [7, 5, 2, 8, 2, 9, 7, 5, 2, 8, 2, 9, 7, 5, 2, 8, 2, 9], [2, 3, 5, 9, 4, 6, 2, 3, 5, 9, 4, 6, 2, 3, 5, 9, 4, 6], [9, 6, 3, 5, 8, 3, 9, 6, 3, 5, 8, 3, 9, 6, 3, 5, 8, 3], [8, 8, 2, 7, 3, 5, 8, 8, 2, 7, 3, 5, 8, 8, 2, 7, 3, 5], [6, 9, 6, 4, 9, 7, 6, 9, 6, 4, 9, 7, 6, 9, 6, 4, 9, 7], [2, 2, 4, 5, 8, 3, 2, 2, 4, 5, 8, 3, 2, 2, 4, 5, 8, 3], [9, 5, 2, 8, 2, 7, 9, 5, 2, 8, 2, 7, 9, 5, 2, 8, 2, 7], [6, 3, 5, 9, 4, 2, 6, 3, 5, 9, 4, 2, 6, 3, 5, 9, 4, 2], [3, 6, 3, 5, 8, 9, 3, 6, 3, 5, 8, 9, 3, 6, 3, 5, 8, 9], [5, 8, 2, 7, 3, 8, 5, 8, 2, 7, 3, 8, 5, 8, 2, 7, 3, 8], [7, 9, 6, 4, 9, 6, 7, 9, 6, 4, 9, 6, 7, 9, 6, 4, 9, 6], [3, 2, 4, 5, 8, 2, 3, 2, 4, 5, 8, 2, 3, 2, 4, 5, 8, 2]]}, {""input"": [[9, 3, 9, 6, 4, 3], [2, 4, 7, 9, 2, 6], [4, 6, 3, 8, 6, 4], [3, 5, 7, 3, 7, 2], [5, 7, 6, 8, 3, 8], [2, 3, 2, 9, 6, 1]], ""output"": [[9, 3, 9, 6, 4, 3, 9, 3, 9, 6, 4, 3, 9, 3, 9, 6, 4, 3], [2, 4, 7, 9, 2, 6, 2, 4, 7, 9, 2, 6, 2, 4, 7, 9, 2, 6], [4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4], [3, 5, 7, 3, 7, 2, 3, 5, 7, 3, 7, 2, 3, 5, 7, 3, 7, 2], [5, 7, 6, 8, 3, 8, 5, 7, 6, 8, 3, 8, 5, 7, 6, 8, 3, 8], [2, 3, 2, 9, 6, 1, 2, 3, 2, 9, 6, 1, 2, 3, 2, 9, 6, 1], [3, 3, 9, 6, 4, 9, 3, 3, 9, 6, 4, 9, 3, 3, 9, 6, 4, 9], [6, 4, 7, 9, 2, 2, 6, 4, 7, 9, 2, 2, 6, 4, 7, 9, 2, 2], [4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4], [2, 5, 7, 3, 7, 3, 2, 5, 7, 3, 7, 3, 2, 5, 7, 3, 7, 3], [8, 7, 6, 8, 3, 5, 8, 7, 6, 8, 3, 5, 8, 7, 6, 8, 3, 5], [1, 3, 2, 9, 6, 2, 1, 3, 2, 9, 6, 2, 1, 3, 2, 9, 6, 2], [9, 3, 9, 6, 4, 3, 9, 3, 9, 6, 4, 3, 9, 3, 9, 6, 4, 3], [2, 4, 7, 9, 2, 6, 2, 4, 7, 9, 2, 6, 2, 4, 7, 9, 2, 6], [4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4, 4, 6, 3, 8, 6, 4], [3, 5, 7, 3, 7, 2, 3, 5, 7, 3, 7, 2, 3, 5, 7, 3, 7, 2], [5, 7, 6, 8, 3, 8, 5, 7, 6, 8, 3, 8, 5, 7, 6, 8, 3, 8], [2, 3, 2, 9, 6, 1, 2, 3, 2, 9, 6, 1, 2, 3, 2, 9, 6, 1]]}], ""test"": [{""input"": [[4, 2, 3, 2, 5, 3], [8, 9, 8, 7, 8, 7], [3, 5, 6, 3, 7, 2], [7, 2, 8, 5, 9, 5], [3, 4, 7, 8, 7, 2], [2, 7, 3, 7, 6, 9]], ""output"": [[4, 2, 3, 2, 5, 3, 4, 2, 3, 2, 5, 3, 4, 2, 3, 2, 5, 3], [8, 9, 8, 7, 8, 7, 8, 9, 8, 7, 8, 7, 8, 9, 8, 7, 8, 7], [3, 5, 6, 3, 7, 2, 3, 5, 6, 3, 7, 2, 3, 5, 6, 3, 7, 2], [7, 2, 8, 5, 9, 5, 7, 2, 8, 5, 9, 5, 7, 2, 8, 5, 9, 5], [3, 4, 7, 8, 7, 2, 3, 4, 7, 8, 7, 2, 3, 4, 7, 8, 7, 2], [2, 7, 3, 7, 6, 9, 2, 7, 3, 7, 6, 9, 2, 7, 3, 7, 6, 9], [3, 2, 3, 2, 5, 4, 3, 2, 3, 2, 5, 4, 3, 2, 3, 2, 5, 4], [7, 9, 8, 7, 8, 8, 7, 9, 8, 7, 8, 8, 7, 9, 8, 7, 8, 8], [2, 5, 6, 3, 7, 3, 2, 5, 6, 3, 7, 3, 2, 5, 6, 3, 7, 3], [5, 2, 8, 5, 9, 7, 5, 2, 8, 5, 9, 7, 5, 2, 8, 5, 9, 7], [2, 4, 7, 8, 7, 3, 2, 4, 7, 8, 7, 3, 2, 4, 7, 8, 7, 3], [9, 7, 3, 7, 6, 2, 9, 7, 3, 7, 6, 2, 9, 7, 3, 7, 6, 2], [4, 2, 3, 2, 5, 3, 4, 2, 3, 2, 5, 3, 4, 2, 3, 2, 5, 3], [8, 9, 8, 7, 8, 7, 8, 9, 8, 7, 8, 7, 8, 9, 8, 7, 8, 7], [3, 5, 6, 3, 7, 2, 3, 5, 6, 3, 7, 2, 3, 5, 6, 3, 7, 2], [7, 2, 8, 5, 9, 5, 7, 2, 8, 5, 9, 5, 7, 2, 8, 5, 9, 5], [3, 4, 7, 8, 7, 2, 3, 4, 7, 8, 7, 2, 3, 4, 7, 8, 7, 2], [2, 7, 3, 7, 6, 9, 2, 7, 3, 7, 6, 9, 2, 7, 3, 7, 6, 9]]}]}"
7KBaG7k9E4MqmRcnmL6EoU,2025-07-21T15:52:22.778247,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 3], [9, 2]], ""output"": [[4, 3, 4, 3, 4, 3], [9, 2, 9, 2, 9, 2], [3, 4, 3, 4, 3, 4], [2, 9, 2, 9, 2, 9], [4, 3, 4, 3, 4, 3], [9, 2, 9, 2, 9, 2]]}, {""input"": [[4, 5], [5, 7]], ""output"": [[4, 5, 4, 5, 4, 5], [5, 7, 5, 7, 5, 7], [5, 4, 5, 4, 5, 4], [7, 5, 7, 5, 7, 5], [4, 5, 4, 5, 4, 5], [5, 7, 5, 7, 5, 7]]}, {""input"": [[2, 5], [7, 4]], ""output"": [[2, 5, 2, 5, 2, 5], [7, 4, 7, 4, 7, 4], [5, 2, 5, 2, 5, 2], [4, 7, 4, 7, 4, 7], [2, 5, 2, 5, 2, 5], [7, 4, 7, 4, 7, 4]]}], ""test"": [{""input"": [[5, 7], [3, 9]], ""output"": [[5, 7, 5, 7, 5, 7], [3, 9, 3, 9, 3, 9], [7, 5, 7, 5, 7, 5], [9, 3, 9, 3, 9, 3], [5, 7, 5, 7, 5, 7], [3, 9, 3, 9, 3, 9]]}]}"
QyJMxFCgHN2LNS7CbZfriw,2025-07-21T15:52:22.780019,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 6], [4, 3]], ""output"": [[9, 6, 9, 6, 9, 6], [4, 3, 4, 3, 4, 3], [6, 9, 6, 9, 6, 9], [3, 4, 3, 4, 3, 4], [9, 6, 9, 6, 9, 6], [4, 3, 4, 3, 4, 3]]}, {""input"": [[7, 3], [2, 6]], ""output"": [[7, 3, 7, 3, 7, 3], [2, 6, 2, 6, 2, 6], [3, 7, 3, 7, 3, 7], [6, 2, 6, 2, 6, 2], [7, 3, 7, 3, 7, 3], [2, 6, 2, 6, 2, 6]]}, {""input"": [[4, 2], [8, 4]], ""output"": [[4, 2, 4, 2, 4, 2], [8, 4, 8, 4, 8, 4], [2, 4, 2, 4, 2, 4], [4, 8, 4, 8, 4, 8], [4, 2, 4, 2, 4, 2], [8, 4, 8, 4, 8, 4]]}], ""test"": [{""input"": [[7, 4], [8, 3]], ""output"": [[7, 4, 7, 4, 7, 4], [8, 3, 8, 3, 8, 3], [4, 7, 4, 7, 4, 7], [3, 8, 3, 8, 3, 8], [7, 4, 7, 4, 7, 4], [8, 3, 8, 3, 8, 3]]}]}"
3NwDCPdn4QhDmWSBc77cHT,2025-07-21T15:52:22.781936,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 6], [2, 9]], ""output"": [[3, 6, 3, 6, 3, 6], [2, 9, 2, 9, 2, 9], [6, 3, 6, 3, 6, 3], [9, 2, 9, 2, 9, 2], [3, 6, 3, 6, 3, 6], [2, 9, 2, 9, 2, 9]]}, {""input"": [[8, 4], [3, 9]], ""output"": [[8, 4, 8, 4, 8, 4], [3, 9, 3, 9, 3, 9], [4, 8, 4, 8, 4, 8], [9, 3, 9, 3, 9, 3], [8, 4, 8, 4, 8, 4], [3, 9, 3, 9, 3, 9]]}, {""input"": [[6, 2], [9, 5]], ""output"": [[6, 2, 6, 2, 6, 2], [9, 5, 9, 5, 9, 5], [2, 6, 2, 6, 2, 6], [5, 9, 5, 9, 5, 9], [6, 2, 6, 2, 6, 2], [9, 5, 9, 5, 9, 5]]}], ""test"": [{""input"": [[3, 4], [2, 6]], ""output"": [[3, 4, 3, 4, 3, 4], [2, 6, 2, 6, 2, 6], [4, 3, 4, 3, 4, 3], [6, 2, 6, 2, 6, 2], [3, 4, 3, 4, 3, 4], [2, 6, 2, 6, 2, 6]]}]}"
LYoD4HvLrBzmnHTkPK5cga,2025-07-21T15:52:22.784884,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 7, 4, 9, 5, 4], [5, 3, 2, 6, 7, 5], [3, 7, 9, 2, 5, 6], [5, 6, 2, 9, 3, 7], [3, 4, 6, 3, 5, 8], [4, 3, 9, 7, 6, 4]], ""output"": [[8, 7, 4, 9, 5, 4, 8, 7, 4, 9, 5, 4, 8, 7, 4, 9, 5, 4], [5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5], [3, 7, 9, 2, 5, 6, 3, 7, 9, 2, 5, 6, 3, 7, 9, 2, 5, 6], [5, 6, 2, 9, 3, 7, 5, 6, 2, 9, 3, 7, 5, 6, 2, 9, 3, 7], [3, 4, 6, 3, 5, 8, 3, 4, 6, 3, 5, 8, 3, 4, 6, 3, 5, 8], [4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4], [4, 7, 4, 9, 5, 8, 4, 7, 4, 9, 5, 8, 4, 7, 4, 9, 5, 8], [5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5], [6, 7, 9, 2, 5, 3, 6, 7, 9, 2, 5, 3, 6, 7, 9, 2, 5, 3], [7, 6, 2, 9, 3, 5, 7, 6, 2, 9, 3, 5, 7, 6, 2, 9, 3, 5], [8, 4, 6, 3, 5, 3, 8, 4, 6, 3, 5, 3, 8, 4, 6, 3, 5, 3], [4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4], [8, 7, 4, 9, 5, 4, 8, 7, 4, 9, 5, 4, 8, 7, 4, 9, 5, 4], [5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5, 5, 3, 2, 6, 7, 5], [3, 7, 9, 2, 5, 6, 3, 7, 9, 2, 5, 6, 3, 7, 9, 2, 5, 6], [5, 6, 2, 9, 3, 7, 5, 6, 2, 9, 3, 7, 5, 6, 2, 9, 3, 7], [3, 4, 6, 3, 5, 8, 3, 4, 6, 3, 5, 8, 3, 4, 6, 3, 5, 8], [4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4, 4, 3, 9, 7, 6, 4]]}, {""input"": [[5, 7, 2, 9, 3, 5], [2, 8, 5, 7, 4, 7], [4, 2, 4, 9, 7, 6], [5, 9, 7, 8, 5, 7], [8, 7, 2, 9, 2, 4], [2, 5, 7, 8, 7, 8]], ""output"": [[5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5], [2, 8, 5, 7, 4, 7, 2, 8, 5, 7, 4, 7, 2, 8, 5, 7, 4, 7], [4, 2, 4, 9, 7, 6, 4, 2, 4, 9, 7, 6, 4, 2, 4, 9, 7, 6], [5, 9, 7, 8, 5, 7, 5, 9, 7, 8, 5, 7, 5, 9, 7, 8, 5, 7], [8, 7, 2, 9, 2, 4, 8, 7, 2, 9, 2, 4, 8, 7, 2, 9, 2, 4], [2, 5, 7, 8, 7, 8, 2, 5, 7, 8, 7, 8, 2, 5, 7, 8, 7, 8], [5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5], [7, 8, 5, 7, 4, 2, 7, 8, 5, 7, 4, 2, 7, 8, 5, 7, 4, 2], [6, 2, 4, 9, 7, 4, 6, 2, 4, 9, 7, 4, 6, 2, 4, 9, 7, 4], [7, 9, 7, 8, 5, 5, 7, 9, 7, 8, 5, 5, 7, 9, 7, 8, 5, 5], [4, 7, 2, 9, 2, 8, 4, 7, 2, 9, 2, 8, 4, 7, 2, 9, 2, 8], [8, 5, 7, 8, 7, 2, 8, 5, 7, 8, 7, 2, 8, 5, 7, 8, 7, 2], [5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5, 5, 7, 2, 9, 3, 5], [2, 8, 5, 7, 4, 7, 2, 8, 5, 7, 4, 7, 2, 8, 5, 7, 4, 7], [4, 2, 4, 9, 7, 6, 4, 2, 4, 9, 7, 6, 4, 2, 4, 9, 7, 6], [5, 9, 7, 8, 5, 7, 5, 9, 7, 8, 5, 7, 5, 9, 7, 8, 5, 7], [8, 7, 2, 9, 2, 4, 8, 7, 2, 9, 2, 4, 8, 7, 2, 9, 2, 4], [2, 5, 7, 8, 7, 8, 2, 5, 7, 8, 7, 8, 2, 5, 7, 8, 7, 8]]}, {""input"": [[6, 8, 2, 8, 6, 7], [3, 4, 8, 7, 4, 9], [5, 9, 4, 5, 9, 2], [3, 7, 6, 2, 3, 6], [6, 5, 7, 9, 2, 7], [2, 4, 5, 2, 5, 9]], ""output"": [[6, 8, 2, 8, 6, 7, 6, 8, 2, 8, 6, 7, 6, 8, 2, 8, 6, 7], [3, 4, 8, 7, 4, 9, 3, 4, 8, 7, 4, 9, 3, 4, 8, 7, 4, 9], [5, 9, 4, 5, 9, 2, 5, 9, 4, 5, 9, 2, 5, 9, 4, 5, 9, 2], [3, 7, 6, 2, 3, 6, 3, 7, 6, 2, 3, 6, 3, 7, 6, 2, 3, 6], [6, 5, 7, 9, 2, 7, 6, 5, 7, 9, 2, 7, 6, 5, 7, 9, 2, 7], [2, 4, 5, 2, 5, 9, 2, 4, 5, 2, 5, 9, 2, 4, 5, 2, 5, 9], [7, 8, 2, 8, 6, 6, 7, 8, 2, 8, 6, 6, 7, 8, 2, 8, 6, 6], [9, 4, 8, 7, 4, 3, 9, 4, 8, 7, 4, 3, 9, 4, 8, 7, 4, 3], [2, 9, 4, 5, 9, 5, 2, 9, 4, 5, 9, 5, 2, 9, 4, 5, 9, 5], [6, 7, 6, 2, 3, 3, 6, 7, 6, 2, 3, 3, 6, 7, 6, 2, 3, 3], [7, 5, 7, 9, 2, 6, 7, 5, 7, 9, 2, 6, 7, 5, 7, 9, 2, 6], [9, 4, 5, 2, 5, 2, 9, 4, 5, 2, 5, 2, 9, 4, 5, 2, 5, 2], [6, 8, 2, 8, 6, 7, 6, 8, 2, 8, 6, 7, 6, 8, 2, 8, 6, 7], [3, 4, 8, 7, 4, 9, 3, 4, 8, 7, 4, 9, 3, 4, 8, 7, 4, 9], [5, 9, 4, 5, 9, 2, 5, 9, 4, 5, 9, 2, 5, 9, 4, 5, 9, 2], [3, 7, 6, 2, 3, 6, 3, 7, 6, 2, 3, 6, 3, 7, 6, 2, 3, 6], [6, 5, 7, 9, 2, 7, 6, 5, 7, 9, 2, 7, 6, 5, 7, 9, 2, 7], [2, 4, 5, 2, 5, 9, 2, 4, 5, 2, 5, 9, 2, 4, 5, 2, 5, 9]]}], ""test"": [{""input"": [[3, 8, 5, 3, 9, 7], [7, 6, 8, 4, 3, 4], [5, 7, 4, 2, 5, 9], [7, 8, 5, 9, 8, 2], [2, 7, 9, 7, 4, 9], [9, 3, 6, 8, 9, 4]], ""output"": [[3, 8, 5, 3, 9, 7, 3, 8, 5, 3, 9, 7, 3, 8, 5, 3, 9, 7], [7, 6, 8, 4, 3, 4, 7, 6, 8, 4, 3, 4, 7, 6, 8, 4, 3, 4], [5, 7, 4, 2, 5, 9, 5, 7, 4, 2, 5, 9, 5, 7, 4, 2, 5, 9], [7, 8, 5, 9, 8, 2, 7, 8, 5, 9, 8, 2, 7, 8, 5, 9, 8, 2], [2, 7, 9, 7, 4, 9, 2, 7, 9, 7, 4, 9, 2, 7, 9, 7, 4, 9], [9, 3, 6, 8, 9, 4, 9, 3, 6, 8, 9, 4, 9, 3, 6, 8, 9, 4], [7, 8, 5, 3, 9, 3, 7, 8, 5, 3, 9, 3, 7, 8, 5, 3, 9, 3], [4, 6, 8, 4, 3, 7, 4, 6, 8, 4, 3, 7, 4, 6, 8, 4, 3, 7], [9, 7, 4, 2, 5, 5, 9, 7, 4, 2, 5, 5, 9, 7, 4, 2, 5, 5], [2, 8, 5, 9, 8, 7, 2, 8, 5, 9, 8, 7, 2, 8, 5, 9, 8, 7], [9, 7, 9, 7, 4, 2, 9, 7, 9, 7, 4, 2, 9, 7, 9, 7, 4, 2], [4, 3, 6, 8, 9, 9, 4, 3, 6, 8, 9, 9, 4, 3, 6, 8, 9, 9], [3, 8, 5, 3, 9, 7, 3, 8, 5, 3, 9, 7, 3, 8, 5, 3, 9, 7], [7, 6, 8, 4, 3, 4, 7, 6, 8, 4, 3, 4, 7, 6, 8, 4, 3, 4], [5, 7, 4, 2, 5, 9, 5, 7, 4, 2, 5, 9, 5, 7, 4, 2, 5, 9], [7, 8, 5, 9, 8, 2, 7, 8, 5, 9, 8, 2, 7, 8, 5, 9, 8, 2], [2, 7, 9, 7, 4, 9, 2, 7, 9, 7, 4, 9, 2, 7, 9, 7, 4, 9], [9, 3, 6, 8, 9, 4, 9, 3, 6, 8, 9, 4, 9, 3, 6, 8, 9, 4]]}]}"
ksE9StRdCEbYkoBxZdYvz7,2025-07-21T15:52:22.788844,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 4, 2, 6, 7, 8, 7], [6, 8, 3, 5, 4, 7, 4], [8, 5, 2, 8, 7, 6, 3], [7, 3, 9, 7, 8, 4, 6], [2, 9, 4, 9, 7, 8, 9], [5, 8, 9, 5, 2, 4, 7], [9, 2, 8, 7, 4, 2, 4]], ""output"": [[5, 4, 2, 6, 7, 8, 7, 5, 4, 2, 6, 7, 8, 7, 5, 4, 2, 6, 7, 8, 7], [6, 8, 3, 5, 4, 7, 4, 6, 8, 3, 5, 4, 7, 4, 6, 8, 3, 5, 4, 7, 4], [8, 5, 2, 8, 7, 6, 3, 8, 5, 2, 8, 7, 6, 3, 8, 5, 2, 8, 7, 6, 3], [7, 3, 9, 7, 8, 4, 6, 7, 3, 9, 7, 8, 4, 6, 7, 3, 9, 7, 8, 4, 6], [2, 9, 4, 9, 7, 8, 9, 2, 9, 4, 9, 7, 8, 9, 2, 9, 4, 9, 7, 8, 9], [5, 8, 9, 5, 2, 4, 7, 5, 8, 9, 5, 2, 4, 7, 5, 8, 9, 5, 2, 4, 7], [9, 2, 8, 7, 4, 2, 4, 9, 2, 8, 7, 4, 2, 4, 9, 2, 8, 7, 4, 2, 4], [7, 4, 2, 6, 7, 8, 5, 7, 4, 2, 6, 7, 8, 5, 7, 4, 2, 6, 7, 8, 5], [4, 8, 3, 5, 4, 7, 6, 4, 8, 3, 5, 4, 7, 6, 4, 8, 3, 5, 4, 7, 6], [3, 5, 2, 8, 7, 6, 8, 3, 5, 2, 8, 7, 6, 8, 3, 5, 2, 8, 7, 6, 8], [6, 3, 9, 7, 8, 4, 7, 6, 3, 9, 7, 8, 4, 7, 6, 3, 9, 7, 8, 4, 7], [9, 9, 4, 9, 7, 8, 2, 9, 9, 4, 9, 7, 8, 2, 9, 9, 4, 9, 7, 8, 2], [7, 8, 9, 5, 2, 4, 5, 7, 8, 9, 5, 2, 4, 5, 7, 8, 9, 5, 2, 4, 5], [4, 2, 8, 7, 4, 2, 9, 4, 2, 8, 7, 4, 2, 9, 4, 2, 8, 7, 4, 2, 9], [5, 4, 2, 6, 7, 8, 7, 5, 4, 2, 6, 7, 8, 7, 5, 4, 2, 6, 7, 8, 7], [6, 8, 3, 5, 4, 7, 4, 6, 8, 3, 5, 4, 7, 4, 6, 8, 3, 5, 4, 7, 4], [8, 5, 2, 8, 7, 6, 3, 8, 5, 2, 8, 7, 6, 3, 8, 5, 2, 8, 7, 6, 3], [7, 3, 9, 7, 8, 4, 6, 7, 3, 9, 7, 8, 4, 6, 7, 3, 9, 7, 8, 4, 6], [2, 9, 4, 9, 7, 8, 9, 2, 9, 4, 9, 7, 8, 9, 2, 9, 4, 9, 7, 8, 9], [5, 8, 9, 5, 2, 4, 7, 5, 8, 9, 5, 2, 4, 7, 5, 8, 9, 5, 2, 4, 7], [9, 2, 8, 7, 4, 2, 4, 9, 2, 8, 7, 4, 2, 4, 9, 2, 8, 7, 4, 2, 4]]}, {""input"": [[3, 9, 8, 2, 4, 9, 6], [9, 2, 3, 4, 6, 5, 8], [7, 6, 8, 3, 4, 8, 2], [8, 2, 5, 8, 2, 4, 3], [9, 3, 7, 2, 7, 8, 9], [5, 8, 5, 4, 5, 2, 7], [6, 3, 9, 7, 8, 6, 8]], ""output"": [[3, 9, 8, 2, 4, 9, 6, 3, 9, 8, 2, 4, 9, 6, 3, 9, 8, 2, 4, 9, 6], [9, 2, 3, 4, 6, 5, 8, 9, 2, 3, 4, 6, 5, 8, 9, 2, 3, 4, 6, 5, 8], [7, 6, 8, 3, 4, 8, 2, 7, 6, 8, 3, 4, 8, 2, 7, 6, 8, 3, 4, 8, 2], [8, 2, 5, 8, 2, 4, 3, 8, 2, 5, 8, 2, 4, 3, 8, 2, 5, 8, 2, 4, 3], [9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9], [5, 8, 5, 4, 5, 2, 7, 5, 8, 5, 4, 5, 2, 7, 5, 8, 5, 4, 5, 2, 7], [6, 3, 9, 7, 8, 6, 8, 6, 3, 9, 7, 8, 6, 8, 6, 3, 9, 7, 8, 6, 8], [6, 9, 8, 2, 4, 9, 3, 6, 9, 8, 2, 4, 9, 3, 6, 9, 8, 2, 4, 9, 3], [8, 2, 3, 4, 6, 5, 9, 8, 2, 3, 4, 6, 5, 9, 8, 2, 3, 4, 6, 5, 9], [2, 6, 8, 3, 4, 8, 7, 2, 6, 8, 3, 4, 8, 7, 2, 6, 8, 3, 4, 8, 7], [3, 2, 5, 8, 2, 4, 8, 3, 2, 5, 8, 2, 4, 8, 3, 2, 5, 8, 2, 4, 8], [9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9], [7, 8, 5, 4, 5, 2, 5, 7, 8, 5, 4, 5, 2, 5, 7, 8, 5, 4, 5, 2, 5], [8, 3, 9, 7, 8, 6, 6, 8, 3, 9, 7, 8, 6, 6, 8, 3, 9, 7, 8, 6, 6], [3, 9, 8, 2, 4, 9, 6, 3, 9, 8, 2, 4, 9, 6, 3, 9, 8, 2, 4, 9, 6], [9, 2, 3, 4, 6, 5, 8, 9, 2, 3, 4, 6, 5, 8, 9, 2, 3, 4, 6, 5, 8], [7, 6, 8, 3, 4, 8, 2, 7, 6, 8, 3, 4, 8, 2, 7, 6, 8, 3, 4, 8, 2], [8, 2, 5, 8, 2, 4, 3, 8, 2, 5, 8, 2, 4, 3, 8, 2, 5, 8, 2, 4, 3], [9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9, 9, 3, 7, 2, 7, 8, 9], [5, 8, 5, 4, 5, 2, 7, 5, 8, 5, 4, 5, 2, 7, 5, 8, 5, 4, 5, 2, 7], [6, 3, 9, 7, 8, 6, 8, 6, 3, 9, 7, 8, 6, 8, 6, 3, 9, 7, 8, 6, 8]]}, {""input"": [[6, 3, 2, 6, 5, 3, 6], [4, 7, 5, 8, 7, 5, 7], [6, 5, 6, 3, 2, 8, 4], [9, 3, 4, 5, 9, 7, 9], [6, 5, 8, 6, 2, 3, 5], [5, 8, 3, 9, 4, 7, 4], [2, 7, 6, 4, 7, 2, 7]], ""output"": [[6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6], [4, 7, 5, 8, 7, 5, 7, 4, 7, 5, 8, 7, 5, 7, 4, 7, 5, 8, 7, 5, 7], [6, 5, 6, 3, 2, 8, 4, 6, 5, 6, 3, 2, 8, 4, 6, 5, 6, 3, 2, 8, 4], [9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9], [6, 5, 8, 6, 2, 3, 5, 6, 5, 8, 6, 2, 3, 5, 6, 5, 8, 6, 2, 3, 5], [5, 8, 3, 9, 4, 7, 4, 5, 8, 3, 9, 4, 7, 4, 5, 8, 3, 9, 4, 7, 4], [2, 7, 6, 4, 7, 2, 7, 2, 7, 6, 4, 7, 2, 7, 2, 7, 6, 4, 7, 2, 7], [6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6], [7, 7, 5, 8, 7, 5, 4, 7, 7, 5, 8, 7, 5, 4, 7, 7, 5, 8, 7, 5, 4], [4, 5, 6, 3, 2, 8, 6, 4, 5, 6, 3, 2, 8, 6, 4, 5, 6, 3, 2, 8, 6], [9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9], [5, 5, 8, 6, 2, 3, 6, 5, 5, 8, 6, 2, 3, 6, 5, 5, 8, 6, 2, 3, 6], [4, 8, 3, 9, 4, 7, 5, 4, 8, 3, 9, 4, 7, 5, 4, 8, 3, 9, 4, 7, 5], [7, 7, 6, 4, 7, 2, 2, 7, 7, 6, 4, 7, 2, 2, 7, 7, 6, 4, 7, 2, 2], [6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6, 6, 3, 2, 6, 5, 3, 6], [4, 7, 5, 8, 7, 5, 7, 4, 7, 5, 8, 7, 5, 7, 4, 7, 5, 8, 7, 5, 7], [6, 5, 6, 3, 2, 8, 4, 6, 5, 6, 3, 2, 8, 4, 6, 5, 6, 3, 2, 8, 4], [9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9, 9, 3, 4, 5, 9, 7, 9], [6, 5, 8, 6, 2, 3, 5, 6, 5, 8, 6, 2, 3, 5, 6, 5, 8, 6, 2, 3, 5], [5, 8, 3, 9, 4, 7, 4, 5, 8, 3, 9, 4, 7, 4, 5, 8, 3, 9, 4, 7, 4], [2, 7, 6, 4, 7, 2, 7, 2, 7, 6, 4, 7, 2, 7, 2, 7, 6, 4, 7, 2, 7]]}], ""test"": [{""input"": [[9, 2, 7, 3, 8, 5, 6], [6, 4, 6, 4, 7, 4, 8], [2, 5, 2, 6, 9, 5, 7], [6, 4, 7, 3, 8, 9, 8], [7, 5, 4, 6, 9, 3, 7], [6, 2, 6, 3, 5, 2, 8], [2, 8, 9, 4, 8, 3, 2]], ""output"": [[9, 2, 7, 3, 8, 5, 6, 9, 2, 7, 3, 8, 5, 6, 9, 2, 7, 3, 8, 5, 6], [6, 4, 6, 4, 7, 4, 8, 6, 4, 6, 4, 7, 4, 8, 6, 4, 6, 4, 7, 4, 8], [2, 5, 2, 6, 9, 5, 7, 2, 5, 2, 6, 9, 5, 7, 2, 5, 2, 6, 9, 5, 7], [6, 4, 7, 3, 8, 9, 8, 6, 4, 7, 3, 8, 9, 8, 6, 4, 7, 3, 8, 9, 8], [7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7], [6, 2, 6, 3, 5, 2, 8, 6, 2, 6, 3, 5, 2, 8, 6, 2, 6, 3, 5, 2, 8], [2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2], [6, 2, 7, 3, 8, 5, 9, 6, 2, 7, 3, 8, 5, 9, 6, 2, 7, 3, 8, 5, 9], [8, 4, 6, 4, 7, 4, 6, 8, 4, 6, 4, 7, 4, 6, 8, 4, 6, 4, 7, 4, 6], [7, 5, 2, 6, 9, 5, 2, 7, 5, 2, 6, 9, 5, 2, 7, 5, 2, 6, 9, 5, 2], [8, 4, 7, 3, 8, 9, 6, 8, 4, 7, 3, 8, 9, 6, 8, 4, 7, 3, 8, 9, 6], [7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7], [8, 2, 6, 3, 5, 2, 6, 8, 2, 6, 3, 5, 2, 6, 8, 2, 6, 3, 5, 2, 6], [2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2], [9, 2, 7, 3, 8, 5, 6, 9, 2, 7, 3, 8, 5, 6, 9, 2, 7, 3, 8, 5, 6], [6, 4, 6, 4, 7, 4, 8, 6, 4, 6, 4, 7, 4, 8, 6, 4, 6, 4, 7, 4, 8], [2, 5, 2, 6, 9, 5, 7, 2, 5, 2, 6, 9, 5, 7, 2, 5, 2, 6, 9, 5, 7], [6, 4, 7, 3, 8, 9, 8, 6, 4, 7, 3, 8, 9, 8, 6, 4, 7, 3, 8, 9, 8], [7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7, 7, 5, 4, 6, 9, 3, 7], [6, 2, 6, 3, 5, 2, 8, 6, 2, 6, 3, 5, 2, 8, 6, 2, 6, 3, 5, 2, 8], [2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2, 2, 8, 9, 4, 8, 3, 2]]}]}"
WBtACxH9wW5xB8Zfg6FEMe,2025-07-21T15:52:22.791876,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 7, 9, 5], [3, 6, 3, 4], [9, 7, 9, 7], [4, 6, 5, 3]], ""output"": [[8, 7, 9, 5, 8, 7, 9, 5, 8, 7, 9, 5], [3, 6, 3, 4, 3, 6, 3, 4, 3, 6, 3, 4], [9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7], [4, 6, 5, 3, 4, 6, 5, 3, 4, 6, 5, 3], [5, 7, 9, 8, 5, 7, 9, 8, 5, 7, 9, 8], [4, 6, 3, 3, 4, 6, 3, 3, 4, 6, 3, 3], [7, 7, 9, 9, 7, 7, 9, 9, 7, 7, 9, 9], [3, 6, 5, 4, 3, 6, 5, 4, 3, 6, 5, 4], [8, 7, 9, 5, 8, 7, 9, 5, 8, 7, 9, 5], [3, 6, 3, 4, 3, 6, 3, 4, 3, 6, 3, 4], [9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7], [4, 6, 5, 3, 4, 6, 5, 3, 4, 6, 5, 3]]}, {""input"": [[8, 7, 6, 5], [6, 5, 4, 7], [3, 4, 3, 9], [2, 5, 7, 3]], ""output"": [[8, 7, 6, 5, 8, 7, 6, 5, 8, 7, 6, 5], [6, 5, 4, 7, 6, 5, 4, 7, 6, 5, 4, 7], [3, 4, 3, 9, 3, 4, 3, 9, 3, 4, 3, 9], [2, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7, 3], [5, 7, 6, 8, 5, 7, 6, 8, 5, 7, 6, 8], [7, 5, 4, 6, 7, 5, 4, 6, 7, 5, 4, 6], [9, 4, 3, 3, 9, 4, 3, 3, 9, 4, 3, 3], [3, 5, 7, 2, 3, 5, 7, 2, 3, 5, 7, 2], [8, 7, 6, 5, 8, 7, 6, 5, 8, 7, 6, 5], [6, 5, 4, 7, 6, 5, 4, 7, 6, 5, 4, 7], [3, 4, 3, 9, 3, 4, 3, 9, 3, 4, 3, 9], [2, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7, 3]]}, {""input"": [[5, 7, 2, 4], [2, 3, 8, 7], [6, 4, 6, 4], [3, 9, 5, 3]], ""output"": [[5, 7, 2, 4, 5, 7, 2, 4, 5, 7, 2, 4], [2, 3, 8, 7, 2, 3, 8, 7, 2, 3, 8, 7], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4, 6, 4], [3, 9, 5, 3, 3, 9, 5, 3, 3, 9, 5, 3], [4, 7, 2, 5, 4, 7, 2, 5, 4, 7, 2, 5], [7, 3, 8, 2, 7, 3, 8, 2, 7, 3, 8, 2], [4, 4, 6, 6, 4, 4, 6, 6, 4, 4, 6, 6], [3, 9, 5, 3, 3, 9, 5, 3, 3, 9, 5, 3], [5, 7, 2, 4, 5, 7, 2, 4, 5, 7, 2, 4], [2, 3, 8, 7, 2, 3, 8, 7, 2, 3, 8, 7], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4, 6, 4], [3, 9, 5, 3, 3, 9, 5, 3, 3, 9, 5, 3]]}], ""test"": [{""input"": [[4, 7, 6, 4], [8, 5, 8, 7], [3, 4, 6, 2], [8, 9, 3, 4]], ""output"": [[4, 7, 6, 4, 4, 7, 6, 4, 4, 7, 6, 4], [8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7], [3, 4, 6, 2, 3, 4, 6, 2, 3, 4, 6, 2], [8, 9, 3, 4, 8, 9, 3, 4, 8, 9, 3, 4], [4, 7, 6, 4, 4, 7, 6, 4, 4, 7, 6, 4], [7, 5, 8, 8, 7, 5, 8, 8, 7, 5, 8, 8], [2, 4, 6, 3, 2, 4, 6, 3, 2, 4, 6, 3], [4, 9, 3, 8, 4, 9, 3, 8, 4, 9, 3, 8], [4, 7, 6, 4, 4, 7, 6, 4, 4, 7, 6, 4], [8, 5, 8, 7, 8, 5, 8, 7, 8, 5, 8, 7], [3, 4, 6, 2, 3, 4, 6, 2, 3, 4, 6, 2], [8, 9, 3, 4, 8, 9, 3, 4, 8, 9, 3, 4]]}]}"
nMTAmTefErqJihNdRKgWut,2025-07-21T15:52:22.794177,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 5, 2], [2, 8, 3], [9, 3, 6]], ""output"": [[4, 5, 2, 4, 5, 2, 4, 5, 2], [2, 8, 3, 2, 8, 3, 2, 8, 3], [9, 3, 6, 9, 3, 6, 9, 3, 6], [2, 5, 4, 2, 5, 4, 2, 5, 4], [3, 8, 2, 3, 8, 2, 3, 8, 2], [6, 3, 9, 6, 3, 9, 6, 3, 9], [4, 5, 2, 4, 5, 2, 4, 5, 2], [2, 8, 3, 2, 8, 3, 2, 8, 3], [9, 3, 6, 9, 3, 6, 9, 3, 6]]}, {""input"": [[7, 8, 7], [2, 5, 9], [7, 3, 7]], ""output"": [[7, 8, 7, 7, 8, 7, 7, 8, 7], [2, 5, 9, 2, 5, 9, 2, 5, 9], [7, 3, 7, 7, 3, 7, 7, 3, 7], [7, 8, 7, 7, 8, 7, 7, 8, 7], [9, 5, 2, 9, 5, 2, 9, 5, 2], [7, 3, 7, 7, 3, 7, 7, 3, 7], [7, 8, 7, 7, 8, 7, 7, 8, 7], [2, 5, 9, 2, 5, 9, 2, 5, 9], [7, 3, 7, 7, 3, 7, 7, 3, 7]]}, {""input"": [[6, 8, 6], [3, 7, 3], [5, 4, 6]], ""output"": [[6, 8, 6, 6, 8, 6, 6, 8, 6], [3, 7, 3, 3, 7, 3, 3, 7, 3], [5, 4, 6, 5, 4, 6, 5, 4, 6], [6, 8, 6, 6, 8, 6, 6, 8, 6], [3, 7, 3, 3, 7, 3, 3, 7, 3], [6, 4, 5, 6, 4, 5, 6, 4, 5], [6, 8, 6, 6, 8, 6, 6, 8, 6], [3, 7, 3, 3, 7, 3, 3, 7, 3], [5, 4, 6, 5, 4, 6, 5, 4, 6]]}], ""test"": [{""input"": [[2, 4, 9], [3, 2, 5], [7, 8, 9]], ""output"": [[2, 4, 9, 2, 4, 9, 2, 4, 9], [3, 2, 5, 3, 2, 5, 3, 2, 5], [7, 8, 9, 7, 8, 9, 7, 8, 9], [9, 4, 2, 9, 4, 2, 9, 4, 2], [5, 2, 3, 5, 2, 3, 5, 2, 3], [9, 8, 7, 9, 8, 7, 9, 8, 7], [2, 4, 9, 2, 4, 9, 2, 4, 9], [3, 2, 5, 3, 2, 5, 3, 2, 5], [7, 8, 9, 7, 8, 9, 7, 8, 9]]}]}"
VgbRiQNdQsgEwUTv6X3ULz,2025-07-21T15:52:22.796144,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 2], [5, 6]], ""output"": [[4, 2, 4, 2, 4, 2], [5, 6, 5, 6, 5, 6], [2, 4, 2, 4, 2, 4], [6, 5, 6, 5, 6, 5], [4, 2, 4, 2, 4, 2], [5, 6, 5, 6, 5, 6]]}, {""input"": [[5, 8], [3, 9]], ""output"": [[5, 8, 5, 8, 5, 8], [3, 9, 3, 9, 3, 9], [8, 5, 8, 5, 8, 5], [9, 3, 9, 3, 9, 3], [5, 8, 5, 8, 5, 8], [3, 9, 3, 9, 3, 9]]}, {""input"": [[5, 2], [9, 3]], ""output"": [[5, 2, 5, 2, 5, 2], [9, 3, 9, 3, 9, 3], [2, 5, 2, 5, 2, 5], [3, 9, 3, 9, 3, 9], [5, 2, 5, 2, 5, 2], [9, 3, 9, 3, 9, 3]]}], ""test"": [{""input"": [[5, 2], [9, 6]], ""output"": [[5, 2, 5, 2, 5, 2], [9, 6, 9, 6, 9, 6], [2, 5, 2, 5, 2, 5], [6, 9, 6, 9, 6, 9], [5, 2, 5, 2, 5, 2], [9, 6, 9, 6, 9, 6]]}]}"
ipm7rwZvQ34xyWJff8iHqc,2025-07-21T15:52:22.798241,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 2, 6, 5, 6], [9, 7, 9, 7, 9], [8, 9, 6, 2, 8], [3, 8, 7, 9, 4], [8, 7, 2, 5, 7]], ""output"": [[3, 2, 6, 5, 6, 3, 2, 6, 5, 6, 3, 2, 6, 5, 6], [9, 7, 9, 7, 9, 9, 7, 9, 7, 9, 9, 7, 9, 7, 9], [8, 9, 6, 2, 8, 8, 9, 6, 2, 8, 8, 9, 6, 2, 8], [3, 8, 7, 9, 4, 3, 8, 7, 9, 4, 3, 8, 7, 9, 4], [8, 7, 2, 5, 7, 8, 7, 2, 5, 7, 8, 7, 2, 5, 7], [6, 2, 6, 5, 3, 6, 2, 6, 5, 3, 6, 2, 6, 5, 3], [9, 7, 9, 7, 9, 9, 7, 9, 7, 9, 9, 7, 9, 7, 9], [8, 9, 6, 2, 8, 8, 9, 6, 2, 8, 8, 9, 6, 2, 8], [4, 8, 7, 9, 3, 4, 8, 7, 9, 3, 4, 8, 7, 9, 3], [7, 7, 2, 5, 8, 7, 7, 2, 5, 8, 7, 7, 2, 5, 8], [3, 2, 6, 5, 6, 3, 2, 6, 5, 6, 3, 2, 6, 5, 6], [9, 7, 9, 7, 9, 9, 7, 9, 7, 9, 9, 7, 9, 7, 9], [8, 9, 6, 2, 8, 8, 9, 6, 2, 8, 8, 9, 6, 2, 8], [3, 8, 7, 9, 4, 3, 8, 7, 9, 4, 3, 8, 7, 9, 4], [8, 7, 2, 5, 7, 8, 7, 2, 5, 7, 8, 7, 2, 5, 7]]}, {""input"": [[9, 4, 2, 6, 3], [4, 8, 9, 4, 6], [3, 5, 4, 7, 4], [9, 6, 2, 4, 5], [7, 3, 6, 2, 6]], ""output"": [[9, 4, 2, 6, 3, 9, 4, 2, 6, 3, 9, 4, 2, 6, 3], [4, 8, 9, 4, 6, 4, 8, 9, 4, 6, 4, 8, 9, 4, 6], [3, 5, 4, 7, 4, 3, 5, 4, 7, 4, 3, 5, 4, 7, 4], [9, 6, 2, 4, 5, 9, 6, 2, 4, 5, 9, 6, 2, 4, 5], [7, 3, 6, 2, 6, 7, 3, 6, 2, 6, 7, 3, 6, 2, 6], [3, 4, 2, 6, 9, 3, 4, 2, 6, 9, 3, 4, 2, 6, 9], [6, 8, 9, 4, 4, 6, 8, 9, 4, 4, 6, 8, 9, 4, 4], [4, 5, 4, 7, 3, 4, 5, 4, 7, 3, 4, 5, 4, 7, 3], [5, 6, 2, 4, 9, 5, 6, 2, 4, 9, 5, 6, 2, 4, 9], [6, 3, 6, 2, 7, 6, 3, 6, 2, 7, 6, 3, 6, 2, 7], [9, 4, 2, 6, 3, 9, 4, 2, 6, 3, 9, 4, 2, 6, 3], [4, 8, 9, 4, 6, 4, 8, 9, 4, 6, 4, 8, 9, 4, 6], [3, 5, 4, 7, 4, 3, 5, 4, 7, 4, 3, 5, 4, 7, 4], [9, 6, 2, 4, 5, 9, 6, 2, 4, 5, 9, 6, 2, 4, 5], [7, 3, 6, 2, 6, 7, 3, 6, 2, 6, 7, 3, 6, 2, 6]]}, {""input"": [[8, 9, 4, 2, 9], [2, 6, 7, 5, 7], [3, 8, 5, 8, 2], [2, 3, 9, 3, 9], [8, 9, 4, 5, 4]], ""output"": [[8, 9, 4, 2, 9, 8, 9, 4, 2, 9, 8, 9, 4, 2, 9], [2, 6, 7, 5, 7, 2, 6, 7, 5, 7, 2, 6, 7, 5, 7], [3, 8, 5, 8, 2, 3, 8, 5, 8, 2, 3, 8, 5, 8, 2], [2, 3, 9, 3, 9, 2, 3, 9, 3, 9, 2, 3, 9, 3, 9], [8, 9, 4, 5, 4, 8, 9, 4, 5, 4, 8, 9, 4, 5, 4], [9, 9, 4, 2, 8, 9, 9, 4, 2, 8, 9, 9, 4, 2, 8], [7, 6, 7, 5, 2, 7, 6, 7, 5, 2, 7, 6, 7, 5, 2], [2, 8, 5, 8, 3, 2, 8, 5, 8, 3, 2, 8, 5, 8, 3], [9, 3, 9, 3, 2, 9, 3, 9, 3, 2, 9, 3, 9, 3, 2], [4, 9, 4, 5, 8, 4, 9, 4, 5, 8, 4, 9, 4, 5, 8], [8, 9, 4, 2, 9, 8, 9, 4, 2, 9, 8, 9, 4, 2, 9], [2, 6, 7, 5, 7, 2, 6, 7, 5, 7, 2, 6, 7, 5, 7], [3, 8, 5, 8, 2, 3, 8, 5, 8, 2, 3, 8, 5, 8, 2], [2, 3, 9, 3, 9, 2, 3, 9, 3, 9, 2, 3, 9, 3, 9], [8, 9, 4, 5, 4, 8, 9, 4, 5, 4, 8, 9, 4, 5, 4]]}], ""test"": [{""input"": [[9, 3, 9, 7, 4], [6, 5, 4, 2, 3], [7, 3, 2, 4, 8], [5, 8, 6, 7, 4], [2, 5, 9, 8, 6]], ""output"": [[9, 3, 9, 7, 4, 9, 3, 9, 7, 4, 9, 3, 9, 7, 4], [6, 5, 4, 2, 3, 6, 5, 4, 2, 3, 6, 5, 4, 2, 3], [7, 3, 2, 4, 8, 7, 3, 2, 4, 8, 7, 3, 2, 4, 8], [5, 8, 6, 7, 4, 5, 8, 6, 7, 4, 5, 8, 6, 7, 4], [2, 5, 9, 8, 6, 2, 5, 9, 8, 6, 2, 5, 9, 8, 6], [4, 3, 9, 7, 9, 4, 3, 9, 7, 9, 4, 3, 9, 7, 9], [3, 5, 4, 2, 6, 3, 5, 4, 2, 6, 3, 5, 4, 2, 6], [8, 3, 2, 4, 7, 8, 3, 2, 4, 7, 8, 3, 2, 4, 7], [4, 8, 6, 7, 5, 4, 8, 6, 7, 5, 4, 8, 6, 7, 5], [6, 5, 9, 8, 2, 6, 5, 9, 8, 2, 6, 5, 9, 8, 2], [9, 3, 9, 7, 4, 9, 3, 9, 7, 4, 9, 3, 9, 7, 4], [6, 5, 4, 2, 3, 6, 5, 4, 2, 3, 6, 5, 4, 2, 3], [7, 3, 2, 4, 8, 7, 3, 2, 4, 8, 7, 3, 2, 4, 8], [5, 8, 6, 7, 4, 5, 8, 6, 7, 4, 5, 8, 6, 7, 4], [2, 5, 9, 8, 6, 2, 5, 9, 8, 6, 2, 5, 9, 8, 6]]}]}"
M6wCjKpikJ2ciuVLMLuLWk,2025-07-21T15:52:22.800335,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 3, 9, 4], [2, 7, 6, 9], [8, 3, 5, 2], [4, 9, 7, 6]], ""output"": [[8, 3, 9, 4, 8, 3, 9, 4, 8, 3, 9, 4], [2, 7, 6, 9, 2, 7, 6, 9, 2, 7, 6, 9], [8, 3, 5, 2, 8, 3, 5, 2, 8, 3, 5, 2], [4, 9, 7, 6, 4, 9, 7, 6, 4, 9, 7, 6], [4, 3, 9, 8, 4, 3, 9, 8, 4, 3, 9, 8], [9, 7, 6, 2, 9, 7, 6, 2, 9, 7, 6, 2], [2, 3, 5, 8, 2, 3, 5, 8, 2, 3, 5, 8], [6, 9, 7, 4, 6, 9, 7, 4, 6, 9, 7, 4], [8, 3, 9, 4, 8, 3, 9, 4, 8, 3, 9, 4], [2, 7, 6, 9, 2, 7, 6, 9, 2, 7, 6, 9], [8, 3, 5, 2, 8, 3, 5, 2, 8, 3, 5, 2], [4, 9, 7, 6, 4, 9, 7, 6, 4, 9, 7, 6]]}, {""input"": [[3, 4, 6, 4], [5, 2, 5, 6], [2, 4, 6, 2], [5, 6, 9, 4]], ""output"": [[3, 4, 6, 4, 3, 4, 6, 4, 3, 4, 6, 4], [5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5, 6], [2, 4, 6, 2, 2, 4, 6, 2, 2, 4, 6, 2], [5, 6, 9, 4, 5, 6, 9, 4, 5, 6, 9, 4], [4, 4, 6, 3, 4, 4, 6, 3, 4, 4, 6, 3], [6, 2, 5, 5, 6, 2, 5, 5, 6, 2, 5, 5], [2, 4, 6, 2, 2, 4, 6, 2, 2, 4, 6, 2], [4, 6, 9, 5, 4, 6, 9, 5, 4, 6, 9, 5], [3, 4, 6, 4, 3, 4, 6, 4, 3, 4, 6, 4], [5, 2, 5, 6, 5, 2, 5, 6, 5, 2, 5, 6], [2, 4, 6, 2, 2, 4, 6, 2, 2, 4, 6, 2], [5, 6, 9, 4, 5, 6, 9, 4, 5, 6, 9, 4]]}, {""input"": [[9, 5, 4, 3], [3, 7, 3, 8], [8, 3, 2, 6], [6, 4, 9, 1]], ""output"": [[9, 5, 4, 3, 9, 5, 4, 3, 9, 5, 4, 3], [3, 7, 3, 8, 3, 7, 3, 8, 3, 7, 3, 8], [8, 3, 2, 6, 8, 3, 2, 6, 8, 3, 2, 6], [6, 4, 9, 1, 6, 4, 9, 1, 6, 4, 9, 1], [3, 5, 4, 9, 3, 5, 4, 9, 3, 5, 4, 9], [8, 7, 3, 3, 8, 7, 3, 3, 8, 7, 3, 3], [6, 3, 2, 8, 6, 3, 2, 8, 6, 3, 2, 8], [1, 4, 9, 6, 1, 4, 9, 6, 1, 4, 9, 6], [9, 5, 4, 3, 9, 5, 4, 3, 9, 5, 4, 3], [3, 7, 3, 8, 3, 7, 3, 8, 3, 7, 3, 8], [8, 3, 2, 6, 8, 3, 2, 6, 8, 3, 2, 6], [6, 4, 9, 1, 6, 4, 9, 1, 6, 4, 9, 1]]}], ""test"": [{""input"": [[6, 8, 2, 9], [7, 4, 9, 5], [9, 5, 8, 9], [7, 9, 6, 5]], ""output"": [[6, 8, 2, 9, 6, 8, 2, 9, 6, 8, 2, 9], [7, 4, 9, 5, 7, 4, 9, 5, 7, 4, 9, 5], [9, 5, 8, 9, 9, 5, 8, 9, 9, 5, 8, 9], [7, 9, 6, 5, 7, 9, 6, 5, 7, 9, 6, 5], [9, 8, 2, 6, 9, 8, 2, 6, 9, 8, 2, 6], [5, 4, 9, 7, 5, 4, 9, 7, 5, 4, 9, 7], [9, 5, 8, 9, 9, 5, 8, 9, 9, 5, 8, 9], [5, 9, 6, 7, 5, 9, 6, 7, 5, 9, 6, 7], [6, 8, 2, 9, 6, 8, 2, 9, 6, 8, 2, 9], [7, 4, 9, 5, 7, 4, 9, 5, 7, 4, 9, 5], [9, 5, 8, 9, 9, 5, 8, 9, 9, 5, 8, 9], [7, 9, 6, 5, 7, 9, 6, 5, 7, 9, 6, 5]]}]}"
bRgvuZkXA5zTFYMZvQJDtE,2025-07-21T15:52:22.803125,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 8, 6, 4, 2, 6, 4], [9, 2, 4, 6, 9, 3, 9], [2, 4, 3, 4, 7, 9, 4], [6, 5, 9, 7, 9, 6, 5], [4, 3, 6, 4, 2, 4, 7], [2, 4, 3, 8, 5, 7, 9], [6, 3, 2, 9, 8, 6, 2]], ""output"": [[7, 8, 6, 4, 2, 6, 4, 7, 8, 6, 4, 2, 6, 4, 7, 8, 6, 4, 2, 6, 4], [9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9], [2, 4, 3, 4, 7, 9, 4, 2, 4, 3, 4, 7, 9, 4, 2, 4, 3, 4, 7, 9, 4], [6, 5, 9, 7, 9, 6, 5, 6, 5, 9, 7, 9, 6, 5, 6, 5, 9, 7, 9, 6, 5], [4, 3, 6, 4, 2, 4, 7, 4, 3, 6, 4, 2, 4, 7, 4, 3, 6, 4, 2, 4, 7], [2, 4, 3, 8, 5, 7, 9, 2, 4, 3, 8, 5, 7, 9, 2, 4, 3, 8, 5, 7, 9], [6, 3, 2, 9, 8, 6, 2, 6, 3, 2, 9, 8, 6, 2, 6, 3, 2, 9, 8, 6, 2], [4, 8, 6, 4, 2, 6, 7, 4, 8, 6, 4, 2, 6, 7, 4, 8, 6, 4, 2, 6, 7], [9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9], [4, 4, 3, 4, 7, 9, 2, 4, 4, 3, 4, 7, 9, 2, 4, 4, 3, 4, 7, 9, 2], [5, 5, 9, 7, 9, 6, 6, 5, 5, 9, 7, 9, 6, 6, 5, 5, 9, 7, 9, 6, 6], [7, 3, 6, 4, 2, 4, 4, 7, 3, 6, 4, 2, 4, 4, 7, 3, 6, 4, 2, 4, 4], [9, 4, 3, 8, 5, 7, 2, 9, 4, 3, 8, 5, 7, 2, 9, 4, 3, 8, 5, 7, 2], [2, 3, 2, 9, 8, 6, 6, 2, 3, 2, 9, 8, 6, 6, 2, 3, 2, 9, 8, 6, 6], [7, 8, 6, 4, 2, 6, 4, 7, 8, 6, 4, 2, 6, 4, 7, 8, 6, 4, 2, 6, 4], [9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9, 9, 2, 4, 6, 9, 3, 9], [2, 4, 3, 4, 7, 9, 4, 2, 4, 3, 4, 7, 9, 4, 2, 4, 3, 4, 7, 9, 4], [6, 5, 9, 7, 9, 6, 5, 6, 5, 9, 7, 9, 6, 5, 6, 5, 9, 7, 9, 6, 5], [4, 3, 6, 4, 2, 4, 7, 4, 3, 6, 4, 2, 4, 7, 4, 3, 6, 4, 2, 4, 7], [2, 4, 3, 8, 5, 7, 9, 2, 4, 3, 8, 5, 7, 9, 2, 4, 3, 8, 5, 7, 9], [6, 3, 2, 9, 8, 6, 2, 6, 3, 2, 9, 8, 6, 2, 6, 3, 2, 9, 8, 6, 2]]}, {""input"": [[4, 9, 8, 3, 4, 5, 2], [9, 2, 9, 4, 7, 3, 6], [3, 4, 3, 6, 9, 5, 7], [4, 5, 7, 2, 5, 8, 9], [6, 4, 2, 7, 9, 5, 4], [3, 6, 5, 3, 8, 9, 3], [9, 2, 9, 2, 7, 3, 8]], ""output"": [[4, 9, 8, 3, 4, 5, 2, 4, 9, 8, 3, 4, 5, 2, 4, 9, 8, 3, 4, 5, 2], [9, 2, 9, 4, 7, 3, 6, 9, 2, 9, 4, 7, 3, 6, 9, 2, 9, 4, 7, 3, 6], [3, 4, 3, 6, 9, 5, 7, 3, 4, 3, 6, 9, 5, 7, 3, 4, 3, 6, 9, 5, 7], [4, 5, 7, 2, 5, 8, 9, 4, 5, 7, 2, 5, 8, 9, 4, 5, 7, 2, 5, 8, 9], [6, 4, 2, 7, 9, 5, 4, 6, 4, 2, 7, 9, 5, 4, 6, 4, 2, 7, 9, 5, 4], [3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3], [9, 2, 9, 2, 7, 3, 8, 9, 2, 9, 2, 7, 3, 8, 9, 2, 9, 2, 7, 3, 8], [2, 9, 8, 3, 4, 5, 4, 2, 9, 8, 3, 4, 5, 4, 2, 9, 8, 3, 4, 5, 4], [6, 2, 9, 4, 7, 3, 9, 6, 2, 9, 4, 7, 3, 9, 6, 2, 9, 4, 7, 3, 9], [7, 4, 3, 6, 9, 5, 3, 7, 4, 3, 6, 9, 5, 3, 7, 4, 3, 6, 9, 5, 3], [9, 5, 7, 2, 5, 8, 4, 9, 5, 7, 2, 5, 8, 4, 9, 5, 7, 2, 5, 8, 4], [4, 4, 2, 7, 9, 5, 6, 4, 4, 2, 7, 9, 5, 6, 4, 4, 2, 7, 9, 5, 6], [3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3], [8, 2, 9, 2, 7, 3, 9, 8, 2, 9, 2, 7, 3, 9, 8, 2, 9, 2, 7, 3, 9], [4, 9, 8, 3, 4, 5, 2, 4, 9, 8, 3, 4, 5, 2, 4, 9, 8, 3, 4, 5, 2], [9, 2, 9, 4, 7, 3, 6, 9, 2, 9, 4, 7, 3, 6, 9, 2, 9, 4, 7, 3, 6], [3, 4, 3, 6, 9, 5, 7, 3, 4, 3, 6, 9, 5, 7, 3, 4, 3, 6, 9, 5, 7], [4, 5, 7, 2, 5, 8, 9, 4, 5, 7, 2, 5, 8, 9, 4, 5, 7, 2, 5, 8, 9], [6, 4, 2, 7, 9, 5, 4, 6, 4, 2, 7, 9, 5, 4, 6, 4, 2, 7, 9, 5, 4], [3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3, 3, 6, 5, 3, 8, 9, 3], [9, 2, 9, 2, 7, 3, 8, 9, 2, 9, 2, 7, 3, 8, 9, 2, 9, 2, 7, 3, 8]]}, {""input"": [[5, 9, 2, 8, 7, 4, 8], [9, 2, 8, 7, 4, 5, 6], [5, 3, 4, 5, 6, 8, 9], [2, 8, 2, 9, 3, 4, 6], [4, 9, 5, 3, 9, 7, 5], [5, 4, 3, 9, 3, 4, 2], [9, 8, 7, 5, 9, 7, 5]], ""output"": [[5, 9, 2, 8, 7, 4, 8, 5, 9, 2, 8, 7, 4, 8, 5, 9, 2, 8, 7, 4, 8], [9, 2, 8, 7, 4, 5, 6, 9, 2, 8, 7, 4, 5, 6, 9, 2, 8, 7, 4, 5, 6], [5, 3, 4, 5, 6, 8, 9, 5, 3, 4, 5, 6, 8, 9, 5, 3, 4, 5, 6, 8, 9], [2, 8, 2, 9, 3, 4, 6, 2, 8, 2, 9, 3, 4, 6, 2, 8, 2, 9, 3, 4, 6], [4, 9, 5, 3, 9, 7, 5, 4, 9, 5, 3, 9, 7, 5, 4, 9, 5, 3, 9, 7, 5], [5, 4, 3, 9, 3, 4, 2, 5, 4, 3, 9, 3, 4, 2, 5, 4, 3, 9, 3, 4, 2], [9, 8, 7, 5, 9, 7, 5, 9, 8, 7, 5, 9, 7, 5, 9, 8, 7, 5, 9, 7, 5], [8, 9, 2, 8, 7, 4, 5, 8, 9, 2, 8, 7, 4, 5, 8, 9, 2, 8, 7, 4, 5], [6, 2, 8, 7, 4, 5, 9, 6, 2, 8, 7, 4, 5, 9, 6, 2, 8, 7, 4, 5, 9], [9, 3, 4, 5, 6, 8, 5, 9, 3, 4, 5, 6, 8, 5, 9, 3, 4, 5, 6, 8, 5], [6, 8, 2, 9, 3, 4, 2, 6, 8, 2, 9, 3, 4, 2, 6, 8, 2, 9, 3, 4, 2], [5, 9, 5, 3, 9, 7, 4, 5, 9, 5, 3, 9, 7, 4, 5, 9, 5, 3, 9, 7, 4], [2, 4, 3, 9, 3, 4, 5, 2, 4, 3, 9, 3, 4, 5, 2, 4, 3, 9, 3, 4, 5], [5, 8, 7, 5, 9, 7, 9, 5, 8, 7, 5, 9, 7, 9, 5, 8, 7, 5, 9, 7, 9], [5, 9, 2, 8, 7, 4, 8, 5, 9, 2, 8, 7, 4, 8, 5, 9, 2, 8, 7, 4, 8], [9, 2, 8, 7, 4, 5, 6, 9, 2, 8, 7, 4, 5, 6, 9, 2, 8, 7, 4, 5, 6], [5, 3, 4, 5, 6, 8, 9, 5, 3, 4, 5, 6, 8, 9, 5, 3, 4, 5, 6, 8, 9], [2, 8, 2, 9, 3, 4, 6, 2, 8, 2, 9, 3, 4, 6, 2, 8, 2, 9, 3, 4, 6], [4, 9, 5, 3, 9, 7, 5, 4, 9, 5, 3, 9, 7, 5, 4, 9, 5, 3, 9, 7, 5], [5, 4, 3, 9, 3, 4, 2, 5, 4, 3, 9, 3, 4, 2, 5, 4, 3, 9, 3, 4, 2], [9, 8, 7, 5, 9, 7, 5, 9, 8, 7, 5, 9, 7, 5, 9, 8, 7, 5, 9, 7, 5]]}], ""test"": [{""input"": [[5, 2, 3, 9, 6, 4, 2], [2, 5, 8, 7, 5, 2, 4], [6, 2, 6, 8, 9, 5, 8], [8, 7, 9, 4, 2, 8, 6], [9, 3, 4, 6, 5, 2, 7], [8, 9, 7, 4, 8, 7, 4], [7, 8, 3, 7, 2, 5, 3]], ""output"": [[5, 2, 3, 9, 6, 4, 2, 5, 2, 3, 9, 6, 4, 2, 5, 2, 3, 9, 6, 4, 2], [2, 5, 8, 7, 5, 2, 4, 2, 5, 8, 7, 5, 2, 4, 2, 5, 8, 7, 5, 2, 4], [6, 2, 6, 8, 9, 5, 8, 6, 2, 6, 8, 9, 5, 8, 6, 2, 6, 8, 9, 5, 8], [8, 7, 9, 4, 2, 8, 6, 8, 7, 9, 4, 2, 8, 6, 8, 7, 9, 4, 2, 8, 6], [9, 3, 4, 6, 5, 2, 7, 9, 3, 4, 6, 5, 2, 7, 9, 3, 4, 6, 5, 2, 7], [8, 9, 7, 4, 8, 7, 4, 8, 9, 7, 4, 8, 7, 4, 8, 9, 7, 4, 8, 7, 4], [7, 8, 3, 7, 2, 5, 3, 7, 8, 3, 7, 2, 5, 3, 7, 8, 3, 7, 2, 5, 3], [2, 2, 3, 9, 6, 4, 5, 2, 2, 3, 9, 6, 4, 5, 2, 2, 3, 9, 6, 4, 5], [4, 5, 8, 7, 5, 2, 2, 4, 5, 8, 7, 5, 2, 2, 4, 5, 8, 7, 5, 2, 2], [8, 2, 6, 8, 9, 5, 6, 8, 2, 6, 8, 9, 5, 6, 8, 2, 6, 8, 9, 5, 6], [6, 7, 9, 4, 2, 8, 8, 6, 7, 9, 4, 2, 8, 8, 6, 7, 9, 4, 2, 8, 8], [7, 3, 4, 6, 5, 2, 9, 7, 3, 4, 6, 5, 2, 9, 7, 3, 4, 6, 5, 2, 9], [4, 9, 7, 4, 8, 7, 8, 4, 9, 7, 4, 8, 7, 8, 4, 9, 7, 4, 8, 7, 8], [3, 8, 3, 7, 2, 5, 7, 3, 8, 3, 7, 2, 5, 7, 3, 8, 3, 7, 2, 5, 7], [5, 2, 3, 9, 6, 4, 2, 5, 2, 3, 9, 6, 4, 2, 5, 2, 3, 9, 6, 4, 2], [2, 5, 8, 7, 5, 2, 4, 2, 5, 8, 7, 5, 2, 4, 2, 5, 8, 7, 5, 2, 4], [6, 2, 6, 8, 9, 5, 8, 6, 2, 6, 8, 9, 5, 8, 6, 2, 6, 8, 9, 5, 8], [8, 7, 9, 4, 2, 8, 6, 8, 7, 9, 4, 2, 8, 6, 8, 7, 9, 4, 2, 8, 6], [9, 3, 4, 6, 5, 2, 7, 9, 3, 4, 6, 5, 2, 7, 9, 3, 4, 6, 5, 2, 7], [8, 9, 7, 4, 8, 7, 4, 8, 9, 7, 4, 8, 7, 4, 8, 9, 7, 4, 8, 7, 4], [7, 8, 3, 7, 2, 5, 3, 7, 8, 3, 7, 2, 5, 3, 7, 8, 3, 7, 2, 5, 3]]}]}"
kMChufK6ZeEZjZsejDg4BY,2025-07-21T15:52:22.805707,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 7, 4, 2, 9], [4, 3, 9, 6, 2], [6, 5, 7, 3, 6], [2, 9, 5, 6, 9], [7, 4, 6, 4, 8]], ""output"": [[8, 7, 4, 2, 9, 8, 7, 4, 2, 9, 8, 7, 4, 2, 9], [4, 3, 9, 6, 2, 4, 3, 9, 6, 2, 4, 3, 9, 6, 2], [6, 5, 7, 3, 6, 6, 5, 7, 3, 6, 6, 5, 7, 3, 6], [2, 9, 5, 6, 9, 2, 9, 5, 6, 9, 2, 9, 5, 6, 9], [7, 4, 6, 4, 8, 7, 4, 6, 4, 8, 7, 4, 6, 4, 8], [9, 7, 4, 2, 8, 9, 7, 4, 2, 8, 9, 7, 4, 2, 8], [2, 3, 9, 6, 4, 2, 3, 9, 6, 4, 2, 3, 9, 6, 4], [6, 5, 7, 3, 6, 6, 5, 7, 3, 6, 6, 5, 7, 3, 6], [9, 9, 5, 6, 2, 9, 9, 5, 6, 2, 9, 9, 5, 6, 2], [8, 4, 6, 4, 7, 8, 4, 6, 4, 7, 8, 4, 6, 4, 7], [8, 7, 4, 2, 9, 8, 7, 4, 2, 9, 8, 7, 4, 2, 9], [4, 3, 9, 6, 2, 4, 3, 9, 6, 2, 4, 3, 9, 6, 2], [6, 5, 7, 3, 6, 6, 5, 7, 3, 6, 6, 5, 7, 3, 6], [2, 9, 5, 6, 9, 2, 9, 5, 6, 9, 2, 9, 5, 6, 9], [7, 4, 6, 4, 8, 7, 4, 6, 4, 8, 7, 4, 6, 4, 8]]}, {""input"": [[2, 9, 7, 8, 7], [4, 7, 3, 7, 9], [6, 9, 7, 9, 4], [3, 5, 9, 2, 9], [9, 8, 3, 6, 3]], ""output"": [[2, 9, 7, 8, 7, 2, 9, 7, 8, 7, 2, 9, 7, 8, 7], [4, 7, 3, 7, 9, 4, 7, 3, 7, 9, 4, 7, 3, 7, 9], [6, 9, 7, 9, 4, 6, 9, 7, 9, 4, 6, 9, 7, 9, 4], [3, 5, 9, 2, 9, 3, 5, 9, 2, 9, 3, 5, 9, 2, 9], [9, 8, 3, 6, 3, 9, 8, 3, 6, 3, 9, 8, 3, 6, 3], [7, 9, 7, 8, 2, 7, 9, 7, 8, 2, 7, 9, 7, 8, 2], [9, 7, 3, 7, 4, 9, 7, 3, 7, 4, 9, 7, 3, 7, 4], [4, 9, 7, 9, 6, 4, 9, 7, 9, 6, 4, 9, 7, 9, 6], [9, 5, 9, 2, 3, 9, 5, 9, 2, 3, 9, 5, 9, 2, 3], [3, 8, 3, 6, 9, 3, 8, 3, 6, 9, 3, 8, 3, 6, 9], [2, 9, 7, 8, 7, 2, 9, 7, 8, 7, 2, 9, 7, 8, 7], [4, 7, 3, 7, 9, 4, 7, 3, 7, 9, 4, 7, 3, 7, 9], [6, 9, 7, 9, 4, 6, 9, 7, 9, 4, 6, 9, 7, 9, 4], [3, 5, 9, 2, 9, 3, 5, 9, 2, 9, 3, 5, 9, 2, 9], [9, 8, 3, 6, 3, 9, 8, 3, 6, 3, 9, 8, 3, 6, 3]]}, {""input"": [[8, 7, 5, 7, 6], [5, 3, 6, 3, 5], [7, 2, 8, 4, 9], [2, 9, 7, 3, 4], [4, 5, 8, 2, 6]], ""output"": [[8, 7, 5, 7, 6, 8, 7, 5, 7, 6, 8, 7, 5, 7, 6], [5, 3, 6, 3, 5, 5, 3, 6, 3, 5, 5, 3, 6, 3, 5], [7, 2, 8, 4, 9, 7, 2, 8, 4, 9, 7, 2, 8, 4, 9], [2, 9, 7, 3, 4, 2, 9, 7, 3, 4, 2, 9, 7, 3, 4], [4, 5, 8, 2, 6, 4, 5, 8, 2, 6, 4, 5, 8, 2, 6], [6, 7, 5, 7, 8, 6, 7, 5, 7, 8, 6, 7, 5, 7, 8], [5, 3, 6, 3, 5, 5, 3, 6, 3, 5, 5, 3, 6, 3, 5], [9, 2, 8, 4, 7, 9, 2, 8, 4, 7, 9, 2, 8, 4, 7], [4, 9, 7, 3, 2, 4, 9, 7, 3, 2, 4, 9, 7, 3, 2], [6, 5, 8, 2, 4, 6, 5, 8, 2, 4, 6, 5, 8, 2, 4], [8, 7, 5, 7, 6, 8, 7, 5, 7, 6, 8, 7, 5, 7, 6], [5, 3, 6, 3, 5, 5, 3, 6, 3, 5, 5, 3, 6, 3, 5], [7, 2, 8, 4, 9, 7, 2, 8, 4, 9, 7, 2, 8, 4, 9], [2, 9, 7, 3, 4, 2, 9, 7, 3, 4, 2, 9, 7, 3, 4], [4, 5, 8, 2, 6, 4, 5, 8, 2, 6, 4, 5, 8, 2, 6]]}], ""test"": [{""input"": [[2, 4, 2, 4, 5], [3, 7, 9, 2, 3], [2, 6, 7, 8, 6], [6, 7, 6, 2, 5], [3, 2, 4, 7, 3]], ""output"": [[2, 4, 2, 4, 5, 2, 4, 2, 4, 5, 2, 4, 2, 4, 5], [3, 7, 9, 2, 3, 3, 7, 9, 2, 3, 3, 7, 9, 2, 3], [2, 6, 7, 8, 6, 2, 6, 7, 8, 6, 2, 6, 7, 8, 6], [6, 7, 6, 2, 5, 6, 7, 6, 2, 5, 6, 7, 6, 2, 5], [3, 2, 4, 7, 3, 3, 2, 4, 7, 3, 3, 2, 4, 7, 3], [5, 4, 2, 4, 2, 5, 4, 2, 4, 2, 5, 4, 2, 4, 2], [3, 7, 9, 2, 3, 3, 7, 9, 2, 3, 3, 7, 9, 2, 3], [6, 6, 7, 8, 2, 6, 6, 7, 8, 2, 6, 6, 7, 8, 2], [5, 7, 6, 2, 6, 5, 7, 6, 2, 6, 5, 7, 6, 2, 6], [3, 2, 4, 7, 3, 3, 2, 4, 7, 3, 3, 2, 4, 7, 3], [2, 4, 2, 4, 5, 2, 4, 2, 4, 5, 2, 4, 2, 4, 5], [3, 7, 9, 2, 3, 3, 7, 9, 2, 3, 3, 7, 9, 2, 3], [2, 6, 7, 8, 6, 2, 6, 7, 8, 6, 2, 6, 7, 8, 6], [6, 7, 6, 2, 5, 6, 7, 6, 2, 5, 6, 7, 6, 2, 5], [3, 2, 4, 7, 3, 3, 2, 4, 7, 3, 3, 2, 4, 7, 3]]}]}"
U3XrzmGtvRTUGovj7m4frB,2025-07-21T15:52:22.808014,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 4, 6, 5, 6], [4, 9, 2, 3, 4], [7, 6, 4, 5, 9], [8, 3, 9, 6, 8], [5, 4, 6, 8, 1]], ""output"": [[8, 4, 6, 5, 6, 8, 4, 6, 5, 6, 8, 4, 6, 5, 6], [4, 9, 2, 3, 4, 4, 9, 2, 3, 4, 4, 9, 2, 3, 4], [7, 6, 4, 5, 9, 7, 6, 4, 5, 9, 7, 6, 4, 5, 9], [8, 3, 9, 6, 8, 8, 3, 9, 6, 8, 8, 3, 9, 6, 8], [5, 4, 6, 8, 1, 5, 4, 6, 8, 1, 5, 4, 6, 8, 1], [6, 4, 6, 5, 8, 6, 4, 6, 5, 8, 6, 4, 6, 5, 8], [4, 9, 2, 3, 4, 4, 9, 2, 3, 4, 4, 9, 2, 3, 4], [9, 6, 4, 5, 7, 9, 6, 4, 5, 7, 9, 6, 4, 5, 7], [8, 3, 9, 6, 8, 8, 3, 9, 6, 8, 8, 3, 9, 6, 8], [1, 4, 6, 8, 5, 1, 4, 6, 8, 5, 1, 4, 6, 8, 5], [8, 4, 6, 5, 6, 8, 4, 6, 5, 6, 8, 4, 6, 5, 6], [4, 9, 2, 3, 4, 4, 9, 2, 3, 4, 4, 9, 2, 3, 4], [7, 6, 4, 5, 9, 7, 6, 4, 5, 9, 7, 6, 4, 5, 9], [8, 3, 9, 6, 8, 8, 3, 9, 6, 8, 8, 3, 9, 6, 8], [5, 4, 6, 8, 1, 5, 4, 6, 8, 1, 5, 4, 6, 8, 1]]}, {""input"": [[9, 6, 2, 5, 3], [8, 4, 3, 6, 4], [2, 3, 7, 2, 7], [9, 4, 6, 9, 5], [3, 6, 2, 5, 2]], ""output"": [[9, 6, 2, 5, 3, 9, 6, 2, 5, 3, 9, 6, 2, 5, 3], [8, 4, 3, 6, 4, 8, 4, 3, 6, 4, 8, 4, 3, 6, 4], [2, 3, 7, 2, 7, 2, 3, 7, 2, 7, 2, 3, 7, 2, 7], [9, 4, 6, 9, 5, 9, 4, 6, 9, 5, 9, 4, 6, 9, 5], [3, 6, 2, 5, 2, 3, 6, 2, 5, 2, 3, 6, 2, 5, 2], [3, 6, 2, 5, 9, 3, 6, 2, 5, 9, 3, 6, 2, 5, 9], [4, 4, 3, 6, 8, 4, 4, 3, 6, 8, 4, 4, 3, 6, 8], [7, 3, 7, 2, 2, 7, 3, 7, 2, 2, 7, 3, 7, 2, 2], [5, 4, 6, 9, 9, 5, 4, 6, 9, 9, 5, 4, 6, 9, 9], [2, 6, 2, 5, 3, 2, 6, 2, 5, 3, 2, 6, 2, 5, 3], [9, 6, 2, 5, 3, 9, 6, 2, 5, 3, 9, 6, 2, 5, 3], [8, 4, 3, 6, 4, 8, 4, 3, 6, 4, 8, 4, 3, 6, 4], [2, 3, 7, 2, 7, 2, 3, 7, 2, 7, 2, 3, 7, 2, 7], [9, 4, 6, 9, 5, 9, 4, 6, 9, 5, 9, 4, 6, 9, 5], [3, 6, 2, 5, 2, 3, 6, 2, 5, 2, 3, 6, 2, 5, 2]]}, {""input"": [[4, 9, 3, 7, 4], [5, 4, 2, 5, 6], [7, 5, 3, 6, 8], [3, 2, 5, 9, 2], [4, 8, 4, 8, 9]], ""output"": [[4, 9, 3, 7, 4, 4, 9, 3, 7, 4, 4, 9, 3, 7, 4], [5, 4, 2, 5, 6, 5, 4, 2, 5, 6, 5, 4, 2, 5, 6], [7, 5, 3, 6, 8, 7, 5, 3, 6, 8, 7, 5, 3, 6, 8], [3, 2, 5, 9, 2, 3, 2, 5, 9, 2, 3, 2, 5, 9, 2], [4, 8, 4, 8, 9, 4, 8, 4, 8, 9, 4, 8, 4, 8, 9], [4, 9, 3, 7, 4, 4, 9, 3, 7, 4, 4, 9, 3, 7, 4], [6, 4, 2, 5, 5, 6, 4, 2, 5, 5, 6, 4, 2, 5, 5], [8, 5, 3, 6, 7, 8, 5, 3, 6, 7, 8, 5, 3, 6, 7], [2, 2, 5, 9, 3, 2, 2, 5, 9, 3, 2, 2, 5, 9, 3], [9, 8, 4, 8, 4, 9, 8, 4, 8, 4, 9, 8, 4, 8, 4], [4, 9, 3, 7, 4, 4, 9, 3, 7, 4, 4, 9, 3, 7, 4], [5, 4, 2, 5, 6, 5, 4, 2, 5, 6, 5, 4, 2, 5, 6], [7, 5, 3, 6, 8, 7, 5, 3, 6, 8, 7, 5, 3, 6, 8], [3, 2, 5, 9, 2, 3, 2, 5, 9, 2, 3, 2, 5, 9, 2], [4, 8, 4, 8, 9, 4, 8, 4, 8, 9, 4, 8, 4, 8, 9]]}], ""test"": [{""input"": [[9, 7, 8, 7, 2], [3, 4, 5, 2, 7], [4, 3, 8, 9, 3], [5, 9, 2, 7, 5], [7, 2, 6, 2, 3]], ""output"": [[9, 7, 8, 7, 2, 9, 7, 8, 7, 2, 9, 7, 8, 7, 2], [3, 4, 5, 2, 7, 3, 4, 5, 2, 7, 3, 4, 5, 2, 7], [4, 3, 8, 9, 3, 4, 3, 8, 9, 3, 4, 3, 8, 9, 3], [5, 9, 2, 7, 5, 5, 9, 2, 7, 5, 5, 9, 2, 7, 5], [7, 2, 6, 2, 3, 7, 2, 6, 2, 3, 7, 2, 6, 2, 3], [2, 7, 8, 7, 9, 2, 7, 8, 7, 9, 2, 7, 8, 7, 9], [7, 4, 5, 2, 3, 7, 4, 5, 2, 3, 7, 4, 5, 2, 3], [3, 3, 8, 9, 4, 3, 3, 8, 9, 4, 3, 3, 8, 9, 4], [5, 9, 2, 7, 5, 5, 9, 2, 7, 5, 5, 9, 2, 7, 5], [3, 2, 6, 2, 7, 3, 2, 6, 2, 7, 3, 2, 6, 2, 7], [9, 7, 8, 7, 2, 9, 7, 8, 7, 2, 9, 7, 8, 7, 2], [3, 4, 5, 2, 7, 3, 4, 5, 2, 7, 3, 4, 5, 2, 7], [4, 3, 8, 9, 3, 4, 3, 8, 9, 3, 4, 3, 8, 9, 3], [5, 9, 2, 7, 5, 5, 9, 2, 7, 5, 5, 9, 2, 7, 5], [7, 2, 6, 2, 3, 7, 2, 6, 2, 3, 7, 2, 6, 2, 3]]}]}"
mbsUjHXhDRioZHPy5Cy8ZQ,2025-07-21T15:52:22.810110,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 3, 9, 5], [4, 6, 7, 3], [2, 5, 6, 9], [6, 2, 7, 5]], ""output"": [[8, 3, 9, 5, 8, 3, 9, 5, 8, 3, 9, 5], [4, 6, 7, 3, 4, 6, 7, 3, 4, 6, 7, 3], [2, 5, 6, 9, 2, 5, 6, 9, 2, 5, 6, 9], [6, 2, 7, 5, 6, 2, 7, 5, 6, 2, 7, 5], [5, 3, 9, 8, 5, 3, 9, 8, 5, 3, 9, 8], [3, 6, 7, 4, 3, 6, 7, 4, 3, 6, 7, 4], [9, 5, 6, 2, 9, 5, 6, 2, 9, 5, 6, 2], [5, 2, 7, 6, 5, 2, 7, 6, 5, 2, 7, 6], [8, 3, 9, 5, 8, 3, 9, 5, 8, 3, 9, 5], [4, 6, 7, 3, 4, 6, 7, 3, 4, 6, 7, 3], [2, 5, 6, 9, 2, 5, 6, 9, 2, 5, 6, 9], [6, 2, 7, 5, 6, 2, 7, 5, 6, 2, 7, 5]]}, {""input"": [[2, 9, 6, 7], [6, 3, 5, 4], [2, 9, 6, 8], [5, 8, 7, 5]], ""output"": [[2, 9, 6, 7, 2, 9, 6, 7, 2, 9, 6, 7], [6, 3, 5, 4, 6, 3, 5, 4, 6, 3, 5, 4], [2, 9, 6, 8, 2, 9, 6, 8, 2, 9, 6, 8], [5, 8, 7, 5, 5, 8, 7, 5, 5, 8, 7, 5], [7, 9, 6, 2, 7, 9, 6, 2, 7, 9, 6, 2], [4, 3, 5, 6, 4, 3, 5, 6, 4, 3, 5, 6], [8, 9, 6, 2, 8, 9, 6, 2, 8, 9, 6, 2], [5, 8, 7, 5, 5, 8, 7, 5, 5, 8, 7, 5], [2, 9, 6, 7, 2, 9, 6, 7, 2, 9, 6, 7], [6, 3, 5, 4, 6, 3, 5, 4, 6, 3, 5, 4], [2, 9, 6, 8, 2, 9, 6, 8, 2, 9, 6, 8], [5, 8, 7, 5, 5, 8, 7, 5, 5, 8, 7, 5]]}, {""input"": [[3, 6, 2, 4], [2, 8, 4, 8], [8, 7, 9, 3], [3, 4, 3, 7]], ""output"": [[3, 6, 2, 4, 3, 6, 2, 4, 3, 6, 2, 4], [2, 8, 4, 8, 2, 8, 4, 8, 2, 8, 4, 8], [8, 7, 9, 3, 8, 7, 9, 3, 8, 7, 9, 3], [3, 4, 3, 7, 3, 4, 3, 7, 3, 4, 3, 7], [4, 6, 2, 3, 4, 6, 2, 3, 4, 6, 2, 3], [8, 8, 4, 2, 8, 8, 4, 2, 8, 8, 4, 2], [3, 7, 9, 8, 3, 7, 9, 8, 3, 7, 9, 8], [7, 4, 3, 3, 7, 4, 3, 3, 7, 4, 3, 3], [3, 6, 2, 4, 3, 6, 2, 4, 3, 6, 2, 4], [2, 8, 4, 8, 2, 8, 4, 8, 2, 8, 4, 8], [8, 7, 9, 3, 8, 7, 9, 3, 8, 7, 9, 3], [3, 4, 3, 7, 3, 4, 3, 7, 3, 4, 3, 7]]}], ""test"": [{""input"": [[4, 5, 3, 9], [5, 4, 9, 4], [6, 9, 8, 2], [2, 3, 2, 3]], ""output"": [[4, 5, 3, 9, 4, 5, 3, 9, 4, 5, 3, 9], [5, 4, 9, 4, 5, 4, 9, 4, 5, 4, 9, 4], [6, 9, 8, 2, 6, 9, 8, 2, 6, 9, 8, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [9, 5, 3, 4, 9, 5, 3, 4, 9, 5, 3, 4], [4, 4, 9, 5, 4, 4, 9, 5, 4, 4, 9, 5], [2, 9, 8, 6, 2, 9, 8, 6, 2, 9, 8, 6], [3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2], [4, 5, 3, 9, 4, 5, 3, 9, 4, 5, 3, 9], [5, 4, 9, 4, 5, 4, 9, 4, 5, 4, 9, 4], [6, 9, 8, 2, 6, 9, 8, 2, 6, 9, 8, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3]]}]}"
P3KdJv37C3H99prvJDwJnA,2025-07-21T15:52:22.811944,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 8, 3], [8, 4, 7], [2, 9, 4]], ""output"": [[2, 8, 3, 2, 8, 3, 2, 8, 3], [8, 4, 7, 8, 4, 7, 8, 4, 7], [2, 9, 4, 2, 9, 4, 2, 9, 4], [3, 8, 2, 3, 8, 2, 3, 8, 2], [7, 4, 8, 7, 4, 8, 7, 4, 8], [4, 9, 2, 4, 9, 2, 4, 9, 2], [2, 8, 3, 2, 8, 3, 2, 8, 3], [8, 4, 7, 8, 4, 7, 8, 4, 7], [2, 9, 4, 2, 9, 4, 2, 9, 4]]}, {""input"": [[2, 7, 9], [8, 5, 8], [7, 4, 6]], ""output"": [[2, 7, 9, 2, 7, 9, 2, 7, 9], [8, 5, 8, 8, 5, 8, 8, 5, 8], [7, 4, 6, 7, 4, 6, 7, 4, 6], [9, 7, 2, 9, 7, 2, 9, 7, 2], [8, 5, 8, 8, 5, 8, 8, 5, 8], [6, 4, 7, 6, 4, 7, 6, 4, 7], [2, 7, 9, 2, 7, 9, 2, 7, 9], [8, 5, 8, 8, 5, 8, 8, 5, 8], [7, 4, 6, 7, 4, 6, 7, 4, 6]]}, {""input"": [[6, 3, 7], [2, 8, 4], [8, 6, 1]], ""output"": [[6, 3, 7, 6, 3, 7, 6, 3, 7], [2, 8, 4, 2, 8, 4, 2, 8, 4], [8, 6, 1, 8, 6, 1, 8, 6, 1], [7, 3, 6, 7, 3, 6, 7, 3, 6], [4, 8, 2, 4, 8, 2, 4, 8, 2], [1, 6, 8, 1, 6, 8, 1, 6, 8], [6, 3, 7, 6, 3, 7, 6, 3, 7], [2, 8, 4, 2, 8, 4, 2, 8, 4], [8, 6, 1, 8, 6, 1, 8, 6, 1]]}], ""test"": [{""input"": [[9, 5, 7], [7, 9, 2], [3, 5, 1]], ""output"": [[9, 5, 7, 9, 5, 7, 9, 5, 7], [7, 9, 2, 7, 9, 2, 7, 9, 2], [3, 5, 1, 3, 5, 1, 3, 5, 1], [7, 5, 9, 7, 5, 9, 7, 5, 9], [2, 9, 7, 2, 9, 7, 2, 9, 7], [1, 5, 3, 1, 5, 3, 1, 5, 3], [9, 5, 7, 9, 5, 7, 9, 5, 7], [7, 9, 2, 7, 9, 2, 7, 9, 2], [3, 5, 1, 3, 5, 1, 3, 5, 1]]}]}"
WhcamARSSZqD57CWMYbVNY,2025-07-21T15:52:22.814303,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 3, 7, 3, 2, 9], [3, 9, 4, 5, 9, 2], [7, 6, 7, 4, 3, 7], [5, 8, 9, 8, 6, 5], [7, 3, 8, 4, 8, 9], [3, 9, 3, 5, 7, 5]], ""output"": [[8, 3, 7, 3, 2, 9, 8, 3, 7, 3, 2, 9, 8, 3, 7, 3, 2, 9], [3, 9, 4, 5, 9, 2, 3, 9, 4, 5, 9, 2, 3, 9, 4, 5, 9, 2], [7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7], [5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5], [7, 3, 8, 4, 8, 9, 7, 3, 8, 4, 8, 9, 7, 3, 8, 4, 8, 9], [3, 9, 3, 5, 7, 5, 3, 9, 3, 5, 7, 5, 3, 9, 3, 5, 7, 5], [9, 3, 7, 3, 2, 8, 9, 3, 7, 3, 2, 8, 9, 3, 7, 3, 2, 8], [2, 9, 4, 5, 9, 3, 2, 9, 4, 5, 9, 3, 2, 9, 4, 5, 9, 3], [7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7], [5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5], [9, 3, 8, 4, 8, 7, 9, 3, 8, 4, 8, 7, 9, 3, 8, 4, 8, 7], [5, 9, 3, 5, 7, 3, 5, 9, 3, 5, 7, 3, 5, 9, 3, 5, 7, 3], [8, 3, 7, 3, 2, 9, 8, 3, 7, 3, 2, 9, 8, 3, 7, 3, 2, 9], [3, 9, 4, 5, 9, 2, 3, 9, 4, 5, 9, 2, 3, 9, 4, 5, 9, 2], [7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7, 7, 6, 7, 4, 3, 7], [5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5, 5, 8, 9, 8, 6, 5], [7, 3, 8, 4, 8, 9, 7, 3, 8, 4, 8, 9, 7, 3, 8, 4, 8, 9], [3, 9, 3, 5, 7, 5, 3, 9, 3, 5, 7, 5, 3, 9, 3, 5, 7, 5]]}, {""input"": [[8, 2, 9, 3, 7, 6], [9, 3, 4, 6, 9, 2], [7, 2, 7, 5, 3, 7], [5, 8, 3, 7, 9, 2], [9, 5, 8, 5, 2, 3], [7, 9, 4, 3, 5, 8]], ""output"": [[8, 2, 9, 3, 7, 6, 8, 2, 9, 3, 7, 6, 8, 2, 9, 3, 7, 6], [9, 3, 4, 6, 9, 2, 9, 3, 4, 6, 9, 2, 9, 3, 4, 6, 9, 2], [7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7], [5, 8, 3, 7, 9, 2, 5, 8, 3, 7, 9, 2, 5, 8, 3, 7, 9, 2], [9, 5, 8, 5, 2, 3, 9, 5, 8, 5, 2, 3, 9, 5, 8, 5, 2, 3], [7, 9, 4, 3, 5, 8, 7, 9, 4, 3, 5, 8, 7, 9, 4, 3, 5, 8], [6, 2, 9, 3, 7, 8, 6, 2, 9, 3, 7, 8, 6, 2, 9, 3, 7, 8], [2, 3, 4, 6, 9, 9, 2, 3, 4, 6, 9, 9, 2, 3, 4, 6, 9, 9], [7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7], [2, 8, 3, 7, 9, 5, 2, 8, 3, 7, 9, 5, 2, 8, 3, 7, 9, 5], [3, 5, 8, 5, 2, 9, 3, 5, 8, 5, 2, 9, 3, 5, 8, 5, 2, 9], [8, 9, 4, 3, 5, 7, 8, 9, 4, 3, 5, 7, 8, 9, 4, 3, 5, 7], [8, 2, 9, 3, 7, 6, 8, 2, 9, 3, 7, 6, 8, 2, 9, 3, 7, 6], [9, 3, 4, 6, 9, 2, 9, 3, 4, 6, 9, 2, 9, 3, 4, 6, 9, 2], [7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7, 7, 2, 7, 5, 3, 7], [5, 8, 3, 7, 9, 2, 5, 8, 3, 7, 9, 2, 5, 8, 3, 7, 9, 2], [9, 5, 8, 5, 2, 3, 9, 5, 8, 5, 2, 3, 9, 5, 8, 5, 2, 3], [7, 9, 4, 3, 5, 8, 7, 9, 4, 3, 5, 8, 7, 9, 4, 3, 5, 8]]}, {""input"": [[8, 4, 8, 3, 6, 8], [5, 6, 7, 8, 7, 2], [4, 2, 3, 2, 8, 7], [5, 8, 4, 8, 2, 3], [6, 9, 3, 6, 4, 7], [4, 8, 2, 3, 2, 8]], ""output"": [[8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8], [5, 6, 7, 8, 7, 2, 5, 6, 7, 8, 7, 2, 5, 6, 7, 8, 7, 2], [4, 2, 3, 2, 8, 7, 4, 2, 3, 2, 8, 7, 4, 2, 3, 2, 8, 7], [5, 8, 4, 8, 2, 3, 5, 8, 4, 8, 2, 3, 5, 8, 4, 8, 2, 3], [6, 9, 3, 6, 4, 7, 6, 9, 3, 6, 4, 7, 6, 9, 3, 6, 4, 7], [4, 8, 2, 3, 2, 8, 4, 8, 2, 3, 2, 8, 4, 8, 2, 3, 2, 8], [8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8], [2, 6, 7, 8, 7, 5, 2, 6, 7, 8, 7, 5, 2, 6, 7, 8, 7, 5], [7, 2, 3, 2, 8, 4, 7, 2, 3, 2, 8, 4, 7, 2, 3, 2, 8, 4], [3, 8, 4, 8, 2, 5, 3, 8, 4, 8, 2, 5, 3, 8, 4, 8, 2, 5], [7, 9, 3, 6, 4, 6, 7, 9, 3, 6, 4, 6, 7, 9, 3, 6, 4, 6], [8, 8, 2, 3, 2, 4, 8, 8, 2, 3, 2, 4, 8, 8, 2, 3, 2, 4], [8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8, 8, 4, 8, 3, 6, 8], [5, 6, 7, 8, 7, 2, 5, 6, 7, 8, 7, 2, 5, 6, 7, 8, 7, 2], [4, 2, 3, 2, 8, 7, 4, 2, 3, 2, 8, 7, 4, 2, 3, 2, 8, 7], [5, 8, 4, 8, 2, 3, 5, 8, 4, 8, 2, 3, 5, 8, 4, 8, 2, 3], [6, 9, 3, 6, 4, 7, 6, 9, 3, 6, 4, 7, 6, 9, 3, 6, 4, 7], [4, 8, 2, 3, 2, 8, 4, 8, 2, 3, 2, 8, 4, 8, 2, 3, 2, 8]]}], ""test"": [{""input"": [[3, 2, 8, 2, 3, 4], [5, 4, 2, 5, 4, 5], [4, 5, 3, 2, 9, 6], [7, 6, 9, 6, 3, 4], [3, 2, 7, 5, 4, 3], [2, 3, 5, 4, 3, 1]], ""output"": [[3, 2, 8, 2, 3, 4, 3, 2, 8, 2, 3, 4, 3, 2, 8, 2, 3, 4], [5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5], [4, 5, 3, 2, 9, 6, 4, 5, 3, 2, 9, 6, 4, 5, 3, 2, 9, 6], [7, 6, 9, 6, 3, 4, 7, 6, 9, 6, 3, 4, 7, 6, 9, 6, 3, 4], [3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3], [2, 3, 5, 4, 3, 1, 2, 3, 5, 4, 3, 1, 2, 3, 5, 4, 3, 1], [4, 2, 8, 2, 3, 3, 4, 2, 8, 2, 3, 3, 4, 2, 8, 2, 3, 3], [5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5], [6, 5, 3, 2, 9, 4, 6, 5, 3, 2, 9, 4, 6, 5, 3, 2, 9, 4], [4, 6, 9, 6, 3, 7, 4, 6, 9, 6, 3, 7, 4, 6, 9, 6, 3, 7], [3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3], [1, 3, 5, 4, 3, 2, 1, 3, 5, 4, 3, 2, 1, 3, 5, 4, 3, 2], [3, 2, 8, 2, 3, 4, 3, 2, 8, 2, 3, 4, 3, 2, 8, 2, 3, 4], [5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5, 5, 4, 2, 5, 4, 5], [4, 5, 3, 2, 9, 6, 4, 5, 3, 2, 9, 6, 4, 5, 3, 2, 9, 6], [7, 6, 9, 6, 3, 4, 7, 6, 9, 6, 3, 4, 7, 6, 9, 6, 3, 4], [3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3, 3, 2, 7, 5, 4, 3], [2, 3, 5, 4, 3, 1, 2, 3, 5, 4, 3, 1, 2, 3, 5, 4, 3, 1]]}]}"
AZGZZUKYpvV8bh8ubLnm3d,2025-07-21T15:52:22.816413,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 7, 6], [8, 9, 2], [2, 7, 3]], ""output"": [[5, 7, 6, 5, 7, 6, 5, 7, 6], [8, 9, 2, 8, 9, 2, 8, 9, 2], [2, 7, 3, 2, 7, 3, 2, 7, 3], [6, 7, 5, 6, 7, 5, 6, 7, 5], [2, 9, 8, 2, 9, 8, 2, 9, 8], [3, 7, 2, 3, 7, 2, 3, 7, 2], [5, 7, 6, 5, 7, 6, 5, 7, 6], [8, 9, 2, 8, 9, 2, 8, 9, 2], [2, 7, 3, 2, 7, 3, 2, 7, 3]]}, {""input"": [[9, 7, 8], [3, 5, 4], [6, 2, 3]], ""output"": [[9, 7, 8, 9, 7, 8, 9, 7, 8], [3, 5, 4, 3, 5, 4, 3, 5, 4], [6, 2, 3, 6, 2, 3, 6, 2, 3], [8, 7, 9, 8, 7, 9, 8, 7, 9], [4, 5, 3, 4, 5, 3, 4, 5, 3], [3, 2, 6, 3, 2, 6, 3, 2, 6], [9, 7, 8, 9, 7, 8, 9, 7, 8], [3, 5, 4, 3, 5, 4, 3, 5, 4], [6, 2, 3, 6, 2, 3, 6, 2, 3]]}, {""input"": [[2, 5, 7], [8, 9, 5], [6, 7, 1]], ""output"": [[2, 5, 7, 2, 5, 7, 2, 5, 7], [8, 9, 5, 8, 9, 5, 8, 9, 5], [6, 7, 1, 6, 7, 1, 6, 7, 1], [7, 5, 2, 7, 5, 2, 7, 5, 2], [5, 9, 8, 5, 9, 8, 5, 9, 8], [1, 7, 6, 1, 7, 6, 1, 7, 6], [2, 5, 7, 2, 5, 7, 2, 5, 7], [8, 9, 5, 8, 9, 5, 8, 9, 5], [6, 7, 1, 6, 7, 1, 6, 7, 1]]}], ""test"": [{""input"": [[9, 3, 7], [2, 5, 8], [9, 2, 3]], ""output"": [[9, 3, 7, 9, 3, 7, 9, 3, 7], [2, 5, 8, 2, 5, 8, 2, 5, 8], [9, 2, 3, 9, 2, 3, 9, 2, 3], [7, 3, 9, 7, 3, 9, 7, 3, 9], [8, 5, 2, 8, 5, 2, 8, 5, 2], [3, 2, 9, 3, 2, 9, 3, 2, 9], [9, 3, 7, 9, 3, 7, 9, 3, 7], [2, 5, 8, 2, 5, 8, 2, 5, 8], [9, 2, 3, 9, 2, 3, 9, 2, 3]]}]}"
KRjSoZeXjkLFSMCX3BcFpg,2025-07-21T15:52:22.818184,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 4, 3], [9, 7, 4], [2, 8, 6]], ""output"": [[5, 4, 3, 5, 4, 3, 5, 4, 3], [9, 7, 4, 9, 7, 4, 9, 7, 4], [2, 8, 6, 2, 8, 6, 2, 8, 6], [3, 4, 5, 3, 4, 5, 3, 4, 5], [4, 7, 9, 4, 7, 9, 4, 7, 9], [6, 8, 2, 6, 8, 2, 6, 8, 2], [5, 4, 3, 5, 4, 3, 5, 4, 3], [9, 7, 4, 9, 7, 4, 9, 7, 4], [2, 8, 6, 2, 8, 6, 2, 8, 6]]}, {""input"": [[9, 7, 4], [3, 2, 8], [6, 9, 1]], ""output"": [[9, 7, 4, 9, 7, 4, 9, 7, 4], [3, 2, 8, 3, 2, 8, 3, 2, 8], [6, 9, 1, 6, 9, 1, 6, 9, 1], [4, 7, 9, 4, 7, 9, 4, 7, 9], [8, 2, 3, 8, 2, 3, 8, 2, 3], [1, 9, 6, 1, 9, 6, 1, 9, 6], [9, 7, 4, 9, 7, 4, 9, 7, 4], [3, 2, 8, 3, 2, 8, 3, 2, 8], [6, 9, 1, 6, 9, 1, 6, 9, 1]]}, {""input"": [[2, 5, 6], [5, 7, 8], [6, 2, 5]], ""output"": [[2, 5, 6, 2, 5, 6, 2, 5, 6], [5, 7, 8, 5, 7, 8, 5, 7, 8], [6, 2, 5, 6, 2, 5, 6, 2, 5], [6, 5, 2, 6, 5, 2, 6, 5, 2], [8, 7, 5, 8, 7, 5, 8, 7, 5], [5, 2, 6, 5, 2, 6, 5, 2, 6], [2, 5, 6, 2, 5, 6, 2, 5, 6], [5, 7, 8, 5, 7, 8, 5, 7, 8], [6, 2, 5, 6, 2, 5, 6, 2, 5]]}], ""test"": [{""input"": [[6, 7, 6], [3, 6, 4], [6, 8, 9]], ""output"": [[6, 7, 6, 6, 7, 6, 6, 7, 6], [3, 6, 4, 3, 6, 4, 3, 6, 4], [6, 8, 9, 6, 8, 9, 6, 8, 9], [6, 7, 6, 6, 7, 6, 6, 7, 6], [4, 6, 3, 4, 6, 3, 4, 6, 3], [9, 8, 6, 9, 8, 6, 9, 8, 6], [6, 7, 6, 6, 7, 6, 6, 7, 6], [3, 6, 4, 3, 6, 4, 3, 6, 4], [6, 8, 9, 6, 8, 9, 6, 8, 9]]}]}"
UAX4hTr8Fo8AmLPMuHFUZU,2025-07-21T15:52:22.820582,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 7, 4, 7, 6, 7], [7, 5, 7, 5, 2, 6], [6, 8, 2, 9, 6, 8], [2, 3, 4, 2, 3, 7], [7, 5, 3, 5, 4, 6], [8, 4, 2, 4, 2, 4]], ""output"": [[2, 7, 4, 7, 6, 7, 2, 7, 4, 7, 6, 7, 2, 7, 4, 7, 6, 7], [7, 5, 7, 5, 2, 6, 7, 5, 7, 5, 2, 6, 7, 5, 7, 5, 2, 6], [6, 8, 2, 9, 6, 8, 6, 8, 2, 9, 6, 8, 6, 8, 2, 9, 6, 8], [2, 3, 4, 2, 3, 7, 2, 3, 4, 2, 3, 7, 2, 3, 4, 2, 3, 7], [7, 5, 3, 5, 4, 6, 7, 5, 3, 5, 4, 6, 7, 5, 3, 5, 4, 6], [8, 4, 2, 4, 2, 4, 8, 4, 2, 4, 2, 4, 8, 4, 2, 4, 2, 4], [7, 7, 4, 7, 6, 2, 7, 7, 4, 7, 6, 2, 7, 7, 4, 7, 6, 2], [6, 5, 7, 5, 2, 7, 6, 5, 7, 5, 2, 7, 6, 5, 7, 5, 2, 7], [8, 8, 2, 9, 6, 6, 8, 8, 2, 9, 6, 6, 8, 8, 2, 9, 6, 6], [7, 3, 4, 2, 3, 2, 7, 3, 4, 2, 3, 2, 7, 3, 4, 2, 3, 2], [6, 5, 3, 5, 4, 7, 6, 5, 3, 5, 4, 7, 6, 5, 3, 5, 4, 7], [4, 4, 2, 4, 2, 8, 4, 4, 2, 4, 2, 8, 4, 4, 2, 4, 2, 8], [2, 7, 4, 7, 6, 7, 2, 7, 4, 7, 6, 7, 2, 7, 4, 7, 6, 7], [7, 5, 7, 5, 2, 6, 7, 5, 7, 5, 2, 6, 7, 5, 7, 5, 2, 6], [6, 8, 2, 9, 6, 8, 6, 8, 2, 9, 6, 8, 6, 8, 2, 9, 6, 8], [2, 3, 4, 2, 3, 7, 2, 3, 4, 2, 3, 7, 2, 3, 4, 2, 3, 7], [7, 5, 3, 5, 4, 6, 7, 5, 3, 5, 4, 6, 7, 5, 3, 5, 4, 6], [8, 4, 2, 4, 2, 4, 8, 4, 2, 4, 2, 4, 8, 4, 2, 4, 2, 4]]}, {""input"": [[2, 4, 7, 3, 5, 2], [3, 9, 2, 6, 8, 7], [8, 7, 3, 2, 4, 8], [7, 4, 9, 7, 9, 6], [8, 9, 8, 5, 2, 3], [3, 6, 3, 7, 9, 4]], ""output"": [[2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2], [3, 9, 2, 6, 8, 7, 3, 9, 2, 6, 8, 7, 3, 9, 2, 6, 8, 7], [8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8], [7, 4, 9, 7, 9, 6, 7, 4, 9, 7, 9, 6, 7, 4, 9, 7, 9, 6], [8, 9, 8, 5, 2, 3, 8, 9, 8, 5, 2, 3, 8, 9, 8, 5, 2, 3], [3, 6, 3, 7, 9, 4, 3, 6, 3, 7, 9, 4, 3, 6, 3, 7, 9, 4], [2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2], [7, 9, 2, 6, 8, 3, 7, 9, 2, 6, 8, 3, 7, 9, 2, 6, 8, 3], [8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8], [6, 4, 9, 7, 9, 7, 6, 4, 9, 7, 9, 7, 6, 4, 9, 7, 9, 7], [3, 9, 8, 5, 2, 8, 3, 9, 8, 5, 2, 8, 3, 9, 8, 5, 2, 8], [4, 6, 3, 7, 9, 3, 4, 6, 3, 7, 9, 3, 4, 6, 3, 7, 9, 3], [2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2, 2, 4, 7, 3, 5, 2], [3, 9, 2, 6, 8, 7, 3, 9, 2, 6, 8, 7, 3, 9, 2, 6, 8, 7], [8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8, 8, 7, 3, 2, 4, 8], [7, 4, 9, 7, 9, 6, 7, 4, 9, 7, 9, 6, 7, 4, 9, 7, 9, 6], [8, 9, 8, 5, 2, 3, 8, 9, 8, 5, 2, 3, 8, 9, 8, 5, 2, 3], [3, 6, 3, 7, 9, 4, 3, 6, 3, 7, 9, 4, 3, 6, 3, 7, 9, 4]]}, {""input"": [[5, 8, 7, 5, 9, 4], [6, 3, 6, 9, 6, 9], [8, 6, 3, 6, 5, 2], [9, 8, 4, 3, 8, 5], [6, 2, 7, 9, 6, 4], [4, 3, 9, 7, 9, 8]], ""output"": [[5, 8, 7, 5, 9, 4, 5, 8, 7, 5, 9, 4, 5, 8, 7, 5, 9, 4], [6, 3, 6, 9, 6, 9, 6, 3, 6, 9, 6, 9, 6, 3, 6, 9, 6, 9], [8, 6, 3, 6, 5, 2, 8, 6, 3, 6, 5, 2, 8, 6, 3, 6, 5, 2], [9, 8, 4, 3, 8, 5, 9, 8, 4, 3, 8, 5, 9, 8, 4, 3, 8, 5], [6, 2, 7, 9, 6, 4, 6, 2, 7, 9, 6, 4, 6, 2, 7, 9, 6, 4], [4, 3, 9, 7, 9, 8, 4, 3, 9, 7, 9, 8, 4, 3, 9, 7, 9, 8], [4, 8, 7, 5, 9, 5, 4, 8, 7, 5, 9, 5, 4, 8, 7, 5, 9, 5], [9, 3, 6, 9, 6, 6, 9, 3, 6, 9, 6, 6, 9, 3, 6, 9, 6, 6], [2, 6, 3, 6, 5, 8, 2, 6, 3, 6, 5, 8, 2, 6, 3, 6, 5, 8], [5, 8, 4, 3, 8, 9, 5, 8, 4, 3, 8, 9, 5, 8, 4, 3, 8, 9], [4, 2, 7, 9, 6, 6, 4, 2, 7, 9, 6, 6, 4, 2, 7, 9, 6, 6], [8, 3, 9, 7, 9, 4, 8, 3, 9, 7, 9, 4, 8, 3, 9, 7, 9, 4], [5, 8, 7, 5, 9, 4, 5, 8, 7, 5, 9, 4, 5, 8, 7, 5, 9, 4], [6, 3, 6, 9, 6, 9, 6, 3, 6, 9, 6, 9, 6, 3, 6, 9, 6, 9], [8, 6, 3, 6, 5, 2, 8, 6, 3, 6, 5, 2, 8, 6, 3, 6, 5, 2], [9, 8, 4, 3, 8, 5, 9, 8, 4, 3, 8, 5, 9, 8, 4, 3, 8, 5], [6, 2, 7, 9, 6, 4, 6, 2, 7, 9, 6, 4, 6, 2, 7, 9, 6, 4], [4, 3, 9, 7, 9, 8, 4, 3, 9, 7, 9, 8, 4, 3, 9, 7, 9, 8]]}], ""test"": [{""input"": [[5, 3, 8, 4, 8, 7], [6, 4, 9, 2, 6, 3], [4, 9, 4, 6, 4, 6], [5, 8, 2, 7, 6, 5], [3, 2, 9, 3, 2, 3], [2, 3, 6, 4, 5, 9]], ""output"": [[5, 3, 8, 4, 8, 7, 5, 3, 8, 4, 8, 7, 5, 3, 8, 4, 8, 7], [6, 4, 9, 2, 6, 3, 6, 4, 9, 2, 6, 3, 6, 4, 9, 2, 6, 3], [4, 9, 4, 6, 4, 6, 4, 9, 4, 6, 4, 6, 4, 9, 4, 6, 4, 6], [5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5], [3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3], [2, 3, 6, 4, 5, 9, 2, 3, 6, 4, 5, 9, 2, 3, 6, 4, 5, 9], [7, 3, 8, 4, 8, 5, 7, 3, 8, 4, 8, 5, 7, 3, 8, 4, 8, 5], [3, 4, 9, 2, 6, 6, 3, 4, 9, 2, 6, 6, 3, 4, 9, 2, 6, 6], [6, 9, 4, 6, 4, 4, 6, 9, 4, 6, 4, 4, 6, 9, 4, 6, 4, 4], [5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5], [3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3], [9, 3, 6, 4, 5, 2, 9, 3, 6, 4, 5, 2, 9, 3, 6, 4, 5, 2], [5, 3, 8, 4, 8, 7, 5, 3, 8, 4, 8, 7, 5, 3, 8, 4, 8, 7], [6, 4, 9, 2, 6, 3, 6, 4, 9, 2, 6, 3, 6, 4, 9, 2, 6, 3], [4, 9, 4, 6, 4, 6, 4, 9, 4, 6, 4, 6, 4, 9, 4, 6, 4, 6], [5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5, 5, 8, 2, 7, 6, 5], [3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3, 3, 2, 9, 3, 2, 3], [2, 3, 6, 4, 5, 9, 2, 3, 6, 4, 5, 9, 2, 3, 6, 4, 5, 9]]}]}"
caa5vy6TMz3xFP2EXhdsfd,2025-07-21T15:52:22.823045,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 2, 9, 8, 7], [5, 8, 2, 6, 2], [8, 7, 6, 2, 4], [9, 2, 7, 8, 2], [8, 7, 3, 7, 4]], ""output"": [[6, 2, 9, 8, 7, 6, 2, 9, 8, 7, 6, 2, 9, 8, 7], [5, 8, 2, 6, 2, 5, 8, 2, 6, 2, 5, 8, 2, 6, 2], [8, 7, 6, 2, 4, 8, 7, 6, 2, 4, 8, 7, 6, 2, 4], [9, 2, 7, 8, 2, 9, 2, 7, 8, 2, 9, 2, 7, 8, 2], [8, 7, 3, 7, 4, 8, 7, 3, 7, 4, 8, 7, 3, 7, 4], [7, 2, 9, 8, 6, 7, 2, 9, 8, 6, 7, 2, 9, 8, 6], [2, 8, 2, 6, 5, 2, 8, 2, 6, 5, 2, 8, 2, 6, 5], [4, 7, 6, 2, 8, 4, 7, 6, 2, 8, 4, 7, 6, 2, 8], [2, 2, 7, 8, 9, 2, 2, 7, 8, 9, 2, 2, 7, 8, 9], [4, 7, 3, 7, 8, 4, 7, 3, 7, 8, 4, 7, 3, 7, 8], [6, 2, 9, 8, 7, 6, 2, 9, 8, 7, 6, 2, 9, 8, 7], [5, 8, 2, 6, 2, 5, 8, 2, 6, 2, 5, 8, 2, 6, 2], [8, 7, 6, 2, 4, 8, 7, 6, 2, 4, 8, 7, 6, 2, 4], [9, 2, 7, 8, 2, 9, 2, 7, 8, 2, 9, 2, 7, 8, 2], [8, 7, 3, 7, 4, 8, 7, 3, 7, 4, 8, 7, 3, 7, 4]]}, {""input"": [[4, 2, 9, 3, 8], [3, 5, 7, 4, 3], [7, 8, 5, 6, 2], [4, 7, 4, 3, 7], [9, 2, 5, 7, 1]], ""output"": [[4, 2, 9, 3, 8, 4, 2, 9, 3, 8, 4, 2, 9, 3, 8], [3, 5, 7, 4, 3, 3, 5, 7, 4, 3, 3, 5, 7, 4, 3], [7, 8, 5, 6, 2, 7, 8, 5, 6, 2, 7, 8, 5, 6, 2], [4, 7, 4, 3, 7, 4, 7, 4, 3, 7, 4, 7, 4, 3, 7], [9, 2, 5, 7, 1, 9, 2, 5, 7, 1, 9, 2, 5, 7, 1], [8, 2, 9, 3, 4, 8, 2, 9, 3, 4, 8, 2, 9, 3, 4], [3, 5, 7, 4, 3, 3, 5, 7, 4, 3, 3, 5, 7, 4, 3], [2, 8, 5, 6, 7, 2, 8, 5, 6, 7, 2, 8, 5, 6, 7], [7, 7, 4, 3, 4, 7, 7, 4, 3, 4, 7, 7, 4, 3, 4], [1, 2, 5, 7, 9, 1, 2, 5, 7, 9, 1, 2, 5, 7, 9], [4, 2, 9, 3, 8, 4, 2, 9, 3, 8, 4, 2, 9, 3, 8], [3, 5, 7, 4, 3, 3, 5, 7, 4, 3, 3, 5, 7, 4, 3], [7, 8, 5, 6, 2, 7, 8, 5, 6, 2, 7, 8, 5, 6, 2], [4, 7, 4, 3, 7, 4, 7, 4, 3, 7, 4, 7, 4, 3, 7], [9, 2, 5, 7, 1, 9, 2, 5, 7, 1, 9, 2, 5, 7, 1]]}, {""input"": [[9, 3, 4, 6, 2], [8, 9, 5, 9, 5], [7, 2, 8, 6, 2], [3, 9, 2, 9, 4], [9, 4, 5, 4, 7]], ""output"": [[9, 3, 4, 6, 2, 9, 3, 4, 6, 2, 9, 3, 4, 6, 2], [8, 9, 5, 9, 5, 8, 9, 5, 9, 5, 8, 9, 5, 9, 5], [7, 2, 8, 6, 2, 7, 2, 8, 6, 2, 7, 2, 8, 6, 2], [3, 9, 2, 9, 4, 3, 9, 2, 9, 4, 3, 9, 2, 9, 4], [9, 4, 5, 4, 7, 9, 4, 5, 4, 7, 9, 4, 5, 4, 7], [2, 3, 4, 6, 9, 2, 3, 4, 6, 9, 2, 3, 4, 6, 9], [5, 9, 5, 9, 8, 5, 9, 5, 9, 8, 5, 9, 5, 9, 8], [2, 2, 8, 6, 7, 2, 2, 8, 6, 7, 2, 2, 8, 6, 7], [4, 9, 2, 9, 3, 4, 9, 2, 9, 3, 4, 9, 2, 9, 3], [7, 4, 5, 4, 9, 7, 4, 5, 4, 9, 7, 4, 5, 4, 9], [9, 3, 4, 6, 2, 9, 3, 4, 6, 2, 9, 3, 4, 6, 2], [8, 9, 5, 9, 5, 8, 9, 5, 9, 5, 8, 9, 5, 9, 5], [7, 2, 8, 6, 2, 7, 2, 8, 6, 2, 7, 2, 8, 6, 2], [3, 9, 2, 9, 4, 3, 9, 2, 9, 4, 3, 9, 2, 9, 4], [9, 4, 5, 4, 7, 9, 4, 5, 4, 7, 9, 4, 5, 4, 7]]}], ""test"": [{""input"": [[9, 3, 7, 6, 2], [8, 4, 5, 4, 9], [2, 7, 4, 8, 4], [8, 9, 6, 2, 6], [2, 3, 9, 8, 9]], ""output"": [[9, 3, 7, 6, 2, 9, 3, 7, 6, 2, 9, 3, 7, 6, 2], [8, 4, 5, 4, 9, 8, 4, 5, 4, 9, 8, 4, 5, 4, 9], [2, 7, 4, 8, 4, 2, 7, 4, 8, 4, 2, 7, 4, 8, 4], [8, 9, 6, 2, 6, 8, 9, 6, 2, 6, 8, 9, 6, 2, 6], [2, 3, 9, 8, 9, 2, 3, 9, 8, 9, 2, 3, 9, 8, 9], [2, 3, 7, 6, 9, 2, 3, 7, 6, 9, 2, 3, 7, 6, 9], [9, 4, 5, 4, 8, 9, 4, 5, 4, 8, 9, 4, 5, 4, 8], [4, 7, 4, 8, 2, 4, 7, 4, 8, 2, 4, 7, 4, 8, 2], [6, 9, 6, 2, 8, 6, 9, 6, 2, 8, 6, 9, 6, 2, 8], [9, 3, 9, 8, 2, 9, 3, 9, 8, 2, 9, 3, 9, 8, 2], [9, 3, 7, 6, 2, 9, 3, 7, 6, 2, 9, 3, 7, 6, 2], [8, 4, 5, 4, 9, 8, 4, 5, 4, 9, 8, 4, 5, 4, 9], [2, 7, 4, 8, 4, 2, 7, 4, 8, 4, 2, 7, 4, 8, 4], [8, 9, 6, 2, 6, 8, 9, 6, 2, 6, 8, 9, 6, 2, 6], [2, 3, 9, 8, 9, 2, 3, 9, 8, 9, 2, 3, 9, 8, 9]]}]}"
GT9sDj6B3viG9j2Xgn65RC,2025-07-21T15:52:22.825926,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 6, 7, 4, 8, 6, 9], [5, 9, 4, 3, 9, 5, 2], [9, 3, 8, 6, 7, 8, 5], [3, 8, 5, 8, 2, 4, 6], [9, 2, 6, 4, 3, 2, 7], [5, 8, 2, 7, 5, 7, 2], [7, 5, 3, 4, 2, 5, 7]], ""output"": [[3, 6, 7, 4, 8, 6, 9, 3, 6, 7, 4, 8, 6, 9, 3, 6, 7, 4, 8, 6, 9], [5, 9, 4, 3, 9, 5, 2, 5, 9, 4, 3, 9, 5, 2, 5, 9, 4, 3, 9, 5, 2], [9, 3, 8, 6, 7, 8, 5, 9, 3, 8, 6, 7, 8, 5, 9, 3, 8, 6, 7, 8, 5], [3, 8, 5, 8, 2, 4, 6, 3, 8, 5, 8, 2, 4, 6, 3, 8, 5, 8, 2, 4, 6], [9, 2, 6, 4, 3, 2, 7, 9, 2, 6, 4, 3, 2, 7, 9, 2, 6, 4, 3, 2, 7], [5, 8, 2, 7, 5, 7, 2, 5, 8, 2, 7, 5, 7, 2, 5, 8, 2, 7, 5, 7, 2], [7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7], [9, 6, 7, 4, 8, 6, 3, 9, 6, 7, 4, 8, 6, 3, 9, 6, 7, 4, 8, 6, 3], [2, 9, 4, 3, 9, 5, 5, 2, 9, 4, 3, 9, 5, 5, 2, 9, 4, 3, 9, 5, 5], [5, 3, 8, 6, 7, 8, 9, 5, 3, 8, 6, 7, 8, 9, 5, 3, 8, 6, 7, 8, 9], [6, 8, 5, 8, 2, 4, 3, 6, 8, 5, 8, 2, 4, 3, 6, 8, 5, 8, 2, 4, 3], [7, 2, 6, 4, 3, 2, 9, 7, 2, 6, 4, 3, 2, 9, 7, 2, 6, 4, 3, 2, 9], [2, 8, 2, 7, 5, 7, 5, 2, 8, 2, 7, 5, 7, 5, 2, 8, 2, 7, 5, 7, 5], [7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7], [3, 6, 7, 4, 8, 6, 9, 3, 6, 7, 4, 8, 6, 9, 3, 6, 7, 4, 8, 6, 9], [5, 9, 4, 3, 9, 5, 2, 5, 9, 4, 3, 9, 5, 2, 5, 9, 4, 3, 9, 5, 2], [9, 3, 8, 6, 7, 8, 5, 9, 3, 8, 6, 7, 8, 5, 9, 3, 8, 6, 7, 8, 5], [3, 8, 5, 8, 2, 4, 6, 3, 8, 5, 8, 2, 4, 6, 3, 8, 5, 8, 2, 4, 6], [9, 2, 6, 4, 3, 2, 7, 9, 2, 6, 4, 3, 2, 7, 9, 2, 6, 4, 3, 2, 7], [5, 8, 2, 7, 5, 7, 2, 5, 8, 2, 7, 5, 7, 2, 5, 8, 2, 7, 5, 7, 2], [7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7, 7, 5, 3, 4, 2, 5, 7]]}, {""input"": [[8, 2, 6, 7, 6, 3, 2], [2, 3, 5, 2, 7, 6, 9], [9, 5, 7, 3, 5, 2, 8], [4, 9, 8, 5, 4, 6, 2], [3, 6, 2, 6, 9, 5, 6], [8, 4, 3, 7, 5, 3, 2], [3, 8, 4, 6, 3, 2, 3]], ""output"": [[8, 2, 6, 7, 6, 3, 2, 8, 2, 6, 7, 6, 3, 2, 8, 2, 6, 7, 6, 3, 2], [2, 3, 5, 2, 7, 6, 9, 2, 3, 5, 2, 7, 6, 9, 2, 3, 5, 2, 7, 6, 9], [9, 5, 7, 3, 5, 2, 8, 9, 5, 7, 3, 5, 2, 8, 9, 5, 7, 3, 5, 2, 8], [4, 9, 8, 5, 4, 6, 2, 4, 9, 8, 5, 4, 6, 2, 4, 9, 8, 5, 4, 6, 2], [3, 6, 2, 6, 9, 5, 6, 3, 6, 2, 6, 9, 5, 6, 3, 6, 2, 6, 9, 5, 6], [8, 4, 3, 7, 5, 3, 2, 8, 4, 3, 7, 5, 3, 2, 8, 4, 3, 7, 5, 3, 2], [3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3], [2, 2, 6, 7, 6, 3, 8, 2, 2, 6, 7, 6, 3, 8, 2, 2, 6, 7, 6, 3, 8], [9, 3, 5, 2, 7, 6, 2, 9, 3, 5, 2, 7, 6, 2, 9, 3, 5, 2, 7, 6, 2], [8, 5, 7, 3, 5, 2, 9, 8, 5, 7, 3, 5, 2, 9, 8, 5, 7, 3, 5, 2, 9], [2, 9, 8, 5, 4, 6, 4, 2, 9, 8, 5, 4, 6, 4, 2, 9, 8, 5, 4, 6, 4], [6, 6, 2, 6, 9, 5, 3, 6, 6, 2, 6, 9, 5, 3, 6, 6, 2, 6, 9, 5, 3], [2, 4, 3, 7, 5, 3, 8, 2, 4, 3, 7, 5, 3, 8, 2, 4, 3, 7, 5, 3, 8], [3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3], [8, 2, 6, 7, 6, 3, 2, 8, 2, 6, 7, 6, 3, 2, 8, 2, 6, 7, 6, 3, 2], [2, 3, 5, 2, 7, 6, 9, 2, 3, 5, 2, 7, 6, 9, 2, 3, 5, 2, 7, 6, 9], [9, 5, 7, 3, 5, 2, 8, 9, 5, 7, 3, 5, 2, 8, 9, 5, 7, 3, 5, 2, 8], [4, 9, 8, 5, 4, 6, 2, 4, 9, 8, 5, 4, 6, 2, 4, 9, 8, 5, 4, 6, 2], [3, 6, 2, 6, 9, 5, 6, 3, 6, 2, 6, 9, 5, 6, 3, 6, 2, 6, 9, 5, 6], [8, 4, 3, 7, 5, 3, 2, 8, 4, 3, 7, 5, 3, 2, 8, 4, 3, 7, 5, 3, 2], [3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3, 3, 8, 4, 6, 3, 2, 3]]}, {""input"": [[6, 4, 6, 5, 8, 2, 4], [4, 2, 4, 3, 7, 8, 7], [6, 8, 5, 2, 6, 2, 8], [3, 7, 8, 7, 4, 7, 6], [9, 6, 3, 5, 7, 9, 2], [2, 4, 7, 6, 5, 3, 4], [3, 7, 5, 8, 3, 9, 1]], ""output"": [[6, 4, 6, 5, 8, 2, 4, 6, 4, 6, 5, 8, 2, 4, 6, 4, 6, 5, 8, 2, 4], [4, 2, 4, 3, 7, 8, 7, 4, 2, 4, 3, 7, 8, 7, 4, 2, 4, 3, 7, 8, 7], [6, 8, 5, 2, 6, 2, 8, 6, 8, 5, 2, 6, 2, 8, 6, 8, 5, 2, 6, 2, 8], [3, 7, 8, 7, 4, 7, 6, 3, 7, 8, 7, 4, 7, 6, 3, 7, 8, 7, 4, 7, 6], [9, 6, 3, 5, 7, 9, 2, 9, 6, 3, 5, 7, 9, 2, 9, 6, 3, 5, 7, 9, 2], [2, 4, 7, 6, 5, 3, 4, 2, 4, 7, 6, 5, 3, 4, 2, 4, 7, 6, 5, 3, 4], [3, 7, 5, 8, 3, 9, 1, 3, 7, 5, 8, 3, 9, 1, 3, 7, 5, 8, 3, 9, 1], [4, 4, 6, 5, 8, 2, 6, 4, 4, 6, 5, 8, 2, 6, 4, 4, 6, 5, 8, 2, 6], [7, 2, 4, 3, 7, 8, 4, 7, 2, 4, 3, 7, 8, 4, 7, 2, 4, 3, 7, 8, 4], [8, 8, 5, 2, 6, 2, 6, 8, 8, 5, 2, 6, 2, 6, 8, 8, 5, 2, 6, 2, 6], [6, 7, 8, 7, 4, 7, 3, 6, 7, 8, 7, 4, 7, 3, 6, 7, 8, 7, 4, 7, 3], [2, 6, 3, 5, 7, 9, 9, 2, 6, 3, 5, 7, 9, 9, 2, 6, 3, 5, 7, 9, 9], [4, 4, 7, 6, 5, 3, 2, 4, 4, 7, 6, 5, 3, 2, 4, 4, 7, 6, 5, 3, 2], [1, 7, 5, 8, 3, 9, 3, 1, 7, 5, 8, 3, 9, 3, 1, 7, 5, 8, 3, 9, 3], [6, 4, 6, 5, 8, 2, 4, 6, 4, 6, 5, 8, 2, 4, 6, 4, 6, 5, 8, 2, 4], [4, 2, 4, 3, 7, 8, 7, 4, 2, 4, 3, 7, 8, 7, 4, 2, 4, 3, 7, 8, 7], [6, 8, 5, 2, 6, 2, 8, 6, 8, 5, 2, 6, 2, 8, 6, 8, 5, 2, 6, 2, 8], [3, 7, 8, 7, 4, 7, 6, 3, 7, 8, 7, 4, 7, 6, 3, 7, 8, 7, 4, 7, 6], [9, 6, 3, 5, 7, 9, 2, 9, 6, 3, 5, 7, 9, 2, 9, 6, 3, 5, 7, 9, 2], [2, 4, 7, 6, 5, 3, 4, 2, 4, 7, 6, 5, 3, 4, 2, 4, 7, 6, 5, 3, 4], [3, 7, 5, 8, 3, 9, 1, 3, 7, 5, 8, 3, 9, 1, 3, 7, 5, 8, 3, 9, 1]]}], ""test"": [{""input"": [[9, 7, 3, 8, 9, 8, 9], [4, 8, 6, 5, 2, 6, 7], [2, 6, 8, 3, 5, 8, 9], [3, 4, 2, 8, 4, 6, 3], [4, 2, 3, 2, 5, 3, 8], [5, 8, 7, 3, 8, 6, 4], [8, 4, 6, 4, 2, 9, 1]], ""output"": [[9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9], [4, 8, 6, 5, 2, 6, 7, 4, 8, 6, 5, 2, 6, 7, 4, 8, 6, 5, 2, 6, 7], [2, 6, 8, 3, 5, 8, 9, 2, 6, 8, 3, 5, 8, 9, 2, 6, 8, 3, 5, 8, 9], [3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3], [4, 2, 3, 2, 5, 3, 8, 4, 2, 3, 2, 5, 3, 8, 4, 2, 3, 2, 5, 3, 8], [5, 8, 7, 3, 8, 6, 4, 5, 8, 7, 3, 8, 6, 4, 5, 8, 7, 3, 8, 6, 4], [8, 4, 6, 4, 2, 9, 1, 8, 4, 6, 4, 2, 9, 1, 8, 4, 6, 4, 2, 9, 1], [9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9], [7, 8, 6, 5, 2, 6, 4, 7, 8, 6, 5, 2, 6, 4, 7, 8, 6, 5, 2, 6, 4], [9, 6, 8, 3, 5, 8, 2, 9, 6, 8, 3, 5, 8, 2, 9, 6, 8, 3, 5, 8, 2], [3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3], [8, 2, 3, 2, 5, 3, 4, 8, 2, 3, 2, 5, 3, 4, 8, 2, 3, 2, 5, 3, 4], [4, 8, 7, 3, 8, 6, 5, 4, 8, 7, 3, 8, 6, 5, 4, 8, 7, 3, 8, 6, 5], [1, 4, 6, 4, 2, 9, 8, 1, 4, 6, 4, 2, 9, 8, 1, 4, 6, 4, 2, 9, 8], [9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9, 9, 7, 3, 8, 9, 8, 9], [4, 8, 6, 5, 2, 6, 7, 4, 8, 6, 5, 2, 6, 7, 4, 8, 6, 5, 2, 6, 7], [2, 6, 8, 3, 5, 8, 9, 2, 6, 8, 3, 5, 8, 9, 2, 6, 8, 3, 5, 8, 9], [3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3, 3, 4, 2, 8, 4, 6, 3], [4, 2, 3, 2, 5, 3, 8, 4, 2, 3, 2, 5, 3, 8, 4, 2, 3, 2, 5, 3, 8], [5, 8, 7, 3, 8, 6, 4, 5, 8, 7, 3, 8, 6, 4, 5, 8, 7, 3, 8, 6, 4], [8, 4, 6, 4, 2, 9, 1, 8, 4, 6, 4, 2, 9, 1, 8, 4, 6, 4, 2, 9, 1]]}]}"
k4Gvj8pT3aNctJxE8Us4vJ,2025-07-21T15:52:22.828014,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 9], [9, 6]], ""output"": [[4, 9, 4, 9, 4, 9], [9, 6, 9, 6, 9, 6], [9, 4, 9, 4, 9, 4], [6, 9, 6, 9, 6, 9], [4, 9, 4, 9, 4, 9], [9, 6, 9, 6, 9, 6]]}, {""input"": [[4, 2], [9, 8]], ""output"": [[4, 2, 4, 2, 4, 2], [9, 8, 9, 8, 9, 8], [2, 4, 2, 4, 2, 4], [8, 9, 8, 9, 8, 9], [4, 2, 4, 2, 4, 2], [9, 8, 9, 8, 9, 8]]}, {""input"": [[9, 5], [7, 4]], ""output"": [[9, 5, 9, 5, 9, 5], [7, 4, 7, 4, 7, 4], [5, 9, 5, 9, 5, 9], [4, 7, 4, 7, 4, 7], [9, 5, 9, 5, 9, 5], [7, 4, 7, 4, 7, 4]]}], ""test"": [{""input"": [[6, 3], [2, 5]], ""output"": [[6, 3, 6, 3, 6, 3], [2, 5, 2, 5, 2, 5], [3, 6, 3, 6, 3, 6], [5, 2, 5, 2, 5, 2], [6, 3, 6, 3, 6, 3], [2, 5, 2, 5, 2, 5]]}]}"
kvQCKAwtpXenUTWk3eUqG8,2025-07-21T15:52:22.830561,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 8, 7, 6, 8, 7, 5], [6, 2, 8, 7, 2, 4, 9], [5, 8, 5, 6, 3, 7, 4], [8, 7, 3, 5, 7, 2, 8], [3, 6, 8, 7, 3, 9, 2], [8, 4, 6, 4, 5, 6, 3], [7, 5, 9, 5, 7, 2, 1]], ""output"": [[5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5], [6, 2, 8, 7, 2, 4, 9, 6, 2, 8, 7, 2, 4, 9, 6, 2, 8, 7, 2, 4, 9], [5, 8, 5, 6, 3, 7, 4, 5, 8, 5, 6, 3, 7, 4, 5, 8, 5, 6, 3, 7, 4], [8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8], [3, 6, 8, 7, 3, 9, 2, 3, 6, 8, 7, 3, 9, 2, 3, 6, 8, 7, 3, 9, 2], [8, 4, 6, 4, 5, 6, 3, 8, 4, 6, 4, 5, 6, 3, 8, 4, 6, 4, 5, 6, 3], [7, 5, 9, 5, 7, 2, 1, 7, 5, 9, 5, 7, 2, 1, 7, 5, 9, 5, 7, 2, 1], [5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5], [9, 2, 8, 7, 2, 4, 6, 9, 2, 8, 7, 2, 4, 6, 9, 2, 8, 7, 2, 4, 6], [4, 8, 5, 6, 3, 7, 5, 4, 8, 5, 6, 3, 7, 5, 4, 8, 5, 6, 3, 7, 5], [8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8], [2, 6, 8, 7, 3, 9, 3, 2, 6, 8, 7, 3, 9, 3, 2, 6, 8, 7, 3, 9, 3], [3, 4, 6, 4, 5, 6, 8, 3, 4, 6, 4, 5, 6, 8, 3, 4, 6, 4, 5, 6, 8], [1, 5, 9, 5, 7, 2, 7, 1, 5, 9, 5, 7, 2, 7, 1, 5, 9, 5, 7, 2, 7], [5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5, 5, 8, 7, 6, 8, 7, 5], [6, 2, 8, 7, 2, 4, 9, 6, 2, 8, 7, 2, 4, 9, 6, 2, 8, 7, 2, 4, 9], [5, 8, 5, 6, 3, 7, 4, 5, 8, 5, 6, 3, 7, 4, 5, 8, 5, 6, 3, 7, 4], [8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8, 8, 7, 3, 5, 7, 2, 8], [3, 6, 8, 7, 3, 9, 2, 3, 6, 8, 7, 3, 9, 2, 3, 6, 8, 7, 3, 9, 2], [8, 4, 6, 4, 5, 6, 3, 8, 4, 6, 4, 5, 6, 3, 8, 4, 6, 4, 5, 6, 3], [7, 5, 9, 5, 7, 2, 1, 7, 5, 9, 5, 7, 2, 1, 7, 5, 9, 5, 7, 2, 1]]}, {""input"": [[7, 5, 3, 2, 7, 2, 7], [3, 9, 4, 3, 2, 3, 9], [2, 7, 6, 4, 7, 9, 6], [9, 6, 8, 9, 2, 6, 7], [2, 3, 4, 2, 9, 5, 3], [9, 8, 6, 8, 5, 6, 2], [7, 9, 8, 9, 6, 9, 7]], ""output"": [[7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7], [3, 9, 4, 3, 2, 3, 9, 3, 9, 4, 3, 2, 3, 9, 3, 9, 4, 3, 2, 3, 9], [2, 7, 6, 4, 7, 9, 6, 2, 7, 6, 4, 7, 9, 6, 2, 7, 6, 4, 7, 9, 6], [9, 6, 8, 9, 2, 6, 7, 9, 6, 8, 9, 2, 6, 7, 9, 6, 8, 9, 2, 6, 7], [2, 3, 4, 2, 9, 5, 3, 2, 3, 4, 2, 9, 5, 3, 2, 3, 4, 2, 9, 5, 3], [9, 8, 6, 8, 5, 6, 2, 9, 8, 6, 8, 5, 6, 2, 9, 8, 6, 8, 5, 6, 2], [7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7], [7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7], [9, 9, 4, 3, 2, 3, 3, 9, 9, 4, 3, 2, 3, 3, 9, 9, 4, 3, 2, 3, 3], [6, 7, 6, 4, 7, 9, 2, 6, 7, 6, 4, 7, 9, 2, 6, 7, 6, 4, 7, 9, 2], [7, 6, 8, 9, 2, 6, 9, 7, 6, 8, 9, 2, 6, 9, 7, 6, 8, 9, 2, 6, 9], [3, 3, 4, 2, 9, 5, 2, 3, 3, 4, 2, 9, 5, 2, 3, 3, 4, 2, 9, 5, 2], [2, 8, 6, 8, 5, 6, 9, 2, 8, 6, 8, 5, 6, 9, 2, 8, 6, 8, 5, 6, 9], [7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7], [7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7, 7, 5, 3, 2, 7, 2, 7], [3, 9, 4, 3, 2, 3, 9, 3, 9, 4, 3, 2, 3, 9, 3, 9, 4, 3, 2, 3, 9], [2, 7, 6, 4, 7, 9, 6, 2, 7, 6, 4, 7, 9, 6, 2, 7, 6, 4, 7, 9, 6], [9, 6, 8, 9, 2, 6, 7, 9, 6, 8, 9, 2, 6, 7, 9, 6, 8, 9, 2, 6, 7], [2, 3, 4, 2, 9, 5, 3, 2, 3, 4, 2, 9, 5, 3, 2, 3, 4, 2, 9, 5, 3], [9, 8, 6, 8, 5, 6, 2, 9, 8, 6, 8, 5, 6, 2, 9, 8, 6, 8, 5, 6, 2], [7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7, 7, 9, 8, 9, 6, 9, 7]]}, {""input"": [[9, 6, 5, 3, 9, 5, 2], [8, 2, 9, 8, 5, 3, 8], [4, 6, 7, 6, 3, 4, 9], [2, 8, 4, 9, 2, 6, 7], [9, 3, 6, 2, 7, 4, 2], [6, 5, 4, 9, 6, 7, 6], [2, 8, 7, 8, 9, 4, 3]], ""output"": [[9, 6, 5, 3, 9, 5, 2, 9, 6, 5, 3, 9, 5, 2, 9, 6, 5, 3, 9, 5, 2], [8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8], [4, 6, 7, 6, 3, 4, 9, 4, 6, 7, 6, 3, 4, 9, 4, 6, 7, 6, 3, 4, 9], [2, 8, 4, 9, 2, 6, 7, 2, 8, 4, 9, 2, 6, 7, 2, 8, 4, 9, 2, 6, 7], [9, 3, 6, 2, 7, 4, 2, 9, 3, 6, 2, 7, 4, 2, 9, 3, 6, 2, 7, 4, 2], [6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6], [2, 8, 7, 8, 9, 4, 3, 2, 8, 7, 8, 9, 4, 3, 2, 8, 7, 8, 9, 4, 3], [2, 6, 5, 3, 9, 5, 9, 2, 6, 5, 3, 9, 5, 9, 2, 6, 5, 3, 9, 5, 9], [8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8], [9, 6, 7, 6, 3, 4, 4, 9, 6, 7, 6, 3, 4, 4, 9, 6, 7, 6, 3, 4, 4], [7, 8, 4, 9, 2, 6, 2, 7, 8, 4, 9, 2, 6, 2, 7, 8, 4, 9, 2, 6, 2], [2, 3, 6, 2, 7, 4, 9, 2, 3, 6, 2, 7, 4, 9, 2, 3, 6, 2, 7, 4, 9], [6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6], [3, 8, 7, 8, 9, 4, 2, 3, 8, 7, 8, 9, 4, 2, 3, 8, 7, 8, 9, 4, 2], [9, 6, 5, 3, 9, 5, 2, 9, 6, 5, 3, 9, 5, 2, 9, 6, 5, 3, 9, 5, 2], [8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8, 8, 2, 9, 8, 5, 3, 8], [4, 6, 7, 6, 3, 4, 9, 4, 6, 7, 6, 3, 4, 9, 4, 6, 7, 6, 3, 4, 9], [2, 8, 4, 9, 2, 6, 7, 2, 8, 4, 9, 2, 6, 7, 2, 8, 4, 9, 2, 6, 7], [9, 3, 6, 2, 7, 4, 2, 9, 3, 6, 2, 7, 4, 2, 9, 3, 6, 2, 7, 4, 2], [6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6, 6, 5, 4, 9, 6, 7, 6], [2, 8, 7, 8, 9, 4, 3, 2, 8, 7, 8, 9, 4, 3, 2, 8, 7, 8, 9, 4, 3]]}], ""test"": [{""input"": [[7, 9, 3, 4, 5, 4, 2], [6, 7, 5, 7, 6, 8, 3], [7, 3, 7, 5, 2, 9, 7], [2, 9, 3, 2, 6, 8, 2], [5, 8, 5, 4, 9, 2, 6], [7, 9, 6, 3, 6, 9, 4], [2, 6, 9, 8, 3, 7, 3]], ""output"": [[7, 9, 3, 4, 5, 4, 2, 7, 9, 3, 4, 5, 4, 2, 7, 9, 3, 4, 5, 4, 2], [6, 7, 5, 7, 6, 8, 3, 6, 7, 5, 7, 6, 8, 3, 6, 7, 5, 7, 6, 8, 3], [7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7], [2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2], [5, 8, 5, 4, 9, 2, 6, 5, 8, 5, 4, 9, 2, 6, 5, 8, 5, 4, 9, 2, 6], [7, 9, 6, 3, 6, 9, 4, 7, 9, 6, 3, 6, 9, 4, 7, 9, 6, 3, 6, 9, 4], [2, 6, 9, 8, 3, 7, 3, 2, 6, 9, 8, 3, 7, 3, 2, 6, 9, 8, 3, 7, 3], [2, 9, 3, 4, 5, 4, 7, 2, 9, 3, 4, 5, 4, 7, 2, 9, 3, 4, 5, 4, 7], [3, 7, 5, 7, 6, 8, 6, 3, 7, 5, 7, 6, 8, 6, 3, 7, 5, 7, 6, 8, 6], [7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7], [2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2], [6, 8, 5, 4, 9, 2, 5, 6, 8, 5, 4, 9, 2, 5, 6, 8, 5, 4, 9, 2, 5], [4, 9, 6, 3, 6, 9, 7, 4, 9, 6, 3, 6, 9, 7, 4, 9, 6, 3, 6, 9, 7], [3, 6, 9, 8, 3, 7, 2, 3, 6, 9, 8, 3, 7, 2, 3, 6, 9, 8, 3, 7, 2], [7, 9, 3, 4, 5, 4, 2, 7, 9, 3, 4, 5, 4, 2, 7, 9, 3, 4, 5, 4, 2], [6, 7, 5, 7, 6, 8, 3, 6, 7, 5, 7, 6, 8, 3, 6, 7, 5, 7, 6, 8, 3], [7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7, 7, 3, 7, 5, 2, 9, 7], [2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2, 2, 9, 3, 2, 6, 8, 2], [5, 8, 5, 4, 9, 2, 6, 5, 8, 5, 4, 9, 2, 6, 5, 8, 5, 4, 9, 2, 6], [7, 9, 6, 3, 6, 9, 4, 7, 9, 6, 3, 6, 9, 4, 7, 9, 6, 3, 6, 9, 4], [2, 6, 9, 8, 3, 7, 3, 2, 6, 9, 8, 3, 7, 3, 2, 6, 9, 8, 3, 7, 3]]}]}"
5Yi7S2TJqYKEshyutzPgkS,2025-07-21T15:52:22.832855,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[6, 4, 9], [4, 7, 6], [8, 5, 9]], ""output"": [[6, 4, 9, 6, 4, 9, 6, 4, 9], [4, 7, 6, 4, 7, 6, 4, 7, 6], [8, 5, 9, 8, 5, 9, 8, 5, 9], [9, 4, 6, 9, 4, 6, 9, 4, 6], [6, 7, 4, 6, 7, 4, 6, 7, 4], [9, 5, 8, 9, 5, 8, 9, 5, 8], [6, 4, 9, 6, 4, 9, 6, 4, 9], [4, 7, 6, 4, 7, 6, 4, 7, 6], [8, 5, 9, 8, 5, 9, 8, 5, 9]]}, {""input"": [[5, 3, 8], [3, 8, 6], [9, 2, 1]], ""output"": [[5, 3, 8, 5, 3, 8, 5, 3, 8], [3, 8, 6, 3, 8, 6, 3, 8, 6], [9, 2, 1, 9, 2, 1, 9, 2, 1], [8, 3, 5, 8, 3, 5, 8, 3, 5], [6, 8, 3, 6, 8, 3, 6, 8, 3], [1, 2, 9, 1, 2, 9, 1, 2, 9], [5, 3, 8, 5, 3, 8, 5, 3, 8], [3, 8, 6, 3, 8, 6, 3, 8, 6], [9, 2, 1, 9, 2, 1, 9, 2, 1]]}, {""input"": [[8, 5, 7], [7, 4, 9], [2, 9, 4]], ""output"": [[8, 5, 7, 8, 5, 7, 8, 5, 7], [7, 4, 9, 7, 4, 9, 7, 4, 9], [2, 9, 4, 2, 9, 4, 2, 9, 4], [7, 5, 8, 7, 5, 8, 7, 5, 8], [9, 4, 7, 9, 4, 7, 9, 4, 7], [4, 9, 2, 4, 9, 2, 4, 9, 2], [8, 5, 7, 8, 5, 7, 8, 5, 7], [7, 4, 9, 7, 4, 9, 7, 4, 9], [2, 9, 4, 2, 9, 4, 2, 9, 4]]}], ""test"": [{""input"": [[2, 4, 7], [7, 9, 2], [6, 4, 6]], ""output"": [[2, 4, 7, 2, 4, 7, 2, 4, 7], [7, 9, 2, 7, 9, 2, 7, 9, 2], [6, 4, 6, 6, 4, 6, 6, 4, 6], [7, 4, 2, 7, 4, 2, 7, 4, 2], [2, 9, 7, 2, 9, 7, 2, 9, 7], [6, 4, 6, 6, 4, 6, 6, 4, 6], [2, 4, 7, 2, 4, 7, 2, 4, 7], [7, 9, 2, 7, 9, 2, 7, 9, 2], [6, 4, 6, 6, 4, 6, 6, 4, 6]]}]}"
A99VFPgqGmEJx7p5HwYu8G,2025-07-21T15:52:22.834779,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 6, 2, 6], [4, 7, 8, 5], [5, 9, 2, 9], [2, 6, 9, 8]], ""output"": [[7, 6, 2, 6, 7, 6, 2, 6, 7, 6, 2, 6], [4, 7, 8, 5, 4, 7, 8, 5, 4, 7, 8, 5], [5, 9, 2, 9, 5, 9, 2, 9, 5, 9, 2, 9], [2, 6, 9, 8, 2, 6, 9, 8, 2, 6, 9, 8], [6, 6, 2, 7, 6, 6, 2, 7, 6, 6, 2, 7], [5, 7, 8, 4, 5, 7, 8, 4, 5, 7, 8, 4], [9, 9, 2, 5, 9, 9, 2, 5, 9, 9, 2, 5], [8, 6, 9, 2, 8, 6, 9, 2, 8, 6, 9, 2], [7, 6, 2, 6, 7, 6, 2, 6, 7, 6, 2, 6], [4, 7, 8, 5, 4, 7, 8, 5, 4, 7, 8, 5], [5, 9, 2, 9, 5, 9, 2, 9, 5, 9, 2, 9], [2, 6, 9, 8, 2, 6, 9, 8, 2, 6, 9, 8]]}, {""input"": [[8, 5, 3, 7], [9, 6, 5, 4], [6, 9, 8, 3], [9, 5, 4, 2]], ""output"": [[8, 5, 3, 7, 8, 5, 3, 7, 8, 5, 3, 7], [9, 6, 5, 4, 9, 6, 5, 4, 9, 6, 5, 4], [6, 9, 8, 3, 6, 9, 8, 3, 6, 9, 8, 3], [9, 5, 4, 2, 9, 5, 4, 2, 9, 5, 4, 2], [7, 5, 3, 8, 7, 5, 3, 8, 7, 5, 3, 8], [4, 6, 5, 9, 4, 6, 5, 9, 4, 6, 5, 9], [3, 9, 8, 6, 3, 9, 8, 6, 3, 9, 8, 6], [2, 5, 4, 9, 2, 5, 4, 9, 2, 5, 4, 9], [8, 5, 3, 7, 8, 5, 3, 7, 8, 5, 3, 7], [9, 6, 5, 4, 9, 6, 5, 4, 9, 6, 5, 4], [6, 9, 8, 3, 6, 9, 8, 3, 6, 9, 8, 3], [9, 5, 4, 2, 9, 5, 4, 2, 9, 5, 4, 2]]}, {""input"": [[8, 5, 6, 2], [4, 8, 3, 4], [7, 2, 6, 7], [2, 9, 2, 3]], ""output"": [[8, 5, 6, 2, 8, 5, 6, 2, 8, 5, 6, 2], [4, 8, 3, 4, 4, 8, 3, 4, 4, 8, 3, 4], [7, 2, 6, 7, 7, 2, 6, 7, 7, 2, 6, 7], [2, 9, 2, 3, 2, 9, 2, 3, 2, 9, 2, 3], [2, 5, 6, 8, 2, 5, 6, 8, 2, 5, 6, 8], [4, 8, 3, 4, 4, 8, 3, 4, 4, 8, 3, 4], [7, 2, 6, 7, 7, 2, 6, 7, 7, 2, 6, 7], [3, 9, 2, 2, 3, 9, 2, 2, 3, 9, 2, 2], [8, 5, 6, 2, 8, 5, 6, 2, 8, 5, 6, 2], [4, 8, 3, 4, 4, 8, 3, 4, 4, 8, 3, 4], [7, 2, 6, 7, 7, 2, 6, 7, 7, 2, 6, 7], [2, 9, 2, 3, 2, 9, 2, 3, 2, 9, 2, 3]]}], ""test"": [{""input"": [[2, 3, 4, 7], [4, 8, 7, 8], [6, 3, 9, 3], [2, 4, 2, 9]], ""output"": [[2, 3, 4, 7, 2, 3, 4, 7, 2, 3, 4, 7], [4, 8, 7, 8, 4, 8, 7, 8, 4, 8, 7, 8], [6, 3, 9, 3, 6, 3, 9, 3, 6, 3, 9, 3], [2, 4, 2, 9, 2, 4, 2, 9, 2, 4, 2, 9], [7, 3, 4, 2, 7, 3, 4, 2, 7, 3, 4, 2], [8, 8, 7, 4, 8, 8, 7, 4, 8, 8, 7, 4], [3, 3, 9, 6, 3, 3, 9, 6, 3, 3, 9, 6], [9, 4, 2, 2, 9, 4, 2, 2, 9, 4, 2, 2], [2, 3, 4, 7, 2, 3, 4, 7, 2, 3, 4, 7], [4, 8, 7, 8, 4, 8, 7, 8, 4, 8, 7, 8], [6, 3, 9, 3, 6, 3, 9, 3, 6, 3, 9, 3], [2, 4, 2, 9, 2, 4, 2, 9, 2, 4, 2, 9]]}]}"
UrUWtYJdRUWCx4ofbguseE,2025-07-21T15:52:22.836605,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 3, 7], [7, 4, 2], [2, 6, 9]], ""output"": [[2, 3, 7, 2, 3, 7, 2, 3, 7], [7, 4, 2, 7, 4, 2, 7, 4, 2], [2, 6, 9, 2, 6, 9, 2, 6, 9], [7, 3, 2, 7, 3, 2, 7, 3, 2], [2, 4, 7, 2, 4, 7, 2, 4, 7], [9, 6, 2, 9, 6, 2, 9, 6, 2], [2, 3, 7, 2, 3, 7, 2, 3, 7], [7, 4, 2, 7, 4, 2, 7, 4, 2], [2, 6, 9, 2, 6, 9, 2, 6, 9]]}, {""input"": [[4, 8, 9], [3, 7, 4], [7, 3, 1]], ""output"": [[4, 8, 9, 4, 8, 9, 4, 8, 9], [3, 7, 4, 3, 7, 4, 3, 7, 4], [7, 3, 1, 7, 3, 1, 7, 3, 1], [9, 8, 4, 9, 8, 4, 9, 8, 4], [4, 7, 3, 4, 7, 3, 4, 7, 3], [1, 3, 7, 1, 3, 7, 1, 3, 7], [4, 8, 9, 4, 8, 9, 4, 8, 9], [3, 7, 4, 3, 7, 4, 3, 7, 4], [7, 3, 1, 7, 3, 1, 7, 3, 1]]}, {""input"": [[9, 3, 2], [5, 4, 5], [3, 2, 6]], ""output"": [[9, 3, 2, 9, 3, 2, 9, 3, 2], [5, 4, 5, 5, 4, 5, 5, 4, 5], [3, 2, 6, 3, 2, 6, 3, 2, 6], [2, 3, 9, 2, 3, 9, 2, 3, 9], [5, 4, 5, 5, 4, 5, 5, 4, 5], [6, 2, 3, 6, 2, 3, 6, 2, 3], [9, 3, 2, 9, 3, 2, 9, 3, 2], [5, 4, 5, 5, 4, 5, 5, 4, 5], [3, 2, 6, 3, 2, 6, 3, 2, 6]]}], ""test"": [{""input"": [[4, 6, 5], [8, 3, 8], [9, 7, 5]], ""output"": [[4, 6, 5, 4, 6, 5, 4, 6, 5], [8, 3, 8, 8, 3, 8, 8, 3, 8], [9, 7, 5, 9, 7, 5, 9, 7, 5], [5, 6, 4, 5, 6, 4, 5, 6, 4], [8, 3, 8, 8, 3, 8, 8, 3, 8], [5, 7, 9, 5, 7, 9, 5, 7, 9], [4, 6, 5, 4, 6, 5, 4, 6, 5], [8, 3, 8, 8, 3, 8, 8, 3, 8], [9, 7, 5, 9, 7, 5, 9, 7, 5]]}]}"
Rejv5ZEWzTSYKCbDicrJKR,2025-07-21T15:52:22.838308,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 2], [7, 6]], ""output"": [[3, 2, 3, 2, 3, 2], [7, 6, 7, 6, 7, 6], [2, 3, 2, 3, 2, 3], [6, 7, 6, 7, 6, 7], [3, 2, 3, 2, 3, 2], [7, 6, 7, 6, 7, 6]]}, {""input"": [[7, 4], [4, 6]], ""output"": [[7, 4, 7, 4, 7, 4], [4, 6, 4, 6, 4, 6], [4, 7, 4, 7, 4, 7], [6, 4, 6, 4, 6, 4], [7, 4, 7, 4, 7, 4], [4, 6, 4, 6, 4, 6]]}, {""input"": [[9, 7], [8, 1]], ""output"": [[9, 7, 9, 7, 9, 7], [8, 1, 8, 1, 8, 1], [7, 9, 7, 9, 7, 9], [1, 8, 1, 8, 1, 8], [9, 7, 9, 7, 9, 7], [8, 1, 8, 1, 8, 1]]}], ""test"": [{""input"": [[7, 5], [9, 8]], ""output"": [[7, 5, 7, 5, 7, 5], [9, 8, 9, 8, 9, 8], [5, 7, 5, 7, 5, 7], [8, 9, 8, 9, 8, 9], [7, 5, 7, 5, 7, 5], [9, 8, 9, 8, 9, 8]]}]}"
D9FC9TgaeGHUrTUj8UPkig,2025-07-21T15:52:22.839817,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[3, 9], [2, 5]], ""output"": [[3, 9, 3, 9, 3, 9], [2, 5, 2, 5, 2, 5], [9, 3, 9, 3, 9, 3], [5, 2, 5, 2, 5, 2], [3, 9, 3, 9, 3, 9], [2, 5, 2, 5, 2, 5]]}, {""input"": [[5, 4], [3, 2]], ""output"": [[5, 4, 5, 4, 5, 4], [3, 2, 3, 2, 3, 2], [4, 5, 4, 5, 4, 5], [2, 3, 2, 3, 2, 3], [5, 4, 5, 4, 5, 4], [3, 2, 3, 2, 3, 2]]}, {""input"": [[6, 9], [8, 7]], ""output"": [[6, 9, 6, 9, 6, 9], [8, 7, 8, 7, 8, 7], [9, 6, 9, 6, 9, 6], [7, 8, 7, 8, 7, 8], [6, 9, 6, 9, 6, 9], [8, 7, 8, 7, 8, 7]]}], ""test"": [{""input"": [[6, 8], [5, 1]], ""output"": [[6, 8, 6, 8, 6, 8], [5, 1, 5, 1, 5, 1], [8, 6, 8, 6, 8, 6], [1, 5, 1, 5, 1, 5], [6, 8, 6, 8, 6, 8], [5, 1, 5, 1, 5, 1]]}]}"
gpdCHuTGEhSYPvbqG5sgLR,2025-07-21T15:52:22.841366,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 6], [2, 5]], ""output"": [[9, 6, 9, 6, 9, 6], [2, 5, 2, 5, 2, 5], [6, 9, 6, 9, 6, 9], [5, 2, 5, 2, 5, 2], [9, 6, 9, 6, 9, 6], [2, 5, 2, 5, 2, 5]]}, {""input"": [[2, 9], [3, 2]], ""output"": [[2, 9, 2, 9, 2, 9], [3, 2, 3, 2, 3, 2], [9, 2, 9, 2, 9, 2], [2, 3, 2, 3, 2, 3], [2, 9, 2, 9, 2, 9], [3, 2, 3, 2, 3, 2]]}, {""input"": [[4, 9], [3, 1]], ""output"": [[4, 9, 4, 9, 4, 9], [3, 1, 3, 1, 3, 1], [9, 4, 9, 4, 9, 4], [1, 3, 1, 3, 1, 3], [4, 9, 4, 9, 4, 9], [3, 1, 3, 1, 3, 1]]}], ""test"": [{""input"": [[3, 4], [7, 8]], ""output"": [[3, 4, 3, 4, 3, 4], [7, 8, 7, 8, 7, 8], [4, 3, 4, 3, 4, 3], [8, 7, 8, 7, 8, 7], [3, 4, 3, 4, 3, 4], [7, 8, 7, 8, 7, 8]]}]}"
5fwMY2bFVV58s7aynwmUko,2025-07-21T15:52:22.843660,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 7, 6, 2, 6, 3], [9, 6, 3, 8, 4, 8], [6, 2, 8, 6, 8, 3], [2, 9, 4, 5, 6, 4], [6, 2, 8, 9, 8, 5], [4, 3, 6, 2, 9, 3]], ""output"": [[4, 7, 6, 2, 6, 3, 4, 7, 6, 2, 6, 3, 4, 7, 6, 2, 6, 3], [9, 6, 3, 8, 4, 8, 9, 6, 3, 8, 4, 8, 9, 6, 3, 8, 4, 8], [6, 2, 8, 6, 8, 3, 6, 2, 8, 6, 8, 3, 6, 2, 8, 6, 8, 3], [2, 9, 4, 5, 6, 4, 2, 9, 4, 5, 6, 4, 2, 9, 4, 5, 6, 4], [6, 2, 8, 9, 8, 5, 6, 2, 8, 9, 8, 5, 6, 2, 8, 9, 8, 5], [4, 3, 6, 2, 9, 3, 4, 3, 6, 2, 9, 3, 4, 3, 6, 2, 9, 3], [3, 7, 6, 2, 6, 4, 3, 7, 6, 2, 6, 4, 3, 7, 6, 2, 6, 4], [8, 6, 3, 8, 4, 9, 8, 6, 3, 8, 4, 9, 8, 6, 3, 8, 4, 9], [3, 2, 8, 6, 8, 6, 3, 2, 8, 6, 8, 6, 3, 2, 8, 6, 8, 6], [4, 9, 4, 5, 6, 2, 4, 9, 4, 5, 6, 2, 4, 9, 4, 5, 6, 2], [5, 2, 8, 9, 8, 6, 5, 2, 8, 9, 8, 6, 5, 2, 8, 9, 8, 6], [3, 3, 6, 2, 9, 4, 3, 3, 6, 2, 9, 4, 3, 3, 6, 2, 9, 4], [4, 7, 6, 2, 6, 3, 4, 7, 6, 2, 6, 3, 4, 7, 6, 2, 6, 3], [9, 6, 3, 8, 4, 8, 9, 6, 3, 8, 4, 8, 9, 6, 3, 8, 4, 8], [6, 2, 8, 6, 8, 3, 6, 2, 8, 6, 8, 3, 6, 2, 8, 6, 8, 3], [2, 9, 4, 5, 6, 4, 2, 9, 4, 5, 6, 4, 2, 9, 4, 5, 6, 4], [6, 2, 8, 9, 8, 5, 6, 2, 8, 9, 8, 5, 6, 2, 8, 9, 8, 5], [4, 3, 6, 2, 9, 3, 4, 3, 6, 2, 9, 3, 4, 3, 6, 2, 9, 3]]}, {""input"": [[9, 8, 6, 8, 5, 4], [4, 9, 3, 6, 4, 7], [8, 3, 8, 7, 5, 9], [5, 7, 9, 5, 4, 3], [6, 4, 8, 2, 9, 6], [8, 2, 7, 9, 2, 4]], ""output"": [[9, 8, 6, 8, 5, 4, 9, 8, 6, 8, 5, 4, 9, 8, 6, 8, 5, 4], [4, 9, 3, 6, 4, 7, 4, 9, 3, 6, 4, 7, 4, 9, 3, 6, 4, 7], [8, 3, 8, 7, 5, 9, 8, 3, 8, 7, 5, 9, 8, 3, 8, 7, 5, 9], [5, 7, 9, 5, 4, 3, 5, 7, 9, 5, 4, 3, 5, 7, 9, 5, 4, 3], [6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6], [8, 2, 7, 9, 2, 4, 8, 2, 7, 9, 2, 4, 8, 2, 7, 9, 2, 4], [4, 8, 6, 8, 5, 9, 4, 8, 6, 8, 5, 9, 4, 8, 6, 8, 5, 9], [7, 9, 3, 6, 4, 4, 7, 9, 3, 6, 4, 4, 7, 9, 3, 6, 4, 4], [9, 3, 8, 7, 5, 8, 9, 3, 8, 7, 5, 8, 9, 3, 8, 7, 5, 8], [3, 7, 9, 5, 4, 5, 3, 7, 9, 5, 4, 5, 3, 7, 9, 5, 4, 5], [6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6], [4, 2, 7, 9, 2, 8, 4, 2, 7, 9, 2, 8, 4, 2, 7, 9, 2, 8], [9, 8, 6, 8, 5, 4, 9, 8, 6, 8, 5, 4, 9, 8, 6, 8, 5, 4], [4, 9, 3, 6, 4, 7, 4, 9, 3, 6, 4, 7, 4, 9, 3, 6, 4, 7], [8, 3, 8, 7, 5, 9, 8, 3, 8, 7, 5, 9, 8, 3, 8, 7, 5, 9], [5, 7, 9, 5, 4, 3, 5, 7, 9, 5, 4, 3, 5, 7, 9, 5, 4, 3], [6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6, 6, 4, 8, 2, 9, 6], [8, 2, 7, 9, 2, 4, 8, 2, 7, 9, 2, 4, 8, 2, 7, 9, 2, 4]]}, {""input"": [[4, 5, 6, 4, 5, 3], [5, 3, 4, 5, 4, 8], [7, 5, 7, 9, 8, 2], [2, 9, 3, 2, 4, 7], [9, 8, 9, 7, 5, 9], [5, 4, 3, 8, 4, 3]], ""output"": [[4, 5, 6, 4, 5, 3, 4, 5, 6, 4, 5, 3, 4, 5, 6, 4, 5, 3], [5, 3, 4, 5, 4, 8, 5, 3, 4, 5, 4, 8, 5, 3, 4, 5, 4, 8], [7, 5, 7, 9, 8, 2, 7, 5, 7, 9, 8, 2, 7, 5, 7, 9, 8, 2], [2, 9, 3, 2, 4, 7, 2, 9, 3, 2, 4, 7, 2, 9, 3, 2, 4, 7], [9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9], [5, 4, 3, 8, 4, 3, 5, 4, 3, 8, 4, 3, 5, 4, 3, 8, 4, 3], [3, 5, 6, 4, 5, 4, 3, 5, 6, 4, 5, 4, 3, 5, 6, 4, 5, 4], [8, 3, 4, 5, 4, 5, 8, 3, 4, 5, 4, 5, 8, 3, 4, 5, 4, 5], [2, 5, 7, 9, 8, 7, 2, 5, 7, 9, 8, 7, 2, 5, 7, 9, 8, 7], [7, 9, 3, 2, 4, 2, 7, 9, 3, 2, 4, 2, 7, 9, 3, 2, 4, 2], [9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9], [3, 4, 3, 8, 4, 5, 3, 4, 3, 8, 4, 5, 3, 4, 3, 8, 4, 5], [4, 5, 6, 4, 5, 3, 4, 5, 6, 4, 5, 3, 4, 5, 6, 4, 5, 3], [5, 3, 4, 5, 4, 8, 5, 3, 4, 5, 4, 8, 5, 3, 4, 5, 4, 8], [7, 5, 7, 9, 8, 2, 7, 5, 7, 9, 8, 2, 7, 5, 7, 9, 8, 2], [2, 9, 3, 2, 4, 7, 2, 9, 3, 2, 4, 7, 2, 9, 3, 2, 4, 7], [9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9, 9, 8, 9, 7, 5, 9], [5, 4, 3, 8, 4, 3, 5, 4, 3, 8, 4, 3, 5, 4, 3, 8, 4, 3]]}], ""test"": [{""input"": [[3, 4, 6, 9, 8, 7], [2, 3, 7, 5, 6, 8], [9, 2, 6, 2, 5, 2], [2, 9, 8, 6, 9, 3], [5, 2, 6, 7, 2, 8], [2, 5, 9, 4, 5, 7]], ""output"": [[3, 4, 6, 9, 8, 7, 3, 4, 6, 9, 8, 7, 3, 4, 6, 9, 8, 7], [2, 3, 7, 5, 6, 8, 2, 3, 7, 5, 6, 8, 2, 3, 7, 5, 6, 8], [9, 2, 6, 2, 5, 2, 9, 2, 6, 2, 5, 2, 9, 2, 6, 2, 5, 2], [2, 9, 8, 6, 9, 3, 2, 9, 8, 6, 9, 3, 2, 9, 8, 6, 9, 3], [5, 2, 6, 7, 2, 8, 5, 2, 6, 7, 2, 8, 5, 2, 6, 7, 2, 8], [2, 5, 9, 4, 5, 7, 2, 5, 9, 4, 5, 7, 2, 5, 9, 4, 5, 7], [7, 4, 6, 9, 8, 3, 7, 4, 6, 9, 8, 3, 7, 4, 6, 9, 8, 3], [8, 3, 7, 5, 6, 2, 8, 3, 7, 5, 6, 2, 8, 3, 7, 5, 6, 2], [2, 2, 6, 2, 5, 9, 2, 2, 6, 2, 5, 9, 2, 2, 6, 2, 5, 9], [3, 9, 8, 6, 9, 2, 3, 9, 8, 6, 9, 2, 3, 9, 8, 6, 9, 2], [8, 2, 6, 7, 2, 5, 8, 2, 6, 7, 2, 5, 8, 2, 6, 7, 2, 5], [7, 5, 9, 4, 5, 2, 7, 5, 9, 4, 5, 2, 7, 5, 9, 4, 5, 2], [3, 4, 6, 9, 8, 7, 3, 4, 6, 9, 8, 7, 3, 4, 6, 9, 8, 7], [2, 3, 7, 5, 6, 8, 2, 3, 7, 5, 6, 8, 2, 3, 7, 5, 6, 8], [9, 2, 6, 2, 5, 2, 9, 2, 6, 2, 5, 2, 9, 2, 6, 2, 5, 2], [2, 9, 8, 6, 9, 3, 2, 9, 8, 6, 9, 3, 2, 9, 8, 6, 9, 3], [5, 2, 6, 7, 2, 8, 5, 2, 6, 7, 2, 8, 5, 2, 6, 7, 2, 8], [2, 5, 9, 4, 5, 7, 2, 5, 9, 4, 5, 7, 2, 5, 9, 4, 5, 7]]}]}"
DMddQxk8uQXkrvwqPN7n9R,2025-07-21T15:52:22.846661,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[9, 7, 3, 6, 3, 8, 6], [5, 4, 9, 7, 5, 6, 5], [8, 7, 2, 3, 4, 7, 2], [2, 9, 4, 6, 9, 6, 7], [4, 6, 9, 5, 8, 7, 5], [2, 9, 3, 8, 2, 6, 2], [5, 7, 9, 7, 5, 4, 8]], ""output"": [[9, 7, 3, 6, 3, 8, 6, 9, 7, 3, 6, 3, 8, 6, 9, 7, 3, 6, 3, 8, 6], [5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5], [8, 7, 2, 3, 4, 7, 2, 8, 7, 2, 3, 4, 7, 2, 8, 7, 2, 3, 4, 7, 2], [2, 9, 4, 6, 9, 6, 7, 2, 9, 4, 6, 9, 6, 7, 2, 9, 4, 6, 9, 6, 7], [4, 6, 9, 5, 8, 7, 5, 4, 6, 9, 5, 8, 7, 5, 4, 6, 9, 5, 8, 7, 5], [2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2], [5, 7, 9, 7, 5, 4, 8, 5, 7, 9, 7, 5, 4, 8, 5, 7, 9, 7, 5, 4, 8], [6, 7, 3, 6, 3, 8, 9, 6, 7, 3, 6, 3, 8, 9, 6, 7, 3, 6, 3, 8, 9], [5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5], [2, 7, 2, 3, 4, 7, 8, 2, 7, 2, 3, 4, 7, 8, 2, 7, 2, 3, 4, 7, 8], [7, 9, 4, 6, 9, 6, 2, 7, 9, 4, 6, 9, 6, 2, 7, 9, 4, 6, 9, 6, 2], [5, 6, 9, 5, 8, 7, 4, 5, 6, 9, 5, 8, 7, 4, 5, 6, 9, 5, 8, 7, 4], [2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2], [8, 7, 9, 7, 5, 4, 5, 8, 7, 9, 7, 5, 4, 5, 8, 7, 9, 7, 5, 4, 5], [9, 7, 3, 6, 3, 8, 6, 9, 7, 3, 6, 3, 8, 6, 9, 7, 3, 6, 3, 8, 6], [5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5, 5, 4, 9, 7, 5, 6, 5], [8, 7, 2, 3, 4, 7, 2, 8, 7, 2, 3, 4, 7, 2, 8, 7, 2, 3, 4, 7, 2], [2, 9, 4, 6, 9, 6, 7, 2, 9, 4, 6, 9, 6, 7, 2, 9, 4, 6, 9, 6, 7], [4, 6, 9, 5, 8, 7, 5, 4, 6, 9, 5, 8, 7, 5, 4, 6, 9, 5, 8, 7, 5], [2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2, 2, 9, 3, 8, 2, 6, 2], [5, 7, 9, 7, 5, 4, 8, 5, 7, 9, 7, 5, 4, 8, 5, 7, 9, 7, 5, 4, 8]]}, {""input"": [[9, 7, 6, 7, 6, 8, 6], [7, 3, 2, 8, 4, 2, 4], [2, 5, 4, 6, 5, 7, 9], [8, 4, 6, 7, 9, 6, 7], [2, 9, 3, 8, 3, 4, 2], [5, 4, 5, 4, 8, 5, 9], [9, 3, 7, 9, 4, 7, 3]], ""output"": [[9, 7, 6, 7, 6, 8, 6, 9, 7, 6, 7, 6, 8, 6, 9, 7, 6, 7, 6, 8, 6], [7, 3, 2, 8, 4, 2, 4, 7, 3, 2, 8, 4, 2, 4, 7, 3, 2, 8, 4, 2, 4], [2, 5, 4, 6, 5, 7, 9, 2, 5, 4, 6, 5, 7, 9, 2, 5, 4, 6, 5, 7, 9], [8, 4, 6, 7, 9, 6, 7, 8, 4, 6, 7, 9, 6, 7, 8, 4, 6, 7, 9, 6, 7], [2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2], [5, 4, 5, 4, 8, 5, 9, 5, 4, 5, 4, 8, 5, 9, 5, 4, 5, 4, 8, 5, 9], [9, 3, 7, 9, 4, 7, 3, 9, 3, 7, 9, 4, 7, 3, 9, 3, 7, 9, 4, 7, 3], [6, 7, 6, 7, 6, 8, 9, 6, 7, 6, 7, 6, 8, 9, 6, 7, 6, 7, 6, 8, 9], [4, 3, 2, 8, 4, 2, 7, 4, 3, 2, 8, 4, 2, 7, 4, 3, 2, 8, 4, 2, 7], [9, 5, 4, 6, 5, 7, 2, 9, 5, 4, 6, 5, 7, 2, 9, 5, 4, 6, 5, 7, 2], [7, 4, 6, 7, 9, 6, 8, 7, 4, 6, 7, 9, 6, 8, 7, 4, 6, 7, 9, 6, 8], [2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2], [9, 4, 5, 4, 8, 5, 5, 9, 4, 5, 4, 8, 5, 5, 9, 4, 5, 4, 8, 5, 5], [3, 3, 7, 9, 4, 7, 9, 3, 3, 7, 9, 4, 7, 9, 3, 3, 7, 9, 4, 7, 9], [9, 7, 6, 7, 6, 8, 6, 9, 7, 6, 7, 6, 8, 6, 9, 7, 6, 7, 6, 8, 6], [7, 3, 2, 8, 4, 2, 4, 7, 3, 2, 8, 4, 2, 4, 7, 3, 2, 8, 4, 2, 4], [2, 5, 4, 6, 5, 7, 9, 2, 5, 4, 6, 5, 7, 9, 2, 5, 4, 6, 5, 7, 9], [8, 4, 6, 7, 9, 6, 7, 8, 4, 6, 7, 9, 6, 7, 8, 4, 6, 7, 9, 6, 7], [2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2, 2, 9, 3, 8, 3, 4, 2], [5, 4, 5, 4, 8, 5, 9, 5, 4, 5, 4, 8, 5, 9, 5, 4, 5, 4, 8, 5, 9], [9, 3, 7, 9, 4, 7, 3, 9, 3, 7, 9, 4, 7, 3, 9, 3, 7, 9, 4, 7, 3]]}, {""input"": [[6, 7, 6, 8, 7, 2, 8], [9, 5, 8, 5, 4, 9, 7], [2, 3, 5, 8, 9, 5, 3], [3, 2, 8, 5, 6, 2, 9], [4, 3, 4, 6, 3, 7, 6], [7, 8, 9, 2, 6, 2, 7], [6, 9, 4, 9, 2, 4, 8]], ""output"": [[6, 7, 6, 8, 7, 2, 8, 6, 7, 6, 8, 7, 2, 8, 6, 7, 6, 8, 7, 2, 8], [9, 5, 8, 5, 4, 9, 7, 9, 5, 8, 5, 4, 9, 7, 9, 5, 8, 5, 4, 9, 7], [2, 3, 5, 8, 9, 5, 3, 2, 3, 5, 8, 9, 5, 3, 2, 3, 5, 8, 9, 5, 3], [3, 2, 8, 5, 6, 2, 9, 3, 2, 8, 5, 6, 2, 9, 3, 2, 8, 5, 6, 2, 9], [4, 3, 4, 6, 3, 7, 6, 4, 3, 4, 6, 3, 7, 6, 4, 3, 4, 6, 3, 7, 6], [7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7], [6, 9, 4, 9, 2, 4, 8, 6, 9, 4, 9, 2, 4, 8, 6, 9, 4, 9, 2, 4, 8], [8, 7, 6, 8, 7, 2, 6, 8, 7, 6, 8, 7, 2, 6, 8, 7, 6, 8, 7, 2, 6], [7, 5, 8, 5, 4, 9, 9, 7, 5, 8, 5, 4, 9, 9, 7, 5, 8, 5, 4, 9, 9], [3, 3, 5, 8, 9, 5, 2, 3, 3, 5, 8, 9, 5, 2, 3, 3, 5, 8, 9, 5, 2], [9, 2, 8, 5, 6, 2, 3, 9, 2, 8, 5, 6, 2, 3, 9, 2, 8, 5, 6, 2, 3], [6, 3, 4, 6, 3, 7, 4, 6, 3, 4, 6, 3, 7, 4, 6, 3, 4, 6, 3, 7, 4], [7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7], [8, 9, 4, 9, 2, 4, 6, 8, 9, 4, 9, 2, 4, 6, 8, 9, 4, 9, 2, 4, 6], [6, 7, 6, 8, 7, 2, 8, 6, 7, 6, 8, 7, 2, 8, 6, 7, 6, 8, 7, 2, 8], [9, 5, 8, 5, 4, 9, 7, 9, 5, 8, 5, 4, 9, 7, 9, 5, 8, 5, 4, 9, 7], [2, 3, 5, 8, 9, 5, 3, 2, 3, 5, 8, 9, 5, 3, 2, 3, 5, 8, 9, 5, 3], [3, 2, 8, 5, 6, 2, 9, 3, 2, 8, 5, 6, 2, 9, 3, 2, 8, 5, 6, 2, 9], [4, 3, 4, 6, 3, 7, 6, 4, 3, 4, 6, 3, 7, 6, 4, 3, 4, 6, 3, 7, 6], [7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7, 7, 8, 9, 2, 6, 2, 7], [6, 9, 4, 9, 2, 4, 8, 6, 9, 4, 9, 2, 4, 8, 6, 9, 4, 9, 2, 4, 8]]}], ""test"": [{""input"": [[6, 5, 3, 9, 6, 7, 6], [8, 7, 4, 6, 9, 4, 7], [4, 3, 2, 3, 7, 8, 9], [3, 2, 8, 2, 4, 9, 4], [2, 8, 6, 5, 2, 7, 8], [6, 2, 5, 3, 6, 3, 9], [3, 4, 9, 7, 3, 8, 7]], ""output"": [[6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6], [8, 7, 4, 6, 9, 4, 7, 8, 7, 4, 6, 9, 4, 7, 8, 7, 4, 6, 9, 4, 7], [4, 3, 2, 3, 7, 8, 9, 4, 3, 2, 3, 7, 8, 9, 4, 3, 2, 3, 7, 8, 9], [3, 2, 8, 2, 4, 9, 4, 3, 2, 8, 2, 4, 9, 4, 3, 2, 8, 2, 4, 9, 4], [2, 8, 6, 5, 2, 7, 8, 2, 8, 6, 5, 2, 7, 8, 2, 8, 6, 5, 2, 7, 8], [6, 2, 5, 3, 6, 3, 9, 6, 2, 5, 3, 6, 3, 9, 6, 2, 5, 3, 6, 3, 9], [3, 4, 9, 7, 3, 8, 7, 3, 4, 9, 7, 3, 8, 7, 3, 4, 9, 7, 3, 8, 7], [6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6], [7, 7, 4, 6, 9, 4, 8, 7, 7, 4, 6, 9, 4, 8, 7, 7, 4, 6, 9, 4, 8], [9, 3, 2, 3, 7, 8, 4, 9, 3, 2, 3, 7, 8, 4, 9, 3, 2, 3, 7, 8, 4], [4, 2, 8, 2, 4, 9, 3, 4, 2, 8, 2, 4, 9, 3, 4, 2, 8, 2, 4, 9, 3], [8, 8, 6, 5, 2, 7, 2, 8, 8, 6, 5, 2, 7, 2, 8, 8, 6, 5, 2, 7, 2], [9, 2, 5, 3, 6, 3, 6, 9, 2, 5, 3, 6, 3, 6, 9, 2, 5, 3, 6, 3, 6], [7, 4, 9, 7, 3, 8, 3, 7, 4, 9, 7, 3, 8, 3, 7, 4, 9, 7, 3, 8, 3], [6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6, 6, 5, 3, 9, 6, 7, 6], [8, 7, 4, 6, 9, 4, 7, 8, 7, 4, 6, 9, 4, 7, 8, 7, 4, 6, 9, 4, 7], [4, 3, 2, 3, 7, 8, 9, 4, 3, 2, 3, 7, 8, 9, 4, 3, 2, 3, 7, 8, 9], [3, 2, 8, 2, 4, 9, 4, 3, 2, 8, 2, 4, 9, 4, 3, 2, 8, 2, 4, 9, 4], [2, 8, 6, 5, 2, 7, 8, 2, 8, 6, 5, 2, 7, 8, 2, 8, 6, 5, 2, 7, 8], [6, 2, 5, 3, 6, 3, 9, 6, 2, 5, 3, 6, 3, 9, 6, 2, 5, 3, 6, 3, 9], [3, 4, 9, 7, 3, 8, 7, 3, 4, 9, 7, 3, 8, 7, 3, 4, 9, 7, 3, 8, 7]]}]}"
iMZEtcWwcVocyo2zPrSza3,2025-07-21T15:52:22.849378,task00576224,"[""Input grids are of size 3x3."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 9x9."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (8, 8)."", ""In the top and bottom 3 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 3}","def transform_input(self, grid: np.ndarray):
    grid_size = 3
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 9, 7], [5, 8, 9], [7, 9, 2]], ""output"": [[2, 9, 7, 2, 9, 7, 2, 9, 7], [5, 8, 9, 5, 8, 9, 5, 8, 9], [7, 9, 2, 7, 9, 2, 7, 9, 2], [7, 9, 2, 7, 9, 2, 7, 9, 2], [9, 8, 5, 9, 8, 5, 9, 8, 5], [2, 9, 7, 2, 9, 7, 2, 9, 7], [2, 9, 7, 2, 9, 7, 2, 9, 7], [5, 8, 9, 5, 8, 9, 5, 8, 9], [7, 9, 2, 7, 9, 2, 7, 9, 2]]}, {""input"": [[9, 3, 8], [7, 5, 9], [5, 9, 3]], ""output"": [[9, 3, 8, 9, 3, 8, 9, 3, 8], [7, 5, 9, 7, 5, 9, 7, 5, 9], [5, 9, 3, 5, 9, 3, 5, 9, 3], [8, 3, 9, 8, 3, 9, 8, 3, 9], [9, 5, 7, 9, 5, 7, 9, 5, 7], [3, 9, 5, 3, 9, 5, 3, 9, 5], [9, 3, 8, 9, 3, 8, 9, 3, 8], [7, 5, 9, 7, 5, 9, 7, 5, 9], [5, 9, 3, 5, 9, 3, 5, 9, 3]]}, {""input"": [[2, 4, 3], [4, 2, 4], [8, 3, 9]], ""output"": [[2, 4, 3, 2, 4, 3, 2, 4, 3], [4, 2, 4, 4, 2, 4, 4, 2, 4], [8, 3, 9, 8, 3, 9, 8, 3, 9], [3, 4, 2, 3, 4, 2, 3, 4, 2], [4, 2, 4, 4, 2, 4, 4, 2, 4], [9, 3, 8, 9, 3, 8, 9, 3, 8], [2, 4, 3, 2, 4, 3, 2, 4, 3], [4, 2, 4, 4, 2, 4, 4, 2, 4], [8, 3, 9, 8, 3, 9, 8, 3, 9]]}], ""test"": [{""input"": [[7, 3, 9], [4, 5, 7], [9, 7, 6]], ""output"": [[7, 3, 9, 7, 3, 9, 7, 3, 9], [4, 5, 7, 4, 5, 7, 4, 5, 7], [9, 7, 6, 9, 7, 6, 9, 7, 6], [9, 3, 7, 9, 3, 7, 9, 3, 7], [7, 5, 4, 7, 5, 4, 7, 5, 4], [6, 7, 9, 6, 7, 9, 6, 7, 9], [7, 3, 9, 7, 3, 9, 7, 3, 9], [4, 5, 7, 4, 5, 7, 4, 5, 7], [9, 7, 6, 9, 7, 6, 9, 7, 6]]}]}"
Jqh8PgAdJHBdrsK3xaskoE,2025-07-21T15:52:22.851867,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 5], [5, 2]], ""output"": [[8, 5, 8, 5, 8, 5], [5, 2, 5, 2, 5, 2], [5, 8, 5, 8, 5, 8], [2, 5, 2, 5, 2, 5], [8, 5, 8, 5, 8, 5], [5, 2, 5, 2, 5, 2]]}, {""input"": [[2, 3], [3, 8]], ""output"": [[2, 3, 2, 3, 2, 3], [3, 8, 3, 8, 3, 8], [3, 2, 3, 2, 3, 2], [8, 3, 8, 3, 8, 3], [2, 3, 2, 3, 2, 3], [3, 8, 3, 8, 3, 8]]}, {""input"": [[2, 9], [3, 5]], ""output"": [[2, 9, 2, 9, 2, 9], [3, 5, 3, 5, 3, 5], [9, 2, 9, 2, 9, 2], [5, 3, 5, 3, 5, 3], [2, 9, 2, 9, 2, 9], [3, 5, 3, 5, 3, 5]]}], ""test"": [{""input"": [[6, 8], [4, 6]], ""output"": [[6, 8, 6, 8, 6, 8], [4, 6, 4, 6, 4, 6], [8, 6, 8, 6, 8, 6], [6, 4, 6, 4, 6, 4], [6, 8, 6, 8, 6, 8], [4, 6, 4, 6, 4, 6]]}]}"
5D3hAvwC6eZqkGu3tdd8Fq,2025-07-21T15:52:22.854145,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[7, 2], [5, 3]], ""output"": [[7, 2, 7, 2, 7, 2], [5, 3, 5, 3, 5, 3], [2, 7, 2, 7, 2, 7], [3, 5, 3, 5, 3, 5], [7, 2, 7, 2, 7, 2], [5, 3, 5, 3, 5, 3]]}, {""input"": [[5, 9], [4, 3]], ""output"": [[5, 9, 5, 9, 5, 9], [4, 3, 4, 3, 4, 3], [9, 5, 9, 5, 9, 5], [3, 4, 3, 4, 3, 4], [5, 9, 5, 9, 5, 9], [4, 3, 4, 3, 4, 3]]}, {""input"": [[2, 3], [6, 2]], ""output"": [[2, 3, 2, 3, 2, 3], [6, 2, 6, 2, 6, 2], [3, 2, 3, 2, 3, 2], [2, 6, 2, 6, 2, 6], [2, 3, 2, 3, 2, 3], [6, 2, 6, 2, 6, 2]]}], ""test"": [{""input"": [[3, 8], [7, 9]], ""output"": [[3, 8, 3, 8, 3, 8], [7, 9, 7, 9, 7, 9], [8, 3, 8, 3, 8, 3], [9, 7, 9, 7, 9, 7], [3, 8, 3, 8, 3, 8], [7, 9, 7, 9, 7, 9]]}]}"
oLQLYHSWR6EejJDCVTtK7g,2025-07-21T15:52:22.857560,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[8, 2, 5, 6, 3, 9, 6], [4, 7, 9, 7, 4, 7, 3], [5, 9, 7, 6, 3, 9, 5], [7, 6, 8, 3, 2, 5, 3], [3, 5, 7, 5, 3, 7, 6], [2, 7, 4, 6, 5, 8, 5], [6, 4, 2, 8, 7, 5, 7]], ""output"": [[8, 2, 5, 6, 3, 9, 6, 8, 2, 5, 6, 3, 9, 6, 8, 2, 5, 6, 3, 9, 6], [4, 7, 9, 7, 4, 7, 3, 4, 7, 9, 7, 4, 7, 3, 4, 7, 9, 7, 4, 7, 3], [5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5], [7, 6, 8, 3, 2, 5, 3, 7, 6, 8, 3, 2, 5, 3, 7, 6, 8, 3, 2, 5, 3], [3, 5, 7, 5, 3, 7, 6, 3, 5, 7, 5, 3, 7, 6, 3, 5, 7, 5, 3, 7, 6], [2, 7, 4, 6, 5, 8, 5, 2, 7, 4, 6, 5, 8, 5, 2, 7, 4, 6, 5, 8, 5], [6, 4, 2, 8, 7, 5, 7, 6, 4, 2, 8, 7, 5, 7, 6, 4, 2, 8, 7, 5, 7], [6, 2, 5, 6, 3, 9, 8, 6, 2, 5, 6, 3, 9, 8, 6, 2, 5, 6, 3, 9, 8], [3, 7, 9, 7, 4, 7, 4, 3, 7, 9, 7, 4, 7, 4, 3, 7, 9, 7, 4, 7, 4], [5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5], [3, 6, 8, 3, 2, 5, 7, 3, 6, 8, 3, 2, 5, 7, 3, 6, 8, 3, 2, 5, 7], [6, 5, 7, 5, 3, 7, 3, 6, 5, 7, 5, 3, 7, 3, 6, 5, 7, 5, 3, 7, 3], [5, 7, 4, 6, 5, 8, 2, 5, 7, 4, 6, 5, 8, 2, 5, 7, 4, 6, 5, 8, 2], [7, 4, 2, 8, 7, 5, 6, 7, 4, 2, 8, 7, 5, 6, 7, 4, 2, 8, 7, 5, 6], [8, 2, 5, 6, 3, 9, 6, 8, 2, 5, 6, 3, 9, 6, 8, 2, 5, 6, 3, 9, 6], [4, 7, 9, 7, 4, 7, 3, 4, 7, 9, 7, 4, 7, 3, 4, 7, 9, 7, 4, 7, 3], [5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5, 5, 9, 7, 6, 3, 9, 5], [7, 6, 8, 3, 2, 5, 3, 7, 6, 8, 3, 2, 5, 3, 7, 6, 8, 3, 2, 5, 3], [3, 5, 7, 5, 3, 7, 6, 3, 5, 7, 5, 3, 7, 6, 3, 5, 7, 5, 3, 7, 6], [2, 7, 4, 6, 5, 8, 5, 2, 7, 4, 6, 5, 8, 5, 2, 7, 4, 6, 5, 8, 5], [6, 4, 2, 8, 7, 5, 7, 6, 4, 2, 8, 7, 5, 7, 6, 4, 2, 8, 7, 5, 7]]}, {""input"": [[2, 9, 5, 2, 4, 9, 4], [4, 7, 4, 7, 9, 2, 7], [3, 4, 6, 5, 7, 6, 5], [4, 7, 2, 6, 2, 7, 3], [7, 5, 9, 4, 6, 2, 8], [4, 6, 7, 9, 3, 6, 7], [5, 9, 4, 6, 5, 4, 8]], ""output"": [[2, 9, 5, 2, 4, 9, 4, 2, 9, 5, 2, 4, 9, 4, 2, 9, 5, 2, 4, 9, 4], [4, 7, 4, 7, 9, 2, 7, 4, 7, 4, 7, 9, 2, 7, 4, 7, 4, 7, 9, 2, 7], [3, 4, 6, 5, 7, 6, 5, 3, 4, 6, 5, 7, 6, 5, 3, 4, 6, 5, 7, 6, 5], [4, 7, 2, 6, 2, 7, 3, 4, 7, 2, 6, 2, 7, 3, 4, 7, 2, 6, 2, 7, 3], [7, 5, 9, 4, 6, 2, 8, 7, 5, 9, 4, 6, 2, 8, 7, 5, 9, 4, 6, 2, 8], [4, 6, 7, 9, 3, 6, 7, 4, 6, 7, 9, 3, 6, 7, 4, 6, 7, 9, 3, 6, 7], [5, 9, 4, 6, 5, 4, 8, 5, 9, 4, 6, 5, 4, 8, 5, 9, 4, 6, 5, 4, 8], [4, 9, 5, 2, 4, 9, 2, 4, 9, 5, 2, 4, 9, 2, 4, 9, 5, 2, 4, 9, 2], [7, 7, 4, 7, 9, 2, 4, 7, 7, 4, 7, 9, 2, 4, 7, 7, 4, 7, 9, 2, 4], [5, 4, 6, 5, 7, 6, 3, 5, 4, 6, 5, 7, 6, 3, 5, 4, 6, 5, 7, 6, 3], [3, 7, 2, 6, 2, 7, 4, 3, 7, 2, 6, 2, 7, 4, 3, 7, 2, 6, 2, 7, 4], [8, 5, 9, 4, 6, 2, 7, 8, 5, 9, 4, 6, 2, 7, 8, 5, 9, 4, 6, 2, 7], [7, 6, 7, 9, 3, 6, 4, 7, 6, 7, 9, 3, 6, 4, 7, 6, 7, 9, 3, 6, 4], [8, 9, 4, 6, 5, 4, 5, 8, 9, 4, 6, 5, 4, 5, 8, 9, 4, 6, 5, 4, 5], [2, 9, 5, 2, 4, 9, 4, 2, 9, 5, 2, 4, 9, 4, 2, 9, 5, 2, 4, 9, 4], [4, 7, 4, 7, 9, 2, 7, 4, 7, 4, 7, 9, 2, 7, 4, 7, 4, 7, 9, 2, 7], [3, 4, 6, 5, 7, 6, 5, 3, 4, 6, 5, 7, 6, 5, 3, 4, 6, 5, 7, 6, 5], [4, 7, 2, 6, 2, 7, 3, 4, 7, 2, 6, 2, 7, 3, 4, 7, 2, 6, 2, 7, 3], [7, 5, 9, 4, 6, 2, 8, 7, 5, 9, 4, 6, 2, 8, 7, 5, 9, 4, 6, 2, 8], [4, 6, 7, 9, 3, 6, 7, 4, 6, 7, 9, 3, 6, 7, 4, 6, 7, 9, 3, 6, 7], [5, 9, 4, 6, 5, 4, 8, 5, 9, 4, 6, 5, 4, 8, 5, 9, 4, 6, 5, 4, 8]]}, {""input"": [[9, 7, 3, 2, 7, 4, 5], [3, 9, 8, 5, 6, 5, 7], [8, 2, 7, 9, 2, 3, 4], [3, 5, 3, 7, 8, 6, 9], [6, 7, 2, 9, 6, 9, 8], [8, 2, 5, 3, 4, 8, 5], [6, 9, 4, 2, 7, 9, 2]], ""output"": [[9, 7, 3, 2, 7, 4, 5, 9, 7, 3, 2, 7, 4, 5, 9, 7, 3, 2, 7, 4, 5], [3, 9, 8, 5, 6, 5, 7, 3, 9, 8, 5, 6, 5, 7, 3, 9, 8, 5, 6, 5, 7], [8, 2, 7, 9, 2, 3, 4, 8, 2, 7, 9, 2, 3, 4, 8, 2, 7, 9, 2, 3, 4], [3, 5, 3, 7, 8, 6, 9, 3, 5, 3, 7, 8, 6, 9, 3, 5, 3, 7, 8, 6, 9], [6, 7, 2, 9, 6, 9, 8, 6, 7, 2, 9, 6, 9, 8, 6, 7, 2, 9, 6, 9, 8], [8, 2, 5, 3, 4, 8, 5, 8, 2, 5, 3, 4, 8, 5, 8, 2, 5, 3, 4, 8, 5], [6, 9, 4, 2, 7, 9, 2, 6, 9, 4, 2, 7, 9, 2, 6, 9, 4, 2, 7, 9, 2], [5, 7, 3, 2, 7, 4, 9, 5, 7, 3, 2, 7, 4, 9, 5, 7, 3, 2, 7, 4, 9], [7, 9, 8, 5, 6, 5, 3, 7, 9, 8, 5, 6, 5, 3, 7, 9, 8, 5, 6, 5, 3], [4, 2, 7, 9, 2, 3, 8, 4, 2, 7, 9, 2, 3, 8, 4, 2, 7, 9, 2, 3, 8], [9, 5, 3, 7, 8, 6, 3, 9, 5, 3, 7, 8, 6, 3, 9, 5, 3, 7, 8, 6, 3], [8, 7, 2, 9, 6, 9, 6, 8, 7, 2, 9, 6, 9, 6, 8, 7, 2, 9, 6, 9, 6], [5, 2, 5, 3, 4, 8, 8, 5, 2, 5, 3, 4, 8, 8, 5, 2, 5, 3, 4, 8, 8], [2, 9, 4, 2, 7, 9, 6, 2, 9, 4, 2, 7, 9, 6, 2, 9, 4, 2, 7, 9, 6], [9, 7, 3, 2, 7, 4, 5, 9, 7, 3, 2, 7, 4, 5, 9, 7, 3, 2, 7, 4, 5], [3, 9, 8, 5, 6, 5, 7, 3, 9, 8, 5, 6, 5, 7, 3, 9, 8, 5, 6, 5, 7], [8, 2, 7, 9, 2, 3, 4, 8, 2, 7, 9, 2, 3, 4, 8, 2, 7, 9, 2, 3, 4], [3, 5, 3, 7, 8, 6, 9, 3, 5, 3, 7, 8, 6, 9, 3, 5, 3, 7, 8, 6, 9], [6, 7, 2, 9, 6, 9, 8, 6, 7, 2, 9, 6, 9, 8, 6, 7, 2, 9, 6, 9, 8], [8, 2, 5, 3, 4, 8, 5, 8, 2, 5, 3, 4, 8, 5, 8, 2, 5, 3, 4, 8, 5], [6, 9, 4, 2, 7, 9, 2, 6, 9, 4, 2, 7, 9, 2, 6, 9, 4, 2, 7, 9, 2]]}], ""test"": [{""input"": [[4, 8, 6, 9, 8, 4, 8], [9, 2, 7, 6, 4, 9, 6], [7, 5, 4, 7, 2, 7, 2], [5, 7, 8, 5, 7, 8, 5], [6, 4, 3, 8, 9, 2, 9], [2, 7, 6, 4, 2, 9, 2], [3, 6, 4, 7, 9, 6, 7]], ""output"": [[4, 8, 6, 9, 8, 4, 8, 4, 8, 6, 9, 8, 4, 8, 4, 8, 6, 9, 8, 4, 8], [9, 2, 7, 6, 4, 9, 6, 9, 2, 7, 6, 4, 9, 6, 9, 2, 7, 6, 4, 9, 6], [7, 5, 4, 7, 2, 7, 2, 7, 5, 4, 7, 2, 7, 2, 7, 5, 4, 7, 2, 7, 2], [5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5], [6, 4, 3, 8, 9, 2, 9, 6, 4, 3, 8, 9, 2, 9, 6, 4, 3, 8, 9, 2, 9], [2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2], [3, 6, 4, 7, 9, 6, 7, 3, 6, 4, 7, 9, 6, 7, 3, 6, 4, 7, 9, 6, 7], [8, 8, 6, 9, 8, 4, 4, 8, 8, 6, 9, 8, 4, 4, 8, 8, 6, 9, 8, 4, 4], [6, 2, 7, 6, 4, 9, 9, 6, 2, 7, 6, 4, 9, 9, 6, 2, 7, 6, 4, 9, 9], [2, 5, 4, 7, 2, 7, 7, 2, 5, 4, 7, 2, 7, 7, 2, 5, 4, 7, 2, 7, 7], [5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5], [9, 4, 3, 8, 9, 2, 6, 9, 4, 3, 8, 9, 2, 6, 9, 4, 3, 8, 9, 2, 6], [2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2], [7, 6, 4, 7, 9, 6, 3, 7, 6, 4, 7, 9, 6, 3, 7, 6, 4, 7, 9, 6, 3], [4, 8, 6, 9, 8, 4, 8, 4, 8, 6, 9, 8, 4, 8, 4, 8, 6, 9, 8, 4, 8], [9, 2, 7, 6, 4, 9, 6, 9, 2, 7, 6, 4, 9, 6, 9, 2, 7, 6, 4, 9, 6], [7, 5, 4, 7, 2, 7, 2, 7, 5, 4, 7, 2, 7, 2, 7, 5, 4, 7, 2, 7, 2], [5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5, 5, 7, 8, 5, 7, 8, 5], [6, 4, 3, 8, 9, 2, 9, 6, 4, 3, 8, 9, 2, 9, 6, 4, 3, 8, 9, 2, 9], [2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2, 2, 7, 6, 4, 2, 9, 2], [3, 6, 4, 7, 9, 6, 7, 3, 6, 4, 7, 9, 6, 7, 3, 6, 4, 7, 9, 6, 7]]}]}"
jtv4MsTxRPTFxD2sdA49vA,2025-07-21T15:52:22.860865,task00576224,"[""Input grids are of size 4x4."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 12x12."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (11, 11)."", ""In the top and bottom 4 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 4}","def transform_input(self, grid: np.ndarray):
    grid_size = 4
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 6, 4, 7], [5, 8, 3, 2], [4, 9, 8, 5], [6, 4, 9, 2]], ""output"": [[2, 6, 4, 7, 2, 6, 4, 7, 2, 6, 4, 7], [5, 8, 3, 2, 5, 8, 3, 2, 5, 8, 3, 2], [4, 9, 8, 5, 4, 9, 8, 5, 4, 9, 8, 5], [6, 4, 9, 2, 6, 4, 9, 2, 6, 4, 9, 2], [7, 6, 4, 2, 7, 6, 4, 2, 7, 6, 4, 2], [2, 8, 3, 5, 2, 8, 3, 5, 2, 8, 3, 5], [5, 9, 8, 4, 5, 9, 8, 4, 5, 9, 8, 4], [2, 4, 9, 6, 2, 4, 9, 6, 2, 4, 9, 6], [2, 6, 4, 7, 2, 6, 4, 7, 2, 6, 4, 7], [5, 8, 3, 2, 5, 8, 3, 2, 5, 8, 3, 2], [4, 9, 8, 5, 4, 9, 8, 5, 4, 9, 8, 5], [6, 4, 9, 2, 6, 4, 9, 2, 6, 4, 9, 2]]}, {""input"": [[3, 6, 2, 3], [4, 9, 6, 2], [5, 6, 4, 8], [7, 4, 5, 1]], ""output"": [[3, 6, 2, 3, 3, 6, 2, 3, 3, 6, 2, 3], [4, 9, 6, 2, 4, 9, 6, 2, 4, 9, 6, 2], [5, 6, 4, 8, 5, 6, 4, 8, 5, 6, 4, 8], [7, 4, 5, 1, 7, 4, 5, 1, 7, 4, 5, 1], [3, 6, 2, 3, 3, 6, 2, 3, 3, 6, 2, 3], [2, 9, 6, 4, 2, 9, 6, 4, 2, 9, 6, 4], [8, 6, 4, 5, 8, 6, 4, 5, 8, 6, 4, 5], [1, 4, 5, 7, 1, 4, 5, 7, 1, 4, 5, 7], [3, 6, 2, 3, 3, 6, 2, 3, 3, 6, 2, 3], [4, 9, 6, 2, 4, 9, 6, 2, 4, 9, 6, 2], [5, 6, 4, 8, 5, 6, 4, 8, 5, 6, 4, 8], [7, 4, 5, 1, 7, 4, 5, 1, 7, 4, 5, 1]]}, {""input"": [[3, 5, 3, 8], [8, 7, 4, 5], [6, 9, 5, 7], [5, 7, 8, 6]], ""output"": [[3, 5, 3, 8, 3, 5, 3, 8, 3, 5, 3, 8], [8, 7, 4, 5, 8, 7, 4, 5, 8, 7, 4, 5], [6, 9, 5, 7, 6, 9, 5, 7, 6, 9, 5, 7], [5, 7, 8, 6, 5, 7, 8, 6, 5, 7, 8, 6], [8, 5, 3, 3, 8, 5, 3, 3, 8, 5, 3, 3], [5, 7, 4, 8, 5, 7, 4, 8, 5, 7, 4, 8], [7, 9, 5, 6, 7, 9, 5, 6, 7, 9, 5, 6], [6, 7, 8, 5, 6, 7, 8, 5, 6, 7, 8, 5], [3, 5, 3, 8, 3, 5, 3, 8, 3, 5, 3, 8], [8, 7, 4, 5, 8, 7, 4, 5, 8, 7, 4, 5], [6, 9, 5, 7, 6, 9, 5, 7, 6, 9, 5, 7], [5, 7, 8, 6, 5, 7, 8, 6, 5, 7, 8, 6]]}], ""test"": [{""input"": [[2, 3, 9, 5], [7, 2, 3, 9], [4, 8, 9, 2], [6, 4, 5, 3]], ""output"": [[2, 3, 9, 5, 2, 3, 9, 5, 2, 3, 9, 5], [7, 2, 3, 9, 7, 2, 3, 9, 7, 2, 3, 9], [4, 8, 9, 2, 4, 8, 9, 2, 4, 8, 9, 2], [6, 4, 5, 3, 6, 4, 5, 3, 6, 4, 5, 3], [5, 3, 9, 2, 5, 3, 9, 2, 5, 3, 9, 2], [9, 2, 3, 7, 9, 2, 3, 7, 9, 2, 3, 7], [2, 8, 9, 4, 2, 8, 9, 4, 2, 8, 9, 4], [3, 4, 5, 6, 3, 4, 5, 6, 3, 4, 5, 6], [2, 3, 9, 5, 2, 3, 9, 5, 2, 3, 9, 5], [7, 2, 3, 9, 7, 2, 3, 9, 7, 2, 3, 9], [4, 8, 9, 2, 4, 8, 9, 2, 4, 8, 9, 2], [6, 4, 5, 3, 6, 4, 5, 3, 6, 4, 5, 3]]}]}"
NZV9c4frJLAZfo4KaVKezF,2025-07-21T15:52:22.863231,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 8], [8, 1]], ""output"": [[5, 8, 5, 8, 5, 8], [8, 1, 8, 1, 8, 1], [8, 5, 8, 5, 8, 5], [1, 8, 1, 8, 1, 8], [5, 8, 5, 8, 5, 8], [8, 1, 8, 1, 8, 1]]}, {""input"": [[8, 3], [7, 4]], ""output"": [[8, 3, 8, 3, 8, 3], [7, 4, 7, 4, 7, 4], [3, 8, 3, 8, 3, 8], [4, 7, 4, 7, 4, 7], [8, 3, 8, 3, 8, 3], [7, 4, 7, 4, 7, 4]]}, {""input"": [[5, 8], [7, 2]], ""output"": [[5, 8, 5, 8, 5, 8], [7, 2, 7, 2, 7, 2], [8, 5, 8, 5, 8, 5], [2, 7, 2, 7, 2, 7], [5, 8, 5, 8, 5, 8], [7, 2, 7, 2, 7, 2]]}], ""test"": [{""input"": [[4, 5], [6, 2]], ""output"": [[4, 5, 4, 5, 4, 5], [6, 2, 6, 2, 6, 2], [5, 4, 5, 4, 5, 4], [2, 6, 2, 6, 2, 6], [4, 5, 4, 5, 4, 5], [6, 2, 6, 2, 6, 2]]}]}"
FE2bCvRBsMaFqchnzcygFF,2025-07-21T15:52:22.865951,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 4, 3, 2, 6], [2, 3, 6, 4, 9], [4, 7, 5, 3, 4], [7, 5, 4, 6, 3], [4, 8, 9, 3, 8]], ""output"": [[5, 4, 3, 2, 6, 5, 4, 3, 2, 6, 5, 4, 3, 2, 6], [2, 3, 6, 4, 9, 2, 3, 6, 4, 9, 2, 3, 6, 4, 9], [4, 7, 5, 3, 4, 4, 7, 5, 3, 4, 4, 7, 5, 3, 4], [7, 5, 4, 6, 3, 7, 5, 4, 6, 3, 7, 5, 4, 6, 3], [4, 8, 9, 3, 8, 4, 8, 9, 3, 8, 4, 8, 9, 3, 8], [6, 4, 3, 2, 5, 6, 4, 3, 2, 5, 6, 4, 3, 2, 5], [9, 3, 6, 4, 2, 9, 3, 6, 4, 2, 9, 3, 6, 4, 2], [4, 7, 5, 3, 4, 4, 7, 5, 3, 4, 4, 7, 5, 3, 4], [3, 5, 4, 6, 7, 3, 5, 4, 6, 7, 3, 5, 4, 6, 7], [8, 8, 9, 3, 4, 8, 8, 9, 3, 4, 8, 8, 9, 3, 4], [5, 4, 3, 2, 6, 5, 4, 3, 2, 6, 5, 4, 3, 2, 6], [2, 3, 6, 4, 9, 2, 3, 6, 4, 9, 2, 3, 6, 4, 9], [4, 7, 5, 3, 4, 4, 7, 5, 3, 4, 4, 7, 5, 3, 4], [7, 5, 4, 6, 3, 7, 5, 4, 6, 3, 7, 5, 4, 6, 3], [4, 8, 9, 3, 8, 4, 8, 9, 3, 8, 4, 8, 9, 3, 8]]}, {""input"": [[7, 9, 3, 8, 5], [9, 7, 9, 6, 2], [6, 2, 7, 4, 5], [4, 7, 2, 9, 2], [8, 4, 7, 2, 1]], ""output"": [[7, 9, 3, 8, 5, 7, 9, 3, 8, 5, 7, 9, 3, 8, 5], [9, 7, 9, 6, 2, 9, 7, 9, 6, 2, 9, 7, 9, 6, 2], [6, 2, 7, 4, 5, 6, 2, 7, 4, 5, 6, 2, 7, 4, 5], [4, 7, 2, 9, 2, 4, 7, 2, 9, 2, 4, 7, 2, 9, 2], [8, 4, 7, 2, 1, 8, 4, 7, 2, 1, 8, 4, 7, 2, 1], [5, 9, 3, 8, 7, 5, 9, 3, 8, 7, 5, 9, 3, 8, 7], [2, 7, 9, 6, 9, 2, 7, 9, 6, 9, 2, 7, 9, 6, 9], [5, 2, 7, 4, 6, 5, 2, 7, 4, 6, 5, 2, 7, 4, 6], [2, 7, 2, 9, 4, 2, 7, 2, 9, 4, 2, 7, 2, 9, 4], [1, 4, 7, 2, 8, 1, 4, 7, 2, 8, 1, 4, 7, 2, 8], [7, 9, 3, 8, 5, 7, 9, 3, 8, 5, 7, 9, 3, 8, 5], [9, 7, 9, 6, 2, 9, 7, 9, 6, 2, 9, 7, 9, 6, 2], [6, 2, 7, 4, 5, 6, 2, 7, 4, 5, 6, 2, 7, 4, 5], [4, 7, 2, 9, 2, 4, 7, 2, 9, 2, 4, 7, 2, 9, 2], [8, 4, 7, 2, 1, 8, 4, 7, 2, 1, 8, 4, 7, 2, 1]]}, {""input"": [[8, 5, 4, 7, 4], [2, 9, 2, 4, 6], [3, 8, 3, 7, 4], [5, 2, 5, 9, 7], [7, 5, 6, 4, 5]], ""output"": [[8, 5, 4, 7, 4, 8, 5, 4, 7, 4, 8, 5, 4, 7, 4], [2, 9, 2, 4, 6, 2, 9, 2, 4, 6, 2, 9, 2, 4, 6], [3, 8, 3, 7, 4, 3, 8, 3, 7, 4, 3, 8, 3, 7, 4], [5, 2, 5, 9, 7, 5, 2, 5, 9, 7, 5, 2, 5, 9, 7], [7, 5, 6, 4, 5, 7, 5, 6, 4, 5, 7, 5, 6, 4, 5], [4, 5, 4, 7, 8, 4, 5, 4, 7, 8, 4, 5, 4, 7, 8], [6, 9, 2, 4, 2, 6, 9, 2, 4, 2, 6, 9, 2, 4, 2], [4, 8, 3, 7, 3, 4, 8, 3, 7, 3, 4, 8, 3, 7, 3], [7, 2, 5, 9, 5, 7, 2, 5, 9, 5, 7, 2, 5, 9, 5], [5, 5, 6, 4, 7, 5, 5, 6, 4, 7, 5, 5, 6, 4, 7], [8, 5, 4, 7, 4, 8, 5, 4, 7, 4, 8, 5, 4, 7, 4], [2, 9, 2, 4, 6, 2, 9, 2, 4, 6, 2, 9, 2, 4, 6], [3, 8, 3, 7, 4, 3, 8, 3, 7, 4, 3, 8, 3, 7, 4], [5, 2, 5, 9, 7, 5, 2, 5, 9, 7, 5, 2, 5, 9, 7], [7, 5, 6, 4, 5, 7, 5, 6, 4, 5, 7, 5, 6, 4, 5]]}], ""test"": [{""input"": [[9, 3, 6, 3, 2], [4, 9, 3, 6, 4], [9, 5, 7, 3, 2], [7, 2, 8, 7, 4], [9, 6, 3, 5, 2]], ""output"": [[9, 3, 6, 3, 2, 9, 3, 6, 3, 2, 9, 3, 6, 3, 2], [4, 9, 3, 6, 4, 4, 9, 3, 6, 4, 4, 9, 3, 6, 4], [9, 5, 7, 3, 2, 9, 5, 7, 3, 2, 9, 5, 7, 3, 2], [7, 2, 8, 7, 4, 7, 2, 8, 7, 4, 7, 2, 8, 7, 4], [9, 6, 3, 5, 2, 9, 6, 3, 5, 2, 9, 6, 3, 5, 2], [2, 3, 6, 3, 9, 2, 3, 6, 3, 9, 2, 3, 6, 3, 9], [4, 9, 3, 6, 4, 4, 9, 3, 6, 4, 4, 9, 3, 6, 4], [2, 5, 7, 3, 9, 2, 5, 7, 3, 9, 2, 5, 7, 3, 9], [4, 2, 8, 7, 7, 4, 2, 8, 7, 7, 4, 2, 8, 7, 7], [2, 6, 3, 5, 9, 2, 6, 3, 5, 9, 2, 6, 3, 5, 9], [9, 3, 6, 3, 2, 9, 3, 6, 3, 2, 9, 3, 6, 3, 2], [4, 9, 3, 6, 4, 4, 9, 3, 6, 4, 4, 9, 3, 6, 4], [9, 5, 7, 3, 2, 9, 5, 7, 3, 2, 9, 5, 7, 3, 2], [7, 2, 8, 7, 4, 7, 2, 8, 7, 4, 7, 2, 8, 7, 4], [9, 6, 3, 5, 2, 9, 6, 3, 5, 2, 9, 6, 3, 5, 2]]}]}"
CTvTt5qX7ucDTsPRf2VtAm,2025-07-21T15:52:22.869143,task00576224,"[""Input grids are of size 5x5."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 15x15."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (14, 14)."", ""In the top and bottom 5 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 5}","def transform_input(self, grid: np.ndarray):
    grid_size = 5
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[4, 2, 9, 6, 3], [5, 9, 7, 3, 5], [3, 2, 6, 7, 9], [6, 4, 8, 3, 8], [5, 2, 9, 4, 7]], ""output"": [[4, 2, 9, 6, 3, 4, 2, 9, 6, 3, 4, 2, 9, 6, 3], [5, 9, 7, 3, 5, 5, 9, 7, 3, 5, 5, 9, 7, 3, 5], [3, 2, 6, 7, 9, 3, 2, 6, 7, 9, 3, 2, 6, 7, 9], [6, 4, 8, 3, 8, 6, 4, 8, 3, 8, 6, 4, 8, 3, 8], [5, 2, 9, 4, 7, 5, 2, 9, 4, 7, 5, 2, 9, 4, 7], [3, 2, 9, 6, 4, 3, 2, 9, 6, 4, 3, 2, 9, 6, 4], [5, 9, 7, 3, 5, 5, 9, 7, 3, 5, 5, 9, 7, 3, 5], [9, 2, 6, 7, 3, 9, 2, 6, 7, 3, 9, 2, 6, 7, 3], [8, 4, 8, 3, 6, 8, 4, 8, 3, 6, 8, 4, 8, 3, 6], [7, 2, 9, 4, 5, 7, 2, 9, 4, 5, 7, 2, 9, 4, 5], [4, 2, 9, 6, 3, 4, 2, 9, 6, 3, 4, 2, 9, 6, 3], [5, 9, 7, 3, 5, 5, 9, 7, 3, 5, 5, 9, 7, 3, 5], [3, 2, 6, 7, 9, 3, 2, 6, 7, 9, 3, 2, 6, 7, 9], [6, 4, 8, 3, 8, 6, 4, 8, 3, 8, 6, 4, 8, 3, 8], [5, 2, 9, 4, 7, 5, 2, 9, 4, 7, 5, 2, 9, 4, 7]]}, {""input"": [[9, 8, 6, 3, 9], [8, 4, 7, 5, 4], [6, 7, 3, 6, 9], [5, 4, 7, 9, 4], [2, 5, 6, 2, 9]], ""output"": [[9, 8, 6, 3, 9, 9, 8, 6, 3, 9, 9, 8, 6, 3, 9], [8, 4, 7, 5, 4, 8, 4, 7, 5, 4, 8, 4, 7, 5, 4], [6, 7, 3, 6, 9, 6, 7, 3, 6, 9, 6, 7, 3, 6, 9], [5, 4, 7, 9, 4, 5, 4, 7, 9, 4, 5, 4, 7, 9, 4], [2, 5, 6, 2, 9, 2, 5, 6, 2, 9, 2, 5, 6, 2, 9], [9, 8, 6, 3, 9, 9, 8, 6, 3, 9, 9, 8, 6, 3, 9], [4, 4, 7, 5, 8, 4, 4, 7, 5, 8, 4, 4, 7, 5, 8], [9, 7, 3, 6, 6, 9, 7, 3, 6, 6, 9, 7, 3, 6, 6], [4, 4, 7, 9, 5, 4, 4, 7, 9, 5, 4, 4, 7, 9, 5], [9, 5, 6, 2, 2, 9, 5, 6, 2, 2, 9, 5, 6, 2, 2], [9, 8, 6, 3, 9, 9, 8, 6, 3, 9, 9, 8, 6, 3, 9], [8, 4, 7, 5, 4, 8, 4, 7, 5, 4, 8, 4, 7, 5, 4], [6, 7, 3, 6, 9, 6, 7, 3, 6, 9, 6, 7, 3, 6, 9], [5, 4, 7, 9, 4, 5, 4, 7, 9, 4, 5, 4, 7, 9, 4], [2, 5, 6, 2, 9, 2, 5, 6, 2, 9, 2, 5, 6, 2, 9]]}, {""input"": [[2, 4, 7, 3, 5], [7, 9, 5, 4, 8], [8, 7, 9, 8, 5], [6, 4, 7, 9, 6], [4, 8, 9, 2, 4]], ""output"": [[2, 4, 7, 3, 5, 2, 4, 7, 3, 5, 2, 4, 7, 3, 5], [7, 9, 5, 4, 8, 7, 9, 5, 4, 8, 7, 9, 5, 4, 8], [8, 7, 9, 8, 5, 8, 7, 9, 8, 5, 8, 7, 9, 8, 5], [6, 4, 7, 9, 6, 6, 4, 7, 9, 6, 6, 4, 7, 9, 6], [4, 8, 9, 2, 4, 4, 8, 9, 2, 4, 4, 8, 9, 2, 4], [5, 4, 7, 3, 2, 5, 4, 7, 3, 2, 5, 4, 7, 3, 2], [8, 9, 5, 4, 7, 8, 9, 5, 4, 7, 8, 9, 5, 4, 7], [5, 7, 9, 8, 8, 5, 7, 9, 8, 8, 5, 7, 9, 8, 8], [6, 4, 7, 9, 6, 6, 4, 7, 9, 6, 6, 4, 7, 9, 6], [4, 8, 9, 2, 4, 4, 8, 9, 2, 4, 4, 8, 9, 2, 4], [2, 4, 7, 3, 5, 2, 4, 7, 3, 5, 2, 4, 7, 3, 5], [7, 9, 5, 4, 8, 7, 9, 5, 4, 8, 7, 9, 5, 4, 8], [8, 7, 9, 8, 5, 8, 7, 9, 8, 5, 8, 7, 9, 8, 5], [6, 4, 7, 9, 6, 6, 4, 7, 9, 6, 6, 4, 7, 9, 6], [4, 8, 9, 2, 4, 4, 8, 9, 2, 4, 4, 8, 9, 2, 4]]}], ""test"": [{""input"": [[3, 5, 2, 7, 3], [2, 6, 9, 8, 2], [4, 3, 2, 4, 6], [2, 9, 7, 9, 2], [9, 6, 5, 6, 8]], ""output"": [[3, 5, 2, 7, 3, 3, 5, 2, 7, 3, 3, 5, 2, 7, 3], [2, 6, 9, 8, 2, 2, 6, 9, 8, 2, 2, 6, 9, 8, 2], [4, 3, 2, 4, 6, 4, 3, 2, 4, 6, 4, 3, 2, 4, 6], [2, 9, 7, 9, 2, 2, 9, 7, 9, 2, 2, 9, 7, 9, 2], [9, 6, 5, 6, 8, 9, 6, 5, 6, 8, 9, 6, 5, 6, 8], [3, 5, 2, 7, 3, 3, 5, 2, 7, 3, 3, 5, 2, 7, 3], [2, 6, 9, 8, 2, 2, 6, 9, 8, 2, 2, 6, 9, 8, 2], [6, 3, 2, 4, 4, 6, 3, 2, 4, 4, 6, 3, 2, 4, 4], [2, 9, 7, 9, 2, 2, 9, 7, 9, 2, 2, 9, 7, 9, 2], [8, 6, 5, 6, 9, 8, 6, 5, 6, 9, 8, 6, 5, 6, 9], [3, 5, 2, 7, 3, 3, 5, 2, 7, 3, 3, 5, 2, 7, 3], [2, 6, 9, 8, 2, 2, 6, 9, 8, 2, 2, 6, 9, 8, 2], [4, 3, 2, 4, 6, 4, 3, 2, 4, 6, 4, 3, 2, 4, 6], [2, 9, 7, 9, 2, 2, 9, 7, 9, 2, 2, 9, 7, 9, 2], [9, 6, 5, 6, 8, 9, 6, 5, 6, 8, 9, 6, 5, 6, 8]]}]}"
DwmYUtpkAxVw5mXBAd2y7p,2025-07-21T15:52:22.871606,task00576224,"[""Input grids are of size 2x2."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 6x6."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (5, 5)."", ""In the top and bottom 2 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 2}","def transform_input(self, grid: np.ndarray):
    grid_size = 2
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[2, 4], [7, 2]], ""output"": [[2, 4, 2, 4, 2, 4], [7, 2, 7, 2, 7, 2], [4, 2, 4, 2, 4, 2], [2, 7, 2, 7, 2, 7], [2, 4, 2, 4, 2, 4], [7, 2, 7, 2, 7, 2]]}, {""input"": [[6, 4], [7, 3]], ""output"": [[6, 4, 6, 4, 6, 4], [7, 3, 7, 3, 7, 3], [4, 6, 4, 6, 4, 6], [3, 7, 3, 7, 3, 7], [6, 4, 6, 4, 6, 4], [7, 3, 7, 3, 7, 3]]}, {""input"": [[5, 8], [9, 2]], ""output"": [[5, 8, 5, 8, 5, 8], [9, 2, 9, 2, 9, 2], [8, 5, 8, 5, 8, 5], [2, 9, 2, 9, 2, 9], [5, 8, 5, 8, 5, 8], [9, 2, 9, 2, 9, 2]]}], ""test"": [{""input"": [[6, 4], [9, 7]], ""output"": [[6, 4, 6, 4, 6, 4], [9, 7, 9, 7, 9, 7], [4, 6, 4, 6, 4, 6], [7, 9, 7, 9, 7, 9], [6, 4, 6, 4, 6, 4], [9, 7, 9, 7, 9, 7]]}]}"
Cd8apQ6nVStCZT6AuHLPjm,2025-07-21T15:52:22.874772,task00576224,"[""Input grids are of size 6x6."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 18x18."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (17, 17)."", ""In the top and bottom 6 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 6}","def transform_input(self, grid: np.ndarray):
    grid_size = 6
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 8, 4, 8, 5, 4], [4, 5, 2, 6, 3, 6], [8, 3, 6, 9, 4, 2], [4, 5, 2, 7, 6, 9], [3, 2, 8, 9, 3, 6], [2, 6, 2, 8, 6, 2]], ""output"": [[5, 8, 4, 8, 5, 4, 5, 8, 4, 8, 5, 4, 5, 8, 4, 8, 5, 4], [4, 5, 2, 6, 3, 6, 4, 5, 2, 6, 3, 6, 4, 5, 2, 6, 3, 6], [8, 3, 6, 9, 4, 2, 8, 3, 6, 9, 4, 2, 8, 3, 6, 9, 4, 2], [4, 5, 2, 7, 6, 9, 4, 5, 2, 7, 6, 9, 4, 5, 2, 7, 6, 9], [3, 2, 8, 9, 3, 6, 3, 2, 8, 9, 3, 6, 3, 2, 8, 9, 3, 6], [2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2], [4, 8, 4, 8, 5, 5, 4, 8, 4, 8, 5, 5, 4, 8, 4, 8, 5, 5], [6, 5, 2, 6, 3, 4, 6, 5, 2, 6, 3, 4, 6, 5, 2, 6, 3, 4], [2, 3, 6, 9, 4, 8, 2, 3, 6, 9, 4, 8, 2, 3, 6, 9, 4, 8], [9, 5, 2, 7, 6, 4, 9, 5, 2, 7, 6, 4, 9, 5, 2, 7, 6, 4], [6, 2, 8, 9, 3, 3, 6, 2, 8, 9, 3, 3, 6, 2, 8, 9, 3, 3], [2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2], [5, 8, 4, 8, 5, 4, 5, 8, 4, 8, 5, 4, 5, 8, 4, 8, 5, 4], [4, 5, 2, 6, 3, 6, 4, 5, 2, 6, 3, 6, 4, 5, 2, 6, 3, 6], [8, 3, 6, 9, 4, 2, 8, 3, 6, 9, 4, 2, 8, 3, 6, 9, 4, 2], [4, 5, 2, 7, 6, 9, 4, 5, 2, 7, 6, 9, 4, 5, 2, 7, 6, 9], [3, 2, 8, 9, 3, 6, 3, 2, 8, 9, 3, 6, 3, 2, 8, 9, 3, 6], [2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2, 2, 6, 2, 8, 6, 2]]}, {""input"": [[3, 6, 3, 6, 5, 7], [8, 4, 6, 3, 6, 4], [5, 2, 8, 2, 3, 7], [9, 6, 5, 7, 9, 4], [4, 5, 8, 4, 2, 3], [9, 8, 6, 7, 9, 7]], ""output"": [[3, 6, 3, 6, 5, 7, 3, 6, 3, 6, 5, 7, 3, 6, 3, 6, 5, 7], [8, 4, 6, 3, 6, 4, 8, 4, 6, 3, 6, 4, 8, 4, 6, 3, 6, 4], [5, 2, 8, 2, 3, 7, 5, 2, 8, 2, 3, 7, 5, 2, 8, 2, 3, 7], [9, 6, 5, 7, 9, 4, 9, 6, 5, 7, 9, 4, 9, 6, 5, 7, 9, 4], [4, 5, 8, 4, 2, 3, 4, 5, 8, 4, 2, 3, 4, 5, 8, 4, 2, 3], [9, 8, 6, 7, 9, 7, 9, 8, 6, 7, 9, 7, 9, 8, 6, 7, 9, 7], [7, 6, 3, 6, 5, 3, 7, 6, 3, 6, 5, 3, 7, 6, 3, 6, 5, 3], [4, 4, 6, 3, 6, 8, 4, 4, 6, 3, 6, 8, 4, 4, 6, 3, 6, 8], [7, 2, 8, 2, 3, 5, 7, 2, 8, 2, 3, 5, 7, 2, 8, 2, 3, 5], [4, 6, 5, 7, 9, 9, 4, 6, 5, 7, 9, 9, 4, 6, 5, 7, 9, 9], [3, 5, 8, 4, 2, 4, 3, 5, 8, 4, 2, 4, 3, 5, 8, 4, 2, 4], [7, 8, 6, 7, 9, 9, 7, 8, 6, 7, 9, 9, 7, 8, 6, 7, 9, 9], [3, 6, 3, 6, 5, 7, 3, 6, 3, 6, 5, 7, 3, 6, 3, 6, 5, 7], [8, 4, 6, 3, 6, 4, 8, 4, 6, 3, 6, 4, 8, 4, 6, 3, 6, 4], [5, 2, 8, 2, 3, 7, 5, 2, 8, 2, 3, 7, 5, 2, 8, 2, 3, 7], [9, 6, 5, 7, 9, 4, 9, 6, 5, 7, 9, 4, 9, 6, 5, 7, 9, 4], [4, 5, 8, 4, 2, 3, 4, 5, 8, 4, 2, 3, 4, 5, 8, 4, 2, 3], [9, 8, 6, 7, 9, 7, 9, 8, 6, 7, 9, 7, 9, 8, 6, 7, 9, 7]]}, {""input"": [[4, 9, 7, 3, 5, 9], [9, 5, 9, 5, 3, 6], [5, 7, 8, 6, 8, 9], [6, 3, 6, 4, 2, 7], [9, 7, 8, 6, 8, 9], [2, 4, 2, 4, 3, 4]], ""output"": [[4, 9, 7, 3, 5, 9, 4, 9, 7, 3, 5, 9, 4, 9, 7, 3, 5, 9], [9, 5, 9, 5, 3, 6, 9, 5, 9, 5, 3, 6, 9, 5, 9, 5, 3, 6], [5, 7, 8, 6, 8, 9, 5, 7, 8, 6, 8, 9, 5, 7, 8, 6, 8, 9], [6, 3, 6, 4, 2, 7, 6, 3, 6, 4, 2, 7, 6, 3, 6, 4, 2, 7], [9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9], [2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 3, 4], [9, 9, 7, 3, 5, 4, 9, 9, 7, 3, 5, 4, 9, 9, 7, 3, 5, 4], [6, 5, 9, 5, 3, 9, 6, 5, 9, 5, 3, 9, 6, 5, 9, 5, 3, 9], [9, 7, 8, 6, 8, 5, 9, 7, 8, 6, 8, 5, 9, 7, 8, 6, 8, 5], [7, 3, 6, 4, 2, 6, 7, 3, 6, 4, 2, 6, 7, 3, 6, 4, 2, 6], [9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9], [4, 4, 2, 4, 3, 2, 4, 4, 2, 4, 3, 2, 4, 4, 2, 4, 3, 2], [4, 9, 7, 3, 5, 9, 4, 9, 7, 3, 5, 9, 4, 9, 7, 3, 5, 9], [9, 5, 9, 5, 3, 6, 9, 5, 9, 5, 3, 6, 9, 5, 9, 5, 3, 6], [5, 7, 8, 6, 8, 9, 5, 7, 8, 6, 8, 9, 5, 7, 8, 6, 8, 9], [6, 3, 6, 4, 2, 7, 6, 3, 6, 4, 2, 7, 6, 3, 6, 4, 2, 7], [9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9, 9, 7, 8, 6, 8, 9], [2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 3, 4, 2, 4, 2, 4, 3, 4]]}], ""test"": [{""input"": [[2, 5, 2, 9, 7, 9], [5, 2, 5, 8, 9, 6], [4, 7, 3, 6, 5, 3], [5, 4, 9, 5, 9, 4], [8, 9, 7, 2, 6, 9], [3, 2, 4, 6, 8, 2]], ""output"": [[2, 5, 2, 9, 7, 9, 2, 5, 2, 9, 7, 9, 2, 5, 2, 9, 7, 9], [5, 2, 5, 8, 9, 6, 5, 2, 5, 8, 9, 6, 5, 2, 5, 8, 9, 6], [4, 7, 3, 6, 5, 3, 4, 7, 3, 6, 5, 3, 4, 7, 3, 6, 5, 3], [5, 4, 9, 5, 9, 4, 5, 4, 9, 5, 9, 4, 5, 4, 9, 5, 9, 4], [8, 9, 7, 2, 6, 9, 8, 9, 7, 2, 6, 9, 8, 9, 7, 2, 6, 9], [3, 2, 4, 6, 8, 2, 3, 2, 4, 6, 8, 2, 3, 2, 4, 6, 8, 2], [9, 5, 2, 9, 7, 2, 9, 5, 2, 9, 7, 2, 9, 5, 2, 9, 7, 2], [6, 2, 5, 8, 9, 5, 6, 2, 5, 8, 9, 5, 6, 2, 5, 8, 9, 5], [3, 7, 3, 6, 5, 4, 3, 7, 3, 6, 5, 4, 3, 7, 3, 6, 5, 4], [4, 4, 9, 5, 9, 5, 4, 4, 9, 5, 9, 5, 4, 4, 9, 5, 9, 5], [9, 9, 7, 2, 6, 8, 9, 9, 7, 2, 6, 8, 9, 9, 7, 2, 6, 8], [2, 2, 4, 6, 8, 3, 2, 2, 4, 6, 8, 3, 2, 2, 4, 6, 8, 3], [2, 5, 2, 9, 7, 9, 2, 5, 2, 9, 7, 9, 2, 5, 2, 9, 7, 9], [5, 2, 5, 8, 9, 6, 5, 2, 5, 8, 9, 6, 5, 2, 5, 8, 9, 6], [4, 7, 3, 6, 5, 3, 4, 7, 3, 6, 5, 3, 4, 7, 3, 6, 5, 3], [5, 4, 9, 5, 9, 4, 5, 4, 9, 5, 9, 4, 5, 4, 9, 5, 9, 4], [8, 9, 7, 2, 6, 9, 8, 9, 7, 2, 6, 9, 8, 9, 7, 2, 6, 9], [3, 2, 4, 6, 8, 2, 3, 2, 4, 6, 8, 2, 3, 2, 4, 6, 8, 2]]}]}"
aqHJ8qq5exKgLDTLUmCBvN,2025-07-21T15:52:22.878897,task00576224,"[""Input grids are of size 7x7."", ""They contain a completely filled grid, with no empty (0) cells."", ""The grids are filled with multi-colored (1\u20139) cells."", ""The cells are placed in such a way that the first and last columns of the input grid are different.""]","[""Output grids are of size 21x21."", ""They are constructed by copying the input grid and pasting it 9 times in the output grid, starting from (0,0) and going until (20, 20)."", ""In the top and bottom 7 rows, the input grid is pasted directly."", ""In all middle rows, the input grid is slightly changed."", ""The slight change involves swapping the first and last columns of the input grid."", ""These modified grids are then pasted into the middle rows.""]","{""grid_size"": 7}","def transform_input(self, grid: np.ndarray):
    grid_size = 7
    output_size = 3 * grid_size
    output_grid = np.zeros((output_size, output_size), dtype=int)
    
    # Create modified grid with swapped first and last columns
    modified_grid = grid.copy()
    modified_grid[:, 0], modified_grid[:, -1] = grid[:, -1].copy(), grid[:, 0].copy()
    
    # Paste grids to create output
    for row in range(3):
        for col in range(3):
            start_r = row * grid_size
            start_c = col * grid_size
            
            # Middle row gets modified grid, others get original
            if row == 1:
                source_grid = modified_grid
            else:
                source_grid = grid
            
            # Copy the source grid to the appropriate location
            for r in range(grid_size):
                for c in range(grid_size):
                    output_grid[start_r + r, start_c + c] = source_grid[r, c]
    
    return output_grid","{""train"": [{""input"": [[5, 4, 7, 8, 6, 7, 3], [7, 8, 4, 7, 5, 9, 7], [3, 6, 3, 9, 6, 2, 4], [2, 9, 5, 4, 2, 4, 5], [5, 2, 8, 7, 8, 7, 9], [2, 8, 2, 5, 4, 5, 3], [4, 7, 6, 9, 8, 6, 5]], ""output"": [[5, 4, 7, 8, 6, 7, 3, 5, 4, 7, 8, 6, 7, 3, 5, 4, 7, 8, 6, 7, 3], [7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7], [3, 6, 3, 9, 6, 2, 4, 3, 6, 3, 9, 6, 2, 4, 3, 6, 3, 9, 6, 2, 4], [2, 9, 5, 4, 2, 4, 5, 2, 9, 5, 4, 2, 4, 5, 2, 9, 5, 4, 2, 4, 5], [5, 2, 8, 7, 8, 7, 9, 5, 2, 8, 7, 8, 7, 9, 5, 2, 8, 7, 8, 7, 9], [2, 8, 2, 5, 4, 5, 3, 2, 8, 2, 5, 4, 5, 3, 2, 8, 2, 5, 4, 5, 3], [4, 7, 6, 9, 8, 6, 5, 4, 7, 6, 9, 8, 6, 5, 4, 7, 6, 9, 8, 6, 5], [3, 4, 7, 8, 6, 7, 5, 3, 4, 7, 8, 6, 7, 5, 3, 4, 7, 8, 6, 7, 5], [7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7], [4, 6, 3, 9, 6, 2, 3, 4, 6, 3, 9, 6, 2, 3, 4, 6, 3, 9, 6, 2, 3], [5, 9, 5, 4, 2, 4, 2, 5, 9, 5, 4, 2, 4, 2, 5, 9, 5, 4, 2, 4, 2], [9, 2, 8, 7, 8, 7, 5, 9, 2, 8, 7, 8, 7, 5, 9, 2, 8, 7, 8, 7, 5], [3, 8, 2, 5, 4, 5, 2, 3, 8, 2, 5, 4, 5, 2, 3, 8, 2, 5, 4, 5, 2], [5, 7, 6, 9, 8, 6, 4, 5, 7, 6, 9, 8, 6, 4, 5, 7, 6, 9, 8, 6, 4], [5, 4, 7, 8, 6, 7, 3, 5, 4, 7, 8, 6, 7, 3, 5, 4, 7, 8, 6, 7, 3], [7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7, 7, 8, 4, 7, 5, 9, 7], [3, 6, 3, 9, 6, 2, 4, 3, 6, 3, 9, 6, 2, 4, 3, 6, 3, 9, 6, 2, 4], [2, 9, 5, 4, 2, 4, 5, 2, 9, 5, 4, 2, 4, 5, 2, 9, 5, 4, 2, 4, 5], [5, 2, 8, 7, 8, 7, 9, 5, 2, 8, 7, 8, 7, 9, 5, 2, 8, 7, 8, 7, 9], [2, 8, 2, 5, 4, 5, 3, 2, 8, 2, 5, 4, 5, 3, 2, 8, 2, 5, 4, 5, 3], [4, 7, 6, 9, 8, 6, 5, 4, 7, 6, 9, 8, 6, 5, 4, 7, 6, 9, 8, 6, 5]]}, {""input"": [[8, 2, 7, 8, 2, 5, 9], [6, 7, 3, 9, 5, 9, 4], [5, 2, 5, 7, 3, 8, 3], [6, 7, 9, 8, 4, 6, 2], [9, 6, 2, 5, 6, 9, 6], [5, 2, 5, 6, 2, 6, 2], [7, 8, 3, 7, 6, 5, 6]], ""output"": [[8, 2, 7, 8, 2, 5, 9, 8, 2, 7, 8, 2, 5, 9, 8, 2, 7, 8, 2, 5, 9], [6, 7, 3, 9, 5, 9, 4, 6, 7, 3, 9, 5, 9, 4, 6, 7, 3, 9, 5, 9, 4], [5, 2, 5, 7, 3, 8, 3, 5, 2, 5, 7, 3, 8, 3, 5, 2, 5, 7, 3, 8, 3], [6, 7, 9, 8, 4, 6, 2, 6, 7, 9, 8, 4, 6, 2, 6, 7, 9, 8, 4, 6, 2], [9, 6, 2, 5, 6, 9, 6, 9, 6, 2, 5, 6, 9, 6, 9, 6, 2, 5, 6, 9, 6], [5, 2, 5, 6, 2, 6, 2, 5, 2, 5, 6, 2, 6, 2, 5, 2, 5, 6, 2, 6, 2], [7, 8, 3, 7, 6, 5, 6, 7, 8, 3, 7, 6, 5, 6, 7, 8, 3, 7, 6, 5, 6], [9, 2, 7, 8, 2, 5, 8, 9, 2, 7, 8, 2, 5, 8, 9, 2, 7, 8, 2, 5, 8], [4, 7, 3, 9, 5, 9, 6, 4, 7, 3, 9, 5, 9, 6, 4, 7, 3, 9, 5, 9, 6], [3, 2, 5, 7, 3, 8, 5, 3, 2, 5, 7, 3, 8, 5, 3, 2, 5, 7, 3, 8, 5], [2, 7, 9, 8, 4, 6, 6, 2, 7, 9, 8, 4, 6, 6, 2, 7, 9, 8, 4, 6, 6], [6, 6, 2, 5, 6, 9, 9, 6, 6, 2, 5, 6, 9, 9, 6, 6, 2, 5, 6, 9, 9], [2, 2, 5, 6, 2, 6, 5, 2, 2, 5, 6, 2, 6, 5, 2, 2, 5, 6, 2, 6, 5], [6, 8, 3, 7, 6, 5, 7, 6, 8, 3, 7, 6, 5, 7, 6, 8, 3, 7, 6, 5, 7], [8, 2, 7, 8, 2, 5, 9, 8, 2, 7, 8, 2, 5, 9, 8, 2, 7, 8, 2, 5, 9], [6, 7, 3, 9, 5, 9, 4, 6, 7, 3, 9, 5, 9, 4, 6, 7, 3, 9, 5, 9, 4], [5, 2, 5, 7, 3, 8, 3, 5, 2, 5, 7, 3, 8, 3, 5, 2, 5, 7, 3, 8, 3], [6, 7, 9, 8, 4, 6, 2, 6, 7, 9, 8, 4, 6, 2, 6, 7, 9, 8, 4, 6, 2], [9, 6, 2, 5, 6, 9, 6, 9, 6, 2, 5, 6, 9, 6, 9, 6, 2, 5, 6, 9, 6], [5, 2, 5, 6, 2, 6, 2, 5, 2, 5, 6, 2, 6, 2, 5, 2, 5, 6, 2, 6, 2], [7, 8, 3, 7, 6, 5, 6, 7, 8, 3, 7, 6, 5, 6, 7, 8, 3, 7, 6, 5, 6]]}, {""input"": [[9, 8, 4, 6, 5, 7, 6], [2, 6, 8, 3, 7, 4, 7], [4, 9, 4, 9, 2, 6, 9], [3, 6, 9, 4, 7, 4, 2], [5, 7, 2, 8, 4, 6, 3], [2, 5, 7, 2, 6, 2, 6], [4, 8, 2, 8, 2, 4, 7]], ""output"": [[9, 8, 4, 6, 5, 7, 6, 9, 8, 4, 6, 5, 7, 6, 9, 8, 4, 6, 5, 7, 6], [2, 6, 8, 3, 7, 4, 7, 2, 6, 8, 3, 7, 4, 7, 2, 6, 8, 3, 7, 4, 7], [4, 9, 4, 9, 2, 6, 9, 4, 9, 4, 9, 2, 6, 9, 4, 9, 4, 9, 2, 6, 9], [3, 6, 9, 4, 7, 4, 2, 3, 6, 9, 4, 7, 4, 2, 3, 6, 9, 4, 7, 4, 2], [5, 7, 2, 8, 4, 6, 3, 5, 7, 2, 8, 4, 6, 3, 5, 7, 2, 8, 4, 6, 3], [2, 5, 7, 2, 6, 2, 6, 2, 5, 7, 2, 6, 2, 6, 2, 5, 7, 2, 6, 2, 6], [4, 8, 2, 8, 2, 4, 7, 4, 8, 2, 8, 2, 4, 7, 4, 8, 2, 8, 2, 4, 7], [6, 8, 4, 6, 5, 7, 9, 6, 8, 4, 6, 5, 7, 9, 6, 8, 4, 6, 5, 7, 9], [7, 6, 8, 3, 7, 4, 2, 7, 6, 8, 3, 7, 4, 2, 7, 6, 8, 3, 7, 4, 2], [9, 9, 4, 9, 2, 6, 4, 9, 9, 4, 9, 2, 6, 4, 9, 9, 4, 9, 2, 6, 4], [2, 6, 9, 4, 7, 4, 3, 2, 6, 9, 4, 7, 4, 3, 2, 6, 9, 4, 7, 4, 3], [3, 7, 2, 8, 4, 6, 5, 3, 7, 2, 8, 4, 6, 5, 3, 7, 2, 8, 4, 6, 5], [6, 5, 7, 2, 6, 2, 2, 6, 5, 7, 2, 6, 2, 2, 6, 5, 7, 2, 6, 2, 2], [7, 8, 2, 8, 2, 4, 4, 7, 8, 2, 8, 2, 4, 4, 7, 8, 2, 8, 2, 4, 4], [9, 8, 4, 6, 5, 7, 6, 9, 8, 4, 6, 5, 7, 6, 9, 8, 4, 6, 5, 7, 6], [2, 6, 8, 3, 7, 4, 7, 2, 6, 8, 3, 7, 4, 7, 2, 6, 8, 3, 7, 4, 7], [4, 9, 4, 9, 2, 6, 9, 4, 9, 4, 9, 2, 6, 9, 4, 9, 4, 9, 2, 6, 9], [3, 6, 9, 4, 7, 4, 2, 3, 6, 9, 4, 7, 4, 2, 3, 6, 9, 4, 7, 4, 2], [5, 7, 2, 8, 4, 6, 3, 5, 7, 2, 8, 4, 6, 3, 5, 7, 2, 8, 4, 6, 3], [2, 5, 7, 2, 6, 2, 6, 2, 5, 7, 2, 6, 2, 6, 2, 5, 7, 2, 6, 2, 6], [4, 8, 2, 8, 2, 4, 7, 4, 8, 2, 8, 2, 4, 7, 4, 8, 2, 8, 2, 4, 7]]}], ""test"": [{""input"": [[3, 8, 7, 5, 6, 7, 3], [2, 5, 9, 6, 5, 9, 6], [6, 3, 5, 4, 2, 3, 2], [9, 6, 9, 6, 3, 5, 7], [6, 7, 5, 7, 8, 3, 9], [8, 2, 6, 9, 2, 4, 3], [4, 3, 9, 7, 9, 2, 8]], ""output"": [[3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3], [2, 5, 9, 6, 5, 9, 6, 2, 5, 9, 6, 5, 9, 6, 2, 5, 9, 6, 5, 9, 6], [6, 3, 5, 4, 2, 3, 2, 6, 3, 5, 4, 2, 3, 2, 6, 3, 5, 4, 2, 3, 2], [9, 6, 9, 6, 3, 5, 7, 9, 6, 9, 6, 3, 5, 7, 9, 6, 9, 6, 3, 5, 7], [6, 7, 5, 7, 8, 3, 9, 6, 7, 5, 7, 8, 3, 9, 6, 7, 5, 7, 8, 3, 9], [8, 2, 6, 9, 2, 4, 3, 8, 2, 6, 9, 2, 4, 3, 8, 2, 6, 9, 2, 4, 3], [4, 3, 9, 7, 9, 2, 8, 4, 3, 9, 7, 9, 2, 8, 4, 3, 9, 7, 9, 2, 8], [3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3], [6, 5, 9, 6, 5, 9, 2, 6, 5, 9, 6, 5, 9, 2, 6, 5, 9, 6, 5, 9, 2], [2, 3, 5, 4, 2, 3, 6, 2, 3, 5, 4, 2, 3, 6, 2, 3, 5, 4, 2, 3, 6], [7, 6, 9, 6, 3, 5, 9, 7, 6, 9, 6, 3, 5, 9, 7, 6, 9, 6, 3, 5, 9], [9, 7, 5, 7, 8, 3, 6, 9, 7, 5, 7, 8, 3, 6, 9, 7, 5, 7, 8, 3, 6], [3, 2, 6, 9, 2, 4, 8, 3, 2, 6, 9, 2, 4, 8, 3, 2, 6, 9, 2, 4, 8], [8, 3, 9, 7, 9, 2, 4, 8, 3, 9, 7, 9, 2, 4, 8, 3, 9, 7, 9, 2, 4], [3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3, 3, 8, 7, 5, 6, 7, 3], [2, 5, 9, 6, 5, 9, 6, 2, 5, 9, 6, 5, 9, 6, 2, 5, 9, 6, 5, 9, 6], [6, 3, 5, 4, 2, 3, 2, 6, 3, 5, 4, 2, 3, 2, 6, 3, 5, 4, 2, 3, 2], [9, 6, 9, 6, 3, 5, 7, 9, 6, 9, 6, 3, 5, 7, 9, 6, 9, 6, 3, 5, 7], [6, 7, 5, 7, 8, 3, 9, 6, 7, 5, 7, 8, 3, 9, 6, 7, 5, 7, 8, 3, 9], [8, 2, 6, 9, 2, 4, 3, 8, 2, 6, 9, 2, 4, 3, 8, 2, 6, 9, 2, 4, 3], [4, 3, 9, 7, 9, 2, 8, 4, 3, 9, 7, 9, 2, 8, 4, 3, 9, 7, 9, 2, 8]]}]}"
bzxnBqzNyhQp9ovXdDZA8M,2025-07-21T15:52:22.888095,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 8, 8, 6, 6, 6, 6, 5, 5, 0, 0, 0], [0, 0, 6, 6, 6, 8, 8, 6, 6, 6, 6, 5, 5, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [8, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 2, 2, 0], [0, 6, 6, 6, 6, 6, 6, 2, 2, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 2, 2, 6, 7, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 2, 2, 6, 7, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 4, 6, 6, 6, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [4, 5]]}]}"
cGgPpoNzJkZwwXcYwpjBg9,2025-07-21T15:52:22.894295,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 8, 8, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 8, 8, 1, 1, 1, 7, 7, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [8, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 1, 1, 1, 1, 1, 1, 0], [0, 8, 8, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 5, 5, 1, 1, 0], [0, 1, 1, 1, 1, 5, 5, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 7, 7, 1, 1, 1, 3, 3, 0], [0, 1, 7, 7, 1, 1, 1, 3, 3, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 5], [7, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 8, 8, 1, 5, 5, 1, 1, 0], [0, 1, 1, 1, 8, 8, 1, 5, 5, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 5], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 8], [0, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 0], [0, 2, 2, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 0], [0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 8], [9, 4]]}]}"
NoMYCLpAoHV3N4GiUGcQ44,2025-07-21T15:52:22.899712,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 6, 6, 4, 4, 7, 7, 4, 4, 0], [0, 4, 4, 4, 4, 6, 6, 4, 4, 7, 7, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 7], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0], [0, 7, 7, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0], [0, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [7, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 8, 8, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 8, 8, 4, 4, 0, 0, 0], [0, 0, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [3, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 3, 3, 4, 0, 0], [0, 0, 4, 8, 8, 4, 4, 3, 3, 4, 0, 0], [0, 0, 4, 8, 8, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 2, 2, 4, 4, 9, 9, 0, 0], [0, 0, 4, 4, 2, 2, 4, 4, 9, 9, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 3], [2, 9]]}]}"
F8pu5ic5GdU9pHPoCvCFvf,2025-07-21T15:52:22.905508,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 6, 6, 2, 0], [0, 8, 8, 2, 2, 2, 6, 6, 2, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 1, 1, 2, 2, 2, 2, 2, 0], [0, 2, 1, 1, 2, 3, 3, 2, 2, 0], [0, 2, 2, 2, 2, 3, 3, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 6], [1, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 7], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 5, 5, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 5, 5, 2, 2, 6, 6, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 6, 6, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 4, 4, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 4, 4, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 6], [4, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 5], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 6, 6, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 6, 6, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0], [0, 2, 2, 1, 1, 2, 2, 4, 4, 2, 0, 0], [0, 2, 2, 1, 1, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [1, 4]]}]}"
MAqACNpfBMn45KM8poyKPU,2025-07-21T15:52:22.910097,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 2, 2, 8, 8, 8, 7, 7, 8, 0], [0, 2, 2, 8, 8, 8, 7, 7, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 9, 9, 8, 8, 8, 8, 0], [0, 8, 8, 9, 9, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 6, 6, 8, 8, 8, 1, 1, 0], [0, 8, 6, 6, 8, 8, 8, 1, 1, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 9, 9, 8, 8, 8, 8, 8, 8, 8, 0], [0, 9, 9, 8, 8, 5, 5, 8, 8, 8, 0], [0, 8, 8, 8, 8, 5, 5, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0], [0, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [0, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 8, 8, 4, 4, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 4, 4, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 9, 9, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 9, 9, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 4], [0, 9]]}]}"
MsJzpqJhrADC4dw2gGirXu,2025-07-21T15:52:22.914956,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 4, 4, 3, 3, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 4, 4, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 7, 7, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 7, 7, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 7, 7, 0], [0, 3, 3, 3, 3, 3, 3, 3, 7, 7, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 7, 7, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 7, 7, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 0], [0, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [2, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 8, 8, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 8, 8, 3, 1, 1, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 1], [4, 0]]}]}"
C5bAtsiTjzUvx3AgUo7SXc,2025-07-21T15:52:22.918849,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 9, 9, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 9, 9, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 4, 4, 3, 7, 7, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 4, 4, 3, 7, 7, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [4, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 9, 9, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 9, 9, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 6, 6, 3, 3, 0], [0, 3, 3, 3, 3, 6, 6, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 8, 8, 0], [0, 3, 3, 3, 3, 3, 3, 8, 8, 0], [0, 2, 2, 3, 3, 3, 3, 3, 3, 0], [0, 2, 2, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [2, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 0]]}]}"
n5srZRmj7zbG8bYHSkL2yX,2025-07-21T15:52:22.921950,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 0], [0, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [3, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 6, 6, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 6, 6, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 2, 2, 0, 0], [0, 0, 3, 3, 8, 8, 8, 8, 8, 2, 2, 0, 0], [0, 0, 3, 3, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [3, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 1, 1, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 1, 1, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 2, 2, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 2, 2, 8, 8, 4, 4, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 9], [2, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 7, 7, 8, 8, 0], [0, 8, 8, 8, 8, 7, 7, 8, 8, 0], [0, 8, 3, 3, 8, 8, 8, 8, 8, 0], [0, 8, 3, 3, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 6, 6, 0], [0, 8, 8, 4, 4, 8, 8, 6, 6, 0], [0, 8, 8, 4, 4, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 7], [4, 6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 3, 3, 8, 8, 5, 5, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 6, 6, 8, 8, 8, 8, 4, 4, 8, 0, 0], [0, 8, 8, 8, 6, 6, 8, 8, 8, 8, 4, 4, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 5], [6, 4]]}]}"
B2CuBEjMx5fSHjp3P8v2Lm,2025-07-21T15:52:22.925042,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 0, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 2, 2, 0, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 7, 7, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 1, 7, 7, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 2], [4, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 6, 6, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 6, 6, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 5, 5, 1, 1, 1, 2, 2, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 2], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 5, 5, 1, 9, 9, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 9, 9, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [0, 7]]}]}"
nJ2ZJoCbf3eetxouDAafKm,2025-07-21T15:52:22.927949,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 1, 1, 0], [0, 3, 3, 3, 3, 3, 3, 1, 1, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 4, 4, 3, 3, 0], [0, 3, 7, 7, 3, 4, 4, 3, 3, 0], [0, 3, 7, 7, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [7, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 7, 7, 3, 3, 3, 3, 0, 0], [0, 3, 3, 1, 1, 3, 7, 7, 3, 3, 3, 3, 0, 0], [0, 3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 7], [6, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 8, 8, 3, 0], [0, 3, 3, 3, 3, 3, 8, 8, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 4, 4, 3, 5, 5, 3, 3, 0], [0, 3, 4, 4, 3, 5, 5, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [4, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 9, 9, 3, 3, 3, 3, 0], [0, 3, 3, 9, 9, 3, 1, 1, 3, 0], [0, 3, 3, 3, 3, 3, 1, 1, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 5, 5, 3, 3, 3, 8, 8, 0], [0, 3, 5, 5, 3, 3, 3, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 1], [5, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [8, 0]]}]}"
T3o46reSbvV2s8LFDp2pF5,2025-07-21T15:52:22.930873,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 2, 2, 6, 0, 0], [0, 6, 6, 6, 6, 6, 2, 2, 6, 0, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 8, 8, 6, 0, 0, 0], [0, 0, 6, 6, 4, 4, 6, 6, 8, 8, 6, 0, 0, 0], [0, 0, 6, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 8], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 0], [0, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [9, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 5, 5, 6, 6, 6, 6, 6, 6, 6, 0], [0, 5, 5, 6, 6, 1, 1, 6, 6, 6, 0], [0, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0], [0, 7, 7, 6, 6, 6, 6, 6, 6, 6, 0], [0, 7, 7, 6, 6, 4, 4, 6, 6, 6, 0], [0, 6, 6, 6, 6, 4, 4, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 1], [7, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 9, 9, 6, 6, 6, 6, 0], [0, 6, 6, 9, 9, 6, 6, 7, 7, 0], [0, 6, 6, 6, 6, 6, 6, 7, 7, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 8, 8, 0], [0, 6, 6, 5, 5, 6, 6, 8, 8, 0], [0, 6, 6, 5, 5, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [5, 8]]}]}"
cfSAQiVF4u2VEM4Ea4EPsi,2025-07-21T15:52:22.933473,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 8, 8, 0], [0, 9, 3, 3, 9, 9, 9, 8, 8, 0], [0, 9, 3, 3, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 7, 7, 9, 9, 0], [0, 9, 9, 9, 9, 7, 7, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 8], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 3, 3, 9, 9, 1, 1, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 1, 1, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 4, 4, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 4, 4, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 1], [4, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 7, 7, 9, 9, 9, 9, 0], [0, 9, 9, 7, 7, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 4, 4, 9, 9, 9, 9, 9, 0], [0, 9, 4, 4, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [4, 0]]}]}"
bmV583AxtW9XJN48jov8Cc,2025-07-21T15:52:22.936446,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 6, 6, 5, 5, 4, 4, 5, 5, 0, 0, 0], [0, 0, 0, 6, 6, 5, 5, 4, 4, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [1, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 5, 6, 6, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 3, 3, 5, 5, 5, 5, 5, 8, 8, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 6], [3, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 7, 7, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 7, 7, 5, 5, 5, 5, 5, 8, 8, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 8, 8, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 4, 4, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 4, 4, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 8], [0, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [9, 0]]}]}"
63pDX3iaM5kZfDgnr6927K,2025-07-21T15:52:22.939482,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 7, 7, 6, 6, 0], [0, 1, 1, 6, 6, 6, 7, 7, 6, 6, 0], [0, 1, 1, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 7], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 1, 1, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 0, 6, 1, 1, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 8], [1, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 4, 4, 6, 6, 6, 5, 5, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 5, 5, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 5], [2, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 2, 2, 6, 6, 6, 6, 6, 6, 0, 0], [0, 2, 2, 6, 6, 6, 6, 9, 9, 0, 0], [0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 9], [0, 7]]}]}"
XRwUro3tLKGjQ4CiLMyeLZ,2025-07-21T15:52:22.942290,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 0, 0, 0], [0, 0, 0, 4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 5, 5, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 5, 5, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 9, 9, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 9, 9, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 1, 1, 4, 9, 9, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 5, 5, 4, 4, 2, 2, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 2, 2, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 9], [5, 2]]}]}"
RW56DRhQ5izUVtWiDLQjTU,2025-07-21T15:52:22.945334,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 1, 1, 1, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [3, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 0], [0, 4, 4, 1, 1, 1, 1, 8, 8, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0], [0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0], [0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 0], [0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 8], [5, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 7, 7, 1, 0, 0], [0, 1, 1, 5, 5, 1, 7, 7, 1, 0, 0], [0, 1, 1, 5, 5, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 4, 4, 1, 1, 1, 2, 2, 0, 0], [0, 1, 4, 4, 1, 1, 1, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 7], [4, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 0], [0, 1, 8, 8, 1, 1, 1, 3, 3, 1, 1, 1, 1, 0], [0, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 2, 2, 0], [0, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 2, 2, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 3], [5, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 1, 5, 5, 1, 0, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 1, 5, 5, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 9, 9, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 9, 9, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 5], [9, 6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 3, 3, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 3, 3, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 8, 8, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 8, 8, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [8, 0]]}]}"
2WNcyWaAKKCrBUbTXFHy3Y,2025-07-21T15:52:22.949803,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 4, 4, 3, 3, 3, 3, 3, 0], [0, 3, 4, 4, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 5, 5, 3, 3, 3, 3, 3, 3, 0], [0, 5, 5, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 9, 9, 0], [0, 3, 3, 3, 3, 3, 3, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [5, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 5, 5, 0], [0, 3, 3, 3, 3, 3, 3, 5, 5, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 5, 5, 3, 0], [0, 3, 3, 3, 3, 3, 5, 5, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 7, 7, 3, 3, 3, 3, 3, 0, 0], [0, 3, 7, 7, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 4]]}]}"
de5LkUGjefNjXN9MtCZhEu,2025-07-21T15:52:22.952873,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [5, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0], [0, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [7, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [5, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 1, 1, 1, 1, 1, 4, 4, 0, 0, 0, 0], [0, 0, 0, 9, 9, 1, 1, 1, 1, 1, 4, 4, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 8, 8, 1, 6, 6, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 4], [8, 6]]}]}"
AeqHXwTYRALMzxodB6cr5t,2025-07-21T15:52:22.956005,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 4, 4, 7, 8, 8, 7, 7, 0, 0], [0, 7, 4, 4, 7, 8, 8, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 3, 3, 7, 7, 7, 7, 6, 6, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 2, 2, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [2, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 2, 2, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 7, 2, 2, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 3, 3, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 3, 3, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 2], [3, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 6, 6, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 0], [0, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 4, 4, 0], [0, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [9, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 4, 4, 7, 7, 7, 7, 7, 1, 1, 0, 0], [0, 7, 7, 4, 4, 7, 7, 7, 7, 7, 1, 1, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 8, 8, 7, 7, 7, 6, 6, 7, 0, 0], [0, 7, 7, 7, 8, 8, 7, 7, 7, 6, 6, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 1], [8, 6]]}]}"
9q7sgesVXCiJAofGTR7qEU,2025-07-21T15:52:22.959075,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 5, 5, 6, 6, 1, 1, 0, 0], [0, 0, 6, 6, 5, 5, 6, 6, 1, 1, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 4, 4, 6, 6, 6, 6, 2, 2, 0, 0], [0, 0, 4, 4, 6, 6, 6, 6, 2, 2, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 1], [4, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [9, 1]]}]}"
NzevoQrhvE7roREJLd79PQ,2025-07-21T15:52:22.962565,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 3, 3, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 3, 3, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 9, 9, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 9, 9, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 6, 6, 4, 3, 3, 4, 4, 0], [0, 4, 6, 6, 4, 3, 3, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 9, 9, 0], [0, 4, 4, 4, 4, 4, 4, 9, 9, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 3], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0, 0], [0, 0, 0, 1, 1, 4, 4, 9, 9, 4, 4, 0, 0, 0, 0], [0, 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 3, 3, 4, 4, 8, 8, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 8], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 9, 9, 0, 0], [0, 4, 4, 4, 4, 4, 4, 9, 9, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [0, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [6, 0]]}]}"
8c5dbW22ET4YJg4AXrLUPc,2025-07-21T15:52:22.967095,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 8, 8, 4, 4, 4, 4, 7, 7, 0, 0, 0, 0], [0, 0, 0, 8, 8, 4, 4, 4, 4, 7, 7, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 2], [1, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [8, 0]]}]}"
fRiUVBncycNFY6pRoFzwmK,2025-07-21T15:52:22.971148,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 6, 6, 1, 1, 1, 1, 1, 0], [0, 1, 1, 6, 6, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 7, 7, 1, 1, 1, 1, 1, 0], [0, 1, 1, 7, 7, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 9, 9, 1, 1, 5, 5, 1, 0], [0, 1, 1, 9, 9, 1, 1, 5, 5, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 6, 6, 1, 1, 1, 5, 5, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [6, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 5, 5, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 5, 5, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 6]]}]}"
aQKwzHXDWtB2pHnqb49KjE,2025-07-21T15:52:22.975147,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 3, 3, 1, 1, 1, 1, 1, 0], [0, 1, 3, 3, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 6, 6, 1, 1, 0], [0, 1, 1, 1, 1, 6, 6, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 9, 9, 1, 5, 5, 1, 0], [0, 1, 1, 9, 9, 1, 5, 5, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [9, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 2, 2, 1, 1, 0], [0, 4, 4, 1, 1, 2, 2, 1, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 7, 7, 1, 1, 1, 1, 1, 1, 0], [0, 7, 7, 1, 1, 1, 5, 5, 1, 0], [0, 1, 1, 1, 1, 1, 5, 5, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 2], [7, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 8, 8, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 8, 8, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 8, 8, 1, 1, 3, 3, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 8, 8, 1, 1, 3, 3, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [8, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 8, 8, 1, 1, 6, 6, 1, 1, 1, 0, 0], [0, 0, 1, 1, 8, 8, 1, 1, 6, 6, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 3, 3, 1, 1, 1, 1, 5, 5, 1, 0, 0], [0, 0, 1, 1, 3, 3, 1, 1, 1, 1, 5, 5, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 6], [3, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [7, 0]]}]}"
HrFo6aetGa5EYDDj7jdvC2,2025-07-21T15:52:22.978812,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 5, 5, 4, 0], [0, 4, 4, 4, 4, 4, 4, 5, 5, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 8, 8, 4, 0], [0, 4, 4, 4, 4, 4, 4, 8, 8, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 2, 2, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 2, 2, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 9, 9, 4, 4, 4, 4, 4, 4, 5, 5, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [9, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 5, 5, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [5, 7]]}]}"
PVeQDtY2hJENuP3FZsLkiA,2025-07-21T15:52:22.982958,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 0, 0, 0], [0, 0, 5, 6, 6, 5, 5, 5, 4, 4, 5, 5, 0, 0, 0], [0, 0, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [7, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 9, 9, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 9, 9, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 5, 8, 8, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 5, 8, 8, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 8], [0, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 5, 8, 8, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 5, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0], [0, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [0, 0]]}]}"
VfUt3kNv39ZCzW8F5TEvME,2025-07-21T15:52:22.987127,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 2, 2, 6, 6, 9, 9, 6, 0, 0, 0, 0], [0, 0, 0, 6, 2, 2, 6, 6, 9, 9, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 5, 5, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 6, 6, 5, 5, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 9], [4, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 0], [0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 9, 9, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 9, 9, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 4, 4, 6, 6, 6, 6, 0, 0], [0, 6, 6, 4, 4, 6, 9, 9, 6, 0, 0], [0, 6, 6, 6, 6, 6, 9, 9, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [8, 0]]}]}"
jFMKRLFvmaGDah39ReMRJp,2025-07-21T15:52:22.990287,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 7, 7, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 7, 7, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 2], [7, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 5, 5, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 5, 5, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 8, 8, 6, 6, 9, 9, 6, 6, 6, 0, 0, 0], [0, 0, 8, 8, 6, 6, 9, 9, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 5], [8, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 4, 4, 6, 3, 3, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 4, 4, 6, 3, 3, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 8, 8, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 8, 8, 6, 6, 6, 6, 2, 2, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 3], [8, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 4, 4, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 4, 4, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}]}"
j5dWyD2q9tVCTao7Wo9RQW,2025-07-21T15:52:22.993248,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 6, 6, 9, 9, 9, 1, 1, 0, 0, 0, 0], [0, 0, 0, 9, 6, 6, 9, 9, 9, 1, 1, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9, 0, 0], [0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [6, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 1, 1, 9, 9, 9, 9, 3, 3, 0, 0], [0, 9, 9, 1, 1, 9, 9, 9, 9, 3, 3, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [1, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 1, 1, 9, 9, 9, 9, 4, 4, 9, 9, 0, 0], [0, 1, 1, 9, 9, 9, 9, 4, 4, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 4], [8, 6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 3, 3, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 3, 3, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}]}"
XVzP8q6JcErdnUoXx8xSD9,2025-07-21T15:52:22.995814,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 3, 3, 6, 7, 7, 6, 6, 0], [0, 6, 3, 3, 6, 7, 7, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 8, 8, 6, 6, 6, 6, 5, 5, 0], [0, 8, 8, 6, 6, 6, 6, 5, 5, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 7], [8, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0], [0, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0], [0, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0], [0, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 1], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 4], [8, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 4, 4, 6, 1, 1, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 1, 1, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 8, 8, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 8, 8, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 1], [0, 8]]}]}"
A8USu3nYo8iY6LwVdPF5FU,2025-07-21T15:52:22.998181,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 3, 3, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 3, 3, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 6, 6, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 6, 6, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [6, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 5, 5, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 5, 5, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 2, 2, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 2, 2, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 1, 1, 7, 7, 0], [0, 7, 7, 7, 7, 1, 1, 7, 7, 0], [0, 6, 6, 7, 7, 7, 7, 7, 7, 0], [0, 6, 6, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 3, 3, 7, 0], [0, 9, 9, 7, 7, 7, 3, 3, 7, 0], [0, 9, 9, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 1], [9, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 2, 2, 7, 7, 7, 7, 0], [0, 7, 7, 2, 2, 7, 7, 6, 6, 0], [0, 7, 7, 7, 7, 7, 7, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [2, 6]]}]}"
TqQ8ez7xbzPoWjB63mEuzG,2025-07-21T15:52:23.000989,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 4, 4, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 4, 4, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 3, 3, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 3, 3, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 8, 8, 2, 2, 2, 2, 2, 0], [0, 2, 2, 8, 8, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0], [0, 3, 3, 2, 2, 2, 9, 9, 2, 0, 0], [0, 2, 2, 2, 2, 2, 9, 9, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 7, 7, 2, 2, 0, 0], [0, 2, 2, 2, 2, 7, 7, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 9], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [0, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 9, 9, 2, 2, 2, 2, 2, 0], [0, 2, 9, 9, 2, 2, 8, 8, 2, 0], [0, 2, 2, 2, 2, 2, 8, 8, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 5, 5, 2, 3, 3, 2, 0], [0, 2, 2, 5, 5, 2, 3, 3, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [5, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 8, 8, 2, 0, 0], [0, 4, 4, 2, 2, 2, 8, 8, 2, 0, 0], [0, 4, 4, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 5, 5, 2, 2, 2, 2, 2, 0, 0], [0, 2, 5, 5, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 7, 7, 2, 0, 0], [0, 2, 2, 2, 2, 2, 7, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 8], [5, 7]]}]}"
bSj5B5R8ZbN8Ucpst3uU7i,2025-07-21T15:52:23.003879,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 9, 9, 7, 7, 7, 7, 0, 0], [0, 7, 7, 9, 9, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 6, 6, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 6, 6, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 6, 6, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 7, 6, 6, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 9, 9, 7, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 9, 9, 7, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 6], [1, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 3, 3, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 8], [3, 5]]}]}"
CDLUf7vAoev6dTuYGt855z,2025-07-21T15:52:23.006879,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 6, 6, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 6, 6, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 7, 7, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 7, 7, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 0], [0, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 3], [9, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 7, 7, 2, 2, 2, 2, 0], [0, 2, 2, 7, 7, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [7, 0]]}]}"
6WUWcBge8DDURoyfDwo2wQ,2025-07-21T15:52:23.009622,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 2, 2, 9, 9, 3, 3, 9, 0, 0], [0, 9, 2, 2, 9, 9, 3, 3, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 6, 6, 9, 9, 9, 9, 9, 9, 0, 0], [0, 6, 6, 9, 9, 9, 9, 8, 8, 0, 0], [0, 9, 9, 9, 9, 9, 9, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 3], [6, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 9, 0, 0], [0, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 7, 7, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 7, 7, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 2, 2, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 2, 2, 0, 0], [0, 0, 9, 9, 6, 6, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 6, 6, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 4, 4, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 4, 4, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 2], [6, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 4, 4, 0, 0], [0, 9, 9, 9, 9, 9, 9, 4, 4, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}]}"
DFp4byi289ERVKZxLwVyot,2025-07-21T15:52:23.012799,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 6, 6, 2, 2, 2, 2, 2, 0], [0, 2, 6, 6, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 4, 4, 2, 0], [0, 2, 2, 2, 2, 2, 4, 4, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 1, 1, 2, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 1], [5, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 1, 1, 2, 2, 0], [0, 2, 2, 2, 2, 1, 1, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 3, 3, 2, 2, 0], [0, 2, 7, 7, 2, 3, 3, 2, 2, 0], [0, 2, 7, 7, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [7, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 6, 6, 2, 2, 2, 2, 3, 3, 0], [0, 6, 6, 2, 2, 2, 2, 3, 3, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 5, 5, 2, 2, 2, 2, 2, 2, 0], [0, 5, 5, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 3], [5, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0], [0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 3, 3, 2, 0, 0], [0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [1, 3]]}]}"
coNJNhZazJqogfuUJw4kfw,2025-07-21T15:52:23.015404,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 1, 1, 4, 4, 4, 7, 7, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 7], [3, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 6, 6, 0, 0], [0, 4, 4, 4, 4, 4, 4, 6, 6, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [5, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 9, 9, 4, 4, 4, 4, 4, 0], [0, 4, 9, 9, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 3, 3, 4, 4, 4, 4, 4, 0], [0, 4, 4, 3, 3, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [0, 0]]}]}"
EqHGhuYWyGrk9ugTZdrS3n,2025-07-21T15:52:23.018454,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 6, 6, 9, 9, 9, 0], [0, 9, 1, 1, 9, 6, 6, 9, 9, 9, 0], [0, 9, 1, 1, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 8, 8, 9, 0], [0, 9, 9, 9, 9, 9, 9, 8, 8, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 6], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 5, 5, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 5, 5, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 5, 5, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 5, 5, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 1, 1, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 6], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 6, 6, 9, 9, 9, 9, 9, 9, 0], [0, 6, 6, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 2, 2, 9, 0], [0, 9, 9, 9, 9, 9, 2, 2, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [0, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [2, 7]]}]}"
ZSjFvcbZhmKEahDTthHE9X,2025-07-21T15:52:23.021645,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 3, 3, 4, 4, 0], [0, 1, 1, 4, 4, 3, 3, 4, 4, 0], [0, 1, 1, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [1, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 6, 6, 4, 4, 4, 4, 4, 0], [0, 4, 6, 6, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 7, 7, 4, 4, 4, 9, 9, 0], [0, 4, 7, 7, 4, 4, 4, 9, 9, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 2, 2, 0], [0, 4, 4, 5, 5, 4, 4, 2, 2, 0], [0, 4, 4, 5, 5, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 9], [5, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 3, 3, 0, 0], [0, 5, 5, 4, 4, 4, 4, 3, 3, 0, 0], [0, 5, 5, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 7, 7, 4, 4, 4, 4, 4, 0, 0], [0, 4, 7, 7, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [7, 0]]}]}"
33AzsJUpc3ZWAUVoe42x64,2025-07-21T15:52:23.024484,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 6, 6, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 6, 6, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 4, 4, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 4, 4, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 5, 5, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 5, 5, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [5, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0], [0, 1, 5, 5, 1, 1, 3, 3, 1, 0, 0], [0, 1, 1, 1, 1, 1, 3, 3, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0], [0, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 3, 3, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 3, 3, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 3], [0, 0]]}]}"
5RzRsvEzeCcfKCynYFbDgB,2025-07-21T15:52:23.027395,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 9, 9, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [0, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 7, 7, 6, 6, 6, 6, 9, 9, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 9, 9, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 8, 8, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0], [0, 0, 8, 8, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 9], [8, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 8, 8, 6, 6, 9, 9, 6, 6, 6, 6, 0], [0, 6, 6, 8, 8, 6, 6, 9, 9, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 9], [1, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 6, 6, 6, 6, 6, 6, 6, 0], [0, 1, 1, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 9, 9, 6, 6, 6, 6, 6, 0], [0, 6, 6, 9, 9, 6, 5, 5, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [9, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 1, 1, 0, 0], [0, 6, 6, 6, 6, 6, 6, 1, 1, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 8, 8, 6, 6, 6, 6, 6, 0, 0], [0, 6, 8, 8, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [8, 0]]}]}"
V4MVTkY3Rn2k2pkgasWWFo,2025-07-21T15:52:23.030361,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 6, 6, 4, 4, 5, 5, 4, 0], [0, 4, 6, 6, 4, 4, 5, 5, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 5], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [5, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 3, 3, 4, 4, 0], [0, 4, 4, 4, 4, 3, 3, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}]}"
RztBunp5q8FHMudskAQDEg,2025-07-21T15:52:23.033299,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 3, 3, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 3, 3, 0, 0, 0], [0, 0, 0, 7, 5, 5, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 5, 5, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 9, 9, 7, 7, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 9, 9, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 6], [5, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 0, 0], [0, 0, 7, 7, 4, 4, 7, 7, 5, 5, 0, 0], [0, 0, 7, 7, 4, 4, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 6, 6, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 6, 6, 7, 7, 1, 1, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 5], [6, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 3, 3, 7, 7, 6, 6, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [0, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 6, 6, 7, 7, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 6, 6, 7, 7, 0, 0, 0], [0, 0, 5, 5, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 1, 1, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 2, 2, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 2, 2, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 6], [1, 2]]}]}"
bSA8wequdT4bU4p2jwuXFf,2025-07-21T15:52:23.036519,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 5, 5, 9, 0, 0], [0, 9, 9, 9, 1, 1, 9, 9, 5, 5, 9, 0, 0], [0, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 3, 3, 9, 9, 9, 2, 2, 0, 0], [0, 9, 9, 9, 3, 3, 9, 9, 9, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 5], [3, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 3, 3, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 3, 3, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 4, 4, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 4, 4, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [4, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9, 0], [0, 9, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 6], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 6, 6, 9, 9, 9, 0], [0, 9, 9, 9, 9, 6, 6, 9, 9, 9, 0], [0, 9, 8, 8, 9, 9, 9, 9, 9, 9, 0], [0, 9, 8, 8, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 2, 2, 9, 9, 0, 0], [0, 9, 9, 9, 9, 2, 2, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 1, 1, 0, 0], [0, 9, 9, 9, 9, 9, 9, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 1]]}]}"
N9ce2e2bXD8ndy4WTcxvJB,2025-07-21T15:52:23.039783,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 3, 3, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 3, 3, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [1, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 0, 0], [0, 0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [9, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 4, 4, 6, 6, 5, 5, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 5, 5, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 2, 2, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 2, 2, 6, 6, 7, 7, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 7, 7, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 5], [2, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 3, 3, 6, 6, 2, 2, 6, 0], [0, 6, 6, 3, 3, 6, 6, 2, 2, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 2], [0, 0]]}]}"
nEJqCGX6cWLLwULbM2xhyj,2025-07-21T15:52:23.042743,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 7, 7, 0], [0, 9, 9, 9, 9, 9, 9, 7, 7, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 2, 2, 9, 9, 0], [0, 9, 9, 9, 9, 2, 2, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 8, 8, 9, 9, 9, 9, 9, 5, 5, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 5, 5, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 9, 9, 9, 1, 1, 9, 9, 9, 9, 0, 0], [0, 0, 5, 5, 9, 9, 9, 1, 1, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 7, 7, 9, 9, 9, 0, 0], [0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 1], [2, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 8, 8, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 8, 8, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 3, 3, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 3, 3, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 3], [0, 0]]}]}"
PUKoPz4sALZbJWfpd8wZYg,2025-07-21T15:52:23.045532,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 4, 1, 1, 4, 4, 9, 9, 4, 0, 0], [0, 4, 4, 4, 4, 4, 9, 9, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 9], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 0], [0, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 0], [0, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [3, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 1, 1, 4, 2, 2, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 2], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [0, 0]]}]}"
noyPZd23z9j7bKuu7u43wT,2025-07-21T15:52:23.048304,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 8, 8, 5, 5, 5, 5, 0, 0], [0, 5, 5, 8, 8, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 7, 7, 5, 0, 0], [0, 5, 5, 6, 6, 5, 7, 7, 5, 0, 0], [0, 5, 5, 6, 6, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [6, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 9, 9, 5, 0, 0], [0, 5, 5, 5, 5, 5, 9, 9, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 7, 7, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 7, 7, 5, 5, 0, 0, 0], [0, 0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [2, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 3, 3, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 3, 3, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 8, 8, 0], [0, 5, 5, 5, 5, 5, 5, 8, 8, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 8]]}]}"
EgikCArNYwFHauMbEregdx,2025-07-21T15:52:23.051976,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 2, 2, 4, 3, 3, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 2, 2, 4, 3, 3, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 8, 8, 4, 4, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 8, 8, 4, 4, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 3], [8, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 9, 9, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 9, 9, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 7, 7, 0, 0, 0], [0, 0, 4, 4, 5, 5, 4, 4, 4, 7, 7, 0, 0, 0], [0, 0, 4, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 6], [5, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [3, 6]]}]}"
Q8TcM9EWjruZmmfXsKw9rB,2025-07-21T15:52:23.054876,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 6, 6, 7, 7, 7, 7, 7, 0, 0], [0, 7, 6, 6, 7, 1, 1, 7, 7, 0, 0], [0, 7, 7, 7, 7, 1, 1, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 5, 5, 7, 7, 0, 0], [0, 7, 7, 7, 7, 5, 5, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 1], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 9, 9, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 9, 9, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 8, 8, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 8, 8, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [0, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 4, 4, 7, 7, 7, 7, 0, 0, 0], [0, 0, 9, 9, 7, 7, 7, 4, 4, 7, 7, 7, 7, 0, 0, 0], [0, 0, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 6, 6, 7, 7, 7, 8, 8, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 4], [6, 8]]}]}"
EUNThZafraUkycEVAAxNpp,2025-07-21T15:52:23.057678,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 8, 8, 3, 0], [0, 3, 3, 3, 3, 3, 8, 8, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 6, 6, 0], [0, 3, 3, 3, 3, 3, 3, 6, 6, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 8, 8, 3, 3, 3, 3, 3, 0], [0, 3, 8, 8, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 7, 7, 3, 3, 3, 3, 3, 3, 0], [0, 7, 7, 3, 3, 3, 1, 1, 3, 0], [0, 3, 3, 3, 3, 3, 1, 1, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [7, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [0, 0]]}]}"
eQCdTpNiL7o5jToFUBQ6j6,2025-07-21T15:52:23.060621,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 4, 4, 4, 4, 4, 4, 0], [0, 8, 8, 4, 4, 4, 9, 9, 4, 0], [0, 4, 4, 4, 4, 4, 9, 9, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 2, 2, 4, 4, 6, 6, 4, 0], [0, 4, 2, 2, 4, 4, 6, 6, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 9], [2, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 3, 3, 4, 6, 6, 4, 4, 0, 0], [0, 4, 4, 3, 3, 4, 6, 6, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [5, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 2, 2, 4, 4, 4, 6, 6, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 6, 6, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 7, 7, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 7, 7, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 0], [0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 7, 7, 4, 4, 4, 2, 2, 0], [0, 4, 4, 7, 7, 4, 4, 4, 2, 2, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [7, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 2, 2, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 2, 2, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 0]]}]}"
Yu5aKa6AdTnsztLRRXWHXw,2025-07-21T15:52:23.063728,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 8, 8, 2, 2, 0], [0, 2, 2, 9, 9, 2, 8, 8, 2, 2, 0], [0, 2, 2, 9, 9, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [9, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 8, 8, 2, 2, 2, 7, 7, 0, 0], [0, 2, 2, 8, 8, 2, 2, 2, 7, 7, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 9, 9, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 9, 9, 2, 2, 3, 3, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 7], [9, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [5, 0]]}]}"
3AYicEkPcjuFkoun4he69u,2025-07-21T15:52:23.066675,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 2, 2, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 2, 2, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0], [0, 4, 3, 3, 4, 4, 1, 1, 4, 4, 0, 0], [0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [3, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 0], [0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 7, 7, 0], [0, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 6, 6, 0], [0, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 6, 6, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 7], [9, 6]]}]}"
LXbCvdXXbyD3Fx5ykYngqr,2025-07-21T15:52:23.070273,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 7, 7, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 7, 7, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 3, 3, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 9, 9, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 9, 9, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [7, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 3, 3, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 3, 3, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 1, 1, 6, 6, 6, 6, 4, 4, 0, 0, 0, 0], [0, 0, 0, 6, 1, 1, 6, 6, 6, 6, 4, 4, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 8], [1, 4]]}]}"
faY5xhTYzMJG6T6ff3Md8R,2025-07-21T15:52:23.074056,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 6, 6, 5, 5, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 6, 6, 5, 5, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 7], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 4, 4, 5, 5, 5, 5, 6, 6, 5, 0], [0, 5, 4, 4, 5, 5, 5, 5, 6, 6, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 2, 2, 5, 3, 3, 5, 5, 5, 0], [0, 5, 5, 2, 2, 5, 3, 3, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 6], [2, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 1, 1, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 1, 1, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 9, 9, 5, 5, 2, 2, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 9, 9, 5, 5, 2, 2, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [9, 2]]}]}"
GrsXqXs2pmrVYxxqesBqvH,2025-07-21T15:52:23.077571,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 6, 6, 3, 4, 4, 3, 0, 0, 0], [0, 0, 0, 3, 3, 6, 6, 3, 4, 4, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 2, 2, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 2, 2, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 7, 7, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 7, 7, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 2, 2, 3, 6, 6, 3, 3, 3, 0, 0], [0, 0, 3, 3, 2, 2, 3, 6, 6, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 7, 7, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 7, 7, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 1, 1, 3, 3, 3, 9, 9, 0, 0], [0, 3, 3, 1, 1, 3, 3, 3, 9, 9, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 4, 4, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 4, 4, 3, 3, 3, 3, 5, 5, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 5, 5, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 9], [4, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 7, 7, 0], [0, 3, 2, 2, 3, 3, 3, 7, 7, 0], [0, 3, 2, 2, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 1, 1, 3, 0], [0, 3, 3, 3, 3, 3, 1, 1, 3, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [9, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 4, 4, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 4, 4, 3, 5, 5, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 5, 5, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 9, 9, 3, 3, 3, 3, 7, 7, 0, 0, 0], [0, 0, 9, 9, 3, 3, 3, 3, 7, 7, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 5], [9, 7]]}]}"
hVuMiHnsSM4knTKk2DfySc,2025-07-21T15:52:23.081043,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 7, 7, 4, 4, 4, 4, 4, 4, 0], [0, 4, 7, 7, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0], [0, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0], [0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 3, 3, 4, 4, 0], [0, 4, 8, 8, 4, 3, 3, 4, 4, 0], [0, 4, 8, 8, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 9, 9, 4, 4, 4, 4, 4, 0], [0, 4, 9, 9, 4, 4, 6, 6, 4, 0], [0, 4, 4, 4, 4, 4, 6, 6, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 3], [9, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 6, 6, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 6, 6, 4, 5, 5, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 5, 5, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 5], [3, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 5, 5, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 5, 5, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 8], [3, 5]]}]}"
eVXZDCFZPbWiT77fgeGbzj,2025-07-21T15:52:23.084770,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 1, 1, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 4, 4, 4, 4, 4, 4, 0, 0], [0, 6, 6, 4, 4, 2, 2, 4, 4, 0, 0], [0, 4, 4, 4, 4, 2, 2, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 2], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 5, 5, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [5, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 7, 7, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 7, 7, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [0, 0]]}]}"
AGXRneyMLcSji7LHu2odaL,2025-07-21T15:52:23.088072,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 6, 6, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0], [0, 6, 6, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 9, 9, 4, 4, 4, 4, 2, 2, 4, 4, 0, 0], [0, 9, 9, 4, 4, 4, 4, 2, 2, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 7], [9, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 0], [0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 8], [5, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 7, 7, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 7, 7, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [0, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 8]]}]}"
Y735A9syaJwEN8SGWpDVxR,2025-07-21T15:52:23.090827,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 7, 7, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 1, 1, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 1, 1, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 1, 1, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 1, 1, 8, 2, 2, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 9, 9, 8, 8, 4, 4, 8, 0, 0], [0, 8, 8, 8, 9, 9, 8, 8, 4, 4, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 2], [9, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 4, 4, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 4, 4, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [0, 9]]}]}"
hsxeZpDokUzMRu9ZnF33JT,2025-07-21T15:52:23.093854,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 5, 5, 3, 3, 3, 3, 3, 3, 7, 7, 3, 0, 0], [0, 0, 5, 5, 3, 3, 3, 3, 3, 3, 7, 7, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 2, 2, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 7], [2, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 3, 1, 1, 3, 3, 3, 4, 4, 0, 0], [0, 3, 1, 1, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 7, 7, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 7, 7, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 9, 9, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 9, 9, 3, 3, 8, 8, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 8, 8, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 4], [9, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 5, 5, 3, 3, 0, 0], [0, 3, 3, 3, 3, 5, 5, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 8, 8, 3, 3, 3, 3, 0, 0], [0, 3, 3, 8, 8, 3, 3, 9, 9, 0, 0], [0, 3, 3, 3, 3, 3, 3, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 5], [8, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 7, 7, 3, 3, 8, 8, 3, 0], [0, 3, 3, 7, 7, 3, 3, 8, 8, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 3, 0], [0, 9, 9, 3, 3, 3, 3, 4, 4, 3, 0], [0, 9, 9, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 8], [9, 4]]}]}"
J6mq5SLqXnV7PCvjCnDuqJ,2025-07-21T15:52:23.096934,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 5, 5, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 5, 5, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 9, 9, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 9, 9, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 7, 7, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 7, 7, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 8, 8, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 8, 8, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [8, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 6, 6, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 6, 6, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 3, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 0, 0], [0, 3, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 4], [8, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 8, 8, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 8, 8, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [8, 4]]}]}"
4EE5fDsEH5sGhKzkL5z6Lh,2025-07-21T15:52:23.100762,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 9, 9, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 0, 0], [0, 9, 9, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [9, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 0, 5, 7, 7, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 7, 7, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 3, 3, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 1], [7, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 9, 9, 5, 5, 5, 5, 2, 2, 0, 0, 0], [0, 0, 9, 9, 5, 5, 5, 5, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [9, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 6, 6, 5, 5, 5, 5, 5, 2, 2, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 9, 9, 5, 5, 7, 7, 5, 5, 5, 5, 0, 0], [0, 5, 9, 9, 5, 5, 7, 7, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 2], [9, 7]]}]}"
TZrzhYMZEEMe9AqqShXfL6,2025-07-21T15:52:23.105116,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 2, 2, 6, 0], [0, 8, 8, 6, 6, 6, 2, 2, 6, 0], [0, 8, 8, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 2], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [5, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0], [0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 0, 0], [0, 6, 6, 6, 6, 6, 5, 5, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [0, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 3, 3, 6, 1, 1, 6, 6, 6, 0, 0], [0, 6, 3, 3, 6, 1, 1, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 7, 7, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 7, 7, 6, 6, 6, 9, 9, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 9, 9, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 1], [7, 9]]}]}"
ezJk3CJxW7Ai6scafZw8ox,2025-07-21T15:52:23.108415,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 8, 8, 3, 3, 2, 2, 3, 3, 0, 0, 0, 0], [0, 0, 0, 8, 8, 3, 3, 2, 2, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 2, 2, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 2, 2, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [6, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 3, 9, 9, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 0], [0, 3, 3, 3, 3, 3, 3, 4, 4, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 5, 5, 3, 3, 0], [0, 3, 3, 3, 3, 5, 5, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 4], [0, 5]]}]}"
FCAF63qPHfXiVvtAKS7pX6,2025-07-21T15:52:23.111591,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 4, 4, 4, 1, 1, 4, 0], [0, 3, 3, 4, 4, 4, 1, 1, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 9, 9, 4, 4, 0], [0, 8, 8, 4, 4, 9, 9, 4, 4, 0], [0, 8, 8, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 1], [8, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 9], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 6, 6, 4, 4, 4, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 4, 8, 8, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 3, 3, 4, 4, 8, 8, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 6], [3, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [0, 0]]}]}"
E4SNfXgtQ9mpDDcEQ85QAc,2025-07-21T15:52:23.115405,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 7, 7, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 7, 7, 5, 5, 5, 9, 9, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 9], [4, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 4, 4, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 4, 4, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 9, 9, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 9, 9, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 1, 1, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 1, 1, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 0], [0, 5, 4, 4, 5, 5, 5, 5, 5, 7, 7, 0], [0, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5, 0], [0, 5, 5, 3, 3, 5, 5, 5, 9, 9, 5, 0], [0, 5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 7], [3, 9]]}]}"
6KLngND5zKk44SZz8QcB5k,2025-07-21T15:52:23.118799,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 5, 5, 7, 7, 7, 7, 4, 4, 7, 0], [0, 7, 5, 5, 7, 7, 7, 7, 4, 4, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [5, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 4, 4, 7, 7, 0], [0, 7, 5, 5, 7, 7, 4, 4, 7, 7, 0], [0, 7, 5, 5, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 9, 9, 7, 7, 7, 7, 6, 6, 0], [0, 7, 9, 9, 7, 7, 7, 7, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 4], [9, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 4, 4, 0], [0, 8, 8, 7, 7, 7, 7, 4, 4, 0], [0, 8, 8, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 6, 6, 7, 7, 0], [0, 7, 7, 7, 7, 6, 6, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 3, 3, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 3, 3, 7, 7, 0, 0], [0, 7, 1, 1, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 1, 1, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 9, 9, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 9, 9, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 6, 6, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 6, 6, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 3], [9, 6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 1, 1, 0, 0], [0, 7, 7, 7, 7, 7, 7, 1, 1, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 8, 8, 7, 7, 7, 7, 0, 0], [0, 7, 7, 8, 8, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 6, 6, 0, 0], [0, 7, 7, 7, 7, 7, 7, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [8, 6]]}]}"
KwY7xjVRSULsA8S5DEmVzL,2025-07-21T15:52:23.121658,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 8, 8, 6, 6, 0], [0, 6, 6, 6, 6, 8, 8, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 1, 1, 6, 6, 6, 6, 6, 0], [0, 6, 1, 1, 6, 9, 9, 6, 6, 0], [0, 6, 6, 6, 6, 9, 9, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [1, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 2, 2, 6, 0, 0], [0, 0, 5, 5, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 5, 5, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [5, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 4, 4, 6, 6, 6, 6, 6, 2, 2, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 2], [0, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 2, 2, 6, 6, 6, 6, 6, 0], [0, 6, 6, 2, 2, 6, 6, 6, 7, 7, 0], [0, 6, 6, 6, 6, 6, 6, 6, 7, 7, 0], [0, 6, 6, 5, 5, 6, 6, 6, 6, 6, 0], [0, 6, 6, 5, 5, 6, 8, 8, 6, 6, 0], [0, 6, 6, 6, 6, 6, 8, 8, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [5, 8]]}]}"
dRCZKX4Gc6NiwPDQutHw8P,2025-07-21T15:52:23.124534,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [5, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 6, 6, 1, 9, 9, 1, 1, 1, 0, 0], [0, 0, 1, 6, 6, 1, 9, 9, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 9], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [2, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0], [0, 0, 1, 5, 5, 1, 2, 2, 1, 1, 0, 0], [0, 0, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 7, 7, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 7, 7, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 2], [0, 7]]}]}"
ctEuwaBDQHDzMkVA2NtYMB,2025-07-21T15:52:23.127790,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 1, 1, 2, 2, 1, 1, 1, 0, 0], [0, 0, 3, 3, 1, 1, 2, 2, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 4, 4, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 4, 4, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 2], [8, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 7], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 6, 6, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 6, 6, 1, 5, 5, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 5, 5, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 5], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 9, 9, 1, 1, 0], [0, 5, 5, 1, 1, 9, 9, 1, 1, 0], [0, 5, 5, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 8, 8, 1, 7, 7, 1, 1, 0], [0, 1, 8, 8, 1, 7, 7, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [8, 7]]}]}"
aZ8jdxUsuxLdJLKCRgaf7R,2025-07-21T15:52:23.131430,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 5, 5, 1, 1, 1, 3, 3, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 9, 9, 1, 1, 1, 7, 7, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [9, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 2, 2, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 2, 2, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 9, 9, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 9, 9, 1, 1, 1, 8, 8, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 8, 8, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 2], [9, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 4, 4, 1, 0, 0, 0], [0, 0, 1, 1, 7, 7, 1, 1, 1, 1, 4, 4, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 4], [2, 0]]}]}"
Sc5998yQKzyekxap9LUvKg,2025-07-21T15:52:23.134229,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 0, 0], [0, 0, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [4, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 5, 5, 5, 5, 5, 5, 0], [0, 2, 2, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 9, 9, 5, 5, 5, 5, 7, 7, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 7, 7, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 4, 4, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 5, 4, 4, 5, 5, 1, 1, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [4, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 0, 0], [0, 0, 5, 5, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 8, 8, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [6, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 7, 7, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 7, 7, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 9, 9, 5, 5, 5, 5, 5, 6, 6, 5, 0, 0, 0], [0, 0, 0, 9, 9, 5, 5, 5, 5, 5, 6, 6, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 1], [9, 6]]}]}"
URDdLrAXsWWDXokWq7CHmf,2025-07-21T15:52:23.137308,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 1, 1, 6, 6, 0], [0, 6, 3, 3, 6, 1, 1, 6, 6, 0], [0, 6, 3, 3, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [3, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0], [0, 6, 6, 6, 6, 3, 3, 6, 6, 6, 0], [0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0], [0, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 0], [0, 6, 2, 2, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 3], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 6, 6, 0], [0, 6, 6, 1, 1, 6, 6, 3, 3, 0], [0, 6, 6, 6, 6, 6, 6, 3, 3, 0], [0, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 4, 4, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 7, 7, 6, 6, 0], [0, 6, 6, 6, 6, 7, 7, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 3], [4, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 8, 8, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 6, 6, 8, 8, 6, 6, 6, 9, 9, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 2, 2, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 2, 2, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 9], [4, 2]]}]}"
iB4zNqCvkoYGqdUe28F3oj,2025-07-21T15:52:23.140060,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 0], [0, 1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 3, 3, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 3, 3, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [4, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 5, 5, 1, 1, 1, 1, 1, 0], [0, 1, 5, 5, 1, 1, 1, 9, 9, 0], [0, 1, 1, 1, 1, 1, 1, 9, 9, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 6, 6, 0], [0, 1, 1, 1, 1, 1, 1, 6, 6, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 9], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 8, 8, 1, 1, 1, 1, 0], [0, 1, 1, 8, 8, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [3, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 1, 1, 1, 1, 1, 1, 0], [0, 8, 8, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 6, 6, 0], [0, 1, 1, 1, 1, 1, 1, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [0, 6]]}]}"
3Xb82BM78nxtCUz9xE5ZfD,2025-07-21T15:52:23.142719,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 1, 1, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 1, 1, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 8, 8, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 8, 8, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [8, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 2, 2, 9, 8, 8, 9, 0], [0, 9, 9, 2, 2, 9, 8, 8, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 6, 6, 9, 9, 0], [0, 9, 9, 9, 9, 6, 6, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 8], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 9, 0, 0], [0, 9, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 5, 5, 9, 9, 9, 8, 8, 9, 0, 0], [0, 9, 9, 9, 9, 5, 5, 9, 9, 9, 8, 8, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 6], [5, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 7, 7, 9, 9, 9, 9, 9, 4, 4, 0], [0, 9, 7, 7, 9, 9, 9, 9, 9, 4, 4, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [7, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 3, 3, 0, 0, 0], [0, 0, 0, 9, 9, 5, 5, 9, 9, 3, 3, 0, 0, 0], [0, 0, 0, 9, 9, 5, 5, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 4, 4, 9, 9, 2, 2, 0, 0, 0], [0, 0, 0, 9, 9, 4, 4, 9, 9, 2, 2, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 3], [4, 2]]}]}"
6tU7U5SNXbSibMKexUekKj,2025-07-21T15:52:23.145507,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 3, 3, 9, 9, 3, 3, 3, 2, 2, 0, 0], [0, 3, 3, 9, 9, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 2], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 5, 5, 3, 3, 3, 3, 4, 4, 3, 0], [0, 5, 5, 3, 3, 3, 3, 4, 4, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 2, 2, 3, 3, 3, 3, 3, 3, 0], [0, 3, 2, 2, 3, 3, 9, 9, 3, 3, 0], [0, 3, 3, 3, 3, 3, 9, 9, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 4], [2, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 4, 4, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [0, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 8, 8, 3, 0], [0, 3, 3, 9, 9, 3, 8, 8, 3, 0], [0, 3, 3, 9, 9, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 5, 5, 3, 0], [0, 3, 3, 3, 3, 3, 5, 5, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [0, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 4, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 4, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 6, 6, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 7], [6, 4]]}]}"
8VXAojZQMmyXQeH79yrDPc,2025-07-21T15:52:23.148725,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 2, 2, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 2, 2, 9, 9, 9, 9, 9, 3, 3, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 3], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0], [0, 9, 9, 9, 9, 9, 9, 6, 6, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 1, 1, 9, 9, 4, 4, 9, 9, 0, 0], [0, 1, 1, 9, 9, 4, 4, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [1, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 1, 1, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 1, 1, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 6, 6, 9, 9, 8, 8, 9, 9, 0, 0], [0, 0, 9, 6, 6, 9, 9, 8, 8, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [6, 8]]}]}"
BcoihqgE8maykWKXkXkRSC,2025-07-21T15:52:23.151677,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 7, 7, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 7, 7, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 6, 6, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 6, 6, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 3, 3, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 3, 3, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [3, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 7, 7, 2, 2, 2, 2, 6, 6, 2, 0, 0], [0, 2, 7, 7, 2, 2, 2, 2, 6, 6, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 5, 5, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 6], [5, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 8, 8, 2, 2, 6, 6, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 6], [5, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 2, 0], [0, 9, 9, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [9, 0]]}]}"
HfWxU66SJ8jXZMVDZc3b4A,2025-07-21T15:52:23.154842,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 6, 6, 4, 4, 4, 4, 0, 0], [0, 4, 4, 6, 6, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0], [0, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 8, 8, 4, 4, 4, 4, 4, 0, 0], [0, 4, 8, 8, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0], [0, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 2], [8, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 2, 2, 4, 4, 3, 3, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 2, 2, 4, 4, 3, 3, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 1], [2, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 3, 3, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 3, 3, 4, 4, 4, 1, 1, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 1, 1, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 8, 8, 4, 4, 4, 4, 5, 5, 0, 0, 0, 0], [0, 0, 0, 8, 8, 4, 4, 4, 4, 5, 5, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 1], [8, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0], [0, 4, 2, 2, 4, 4, 4, 4, 1, 1, 4, 4, 0, 0], [0, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 3, 3, 4, 4, 6, 6, 4, 4, 4, 0, 0], [0, 4, 4, 3, 3, 4, 4, 6, 6, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 1], [3, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 7, 7, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 7, 7, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0, 0], [0, 0, 8, 8, 4, 4, 4, 4, 4, 7, 7, 4, 4, 0, 0, 0], [0, 0, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 6, 6, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 7], [6, 9]]}]}"
224prBsQWHubKR2ssBcGWf,2025-07-21T15:52:23.157740,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 0, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [3, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 6, 6, 2, 2, 2, 2, 8, 8, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 9], [6, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 3, 3, 2, 2, 0], [0, 2, 2, 2, 2, 3, 3, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 8, 8, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 8, 8, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 3, 3, 2, 2, 2, 2, 4, 4, 2, 2, 0], [0, 3, 3, 2, 2, 2, 2, 4, 4, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [3, 4]]}]}"
UvubSKSnjVDSrggo2RsEK4,2025-07-21T15:52:23.160710,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 6], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 4, 4, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 4, 4, 0, 0, 0, 0], [0, 0, 0, 7, 7, 8, 8, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 8, 8, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [8, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 2, 2, 7, 7, 0, 0], [0, 7, 7, 7, 7, 2, 2, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 2, 2, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 2, 2, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 5, 5, 7, 7, 7, 7, 6, 6, 7, 7, 0, 0], [0, 5, 5, 7, 7, 7, 7, 6, 6, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 4, 4, 7, 7, 7, 1, 1, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 1, 1, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 6], [4, 1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 3, 3, 7, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 3, 3, 7, 9, 9, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 9, 9, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [3, 9]]}]}"
7L3XS47Y3VE9UeMUqbS4Ae,2025-07-21T15:52:23.163917,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color maroon."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 9
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 7, 7, 9, 9, 9, 2, 2, 9, 0, 0], [0, 9, 9, 7, 7, 9, 9, 9, 2, 2, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 3, 3, 9, 4, 4, 9, 9, 0, 0], [0, 9, 9, 9, 3, 3, 9, 4, 4, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 2], [3, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 3, 3, 9, 9, 9, 9, 9, 9, 0], [0, 9, 3, 3, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 8, 8, 9, 9, 9, 9, 9, 0], [0, 9, 9, 8, 8, 9, 2, 2, 9, 9, 0], [0, 9, 9, 9, 9, 9, 2, 2, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [8, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 2, 2, 9, 0, 0], [0, 9, 9, 9, 9, 9, 2, 2, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0], [0, 6, 6, 9, 9, 9, 9, 9, 9, 0, 0], [0, 6, 6, 9, 9, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [6, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 4, 4, 9, 9, 9, 9, 9, 9, 0], [0, 4, 4, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 0]]}]}"
7MRfpEkbRRkcL5oUAevjxg,2025-07-21T15:52:23.166931,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 4, 4, 1, 1, 1, 1, 1, 0], [0, 1, 4, 4, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 0], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 3, 3, 1, 1, 4, 4, 1, 1, 0, 0, 0], [0, 0, 3, 3, 1, 1, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 7, 7, 1, 0, 0, 0], [0, 0, 1, 6, 6, 1, 1, 7, 7, 1, 0, 0, 0], [0, 0, 1, 6, 6, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 4], [6, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 8, 8, 1, 1, 0], [0, 1, 1, 1, 1, 8, 8, 1, 1, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 0], [0, 1, 9, 9, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 2, 2, 0], [0, 1, 1, 1, 1, 1, 1, 2, 2, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [0, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 1, 4, 4, 1, 1, 1, 1, 7, 7, 0, 0, 0], [0, 0, 1, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 9, 9, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 9, 9, 1, 1, 1, 1, 6, 6, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 6, 6, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 7], [9, 6]]}]}"
PFECgambPKUNnG4hNHY4pz,2025-07-21T15:52:23.169732,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color red."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 2
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 0, 0], [0, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [6, 3]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 6, 6, 2, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 2, 2, 2, 7, 7, 2, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 2, 2, 2, 7, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 3], [1, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [3, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 2, 4, 4, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 1, 1, 2, 2, 0, 0], [0, 7, 7, 2, 2, 1, 1, 2, 2, 0, 0], [0, 7, 7, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 8, 8, 2, 0, 0], [0, 2, 2, 2, 2, 2, 8, 8, 2, 0, 0], [0, 2, 2, 5, 5, 2, 2, 2, 2, 0, 0], [0, 2, 2, 5, 5, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 1], [5, 8]]}]}"
3FsGY23DyZfeDSmYNJnwx7,2025-07-21T15:52:23.172722,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 1, 1, 8, 0, 0], [0, 8, 8, 8, 8, 8, 1, 1, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 6, 6, 8, 0, 0], [0, 8, 8, 8, 8, 8, 6, 6, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 1], [0, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 2, 2, 8, 5, 5, 8, 8, 8, 0], [0, 8, 2, 2, 8, 5, 5, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 1, 1, 8, 8, 7, 7, 8, 8, 8, 0], [0, 1, 1, 8, 8, 7, 7, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 5], [1, 7]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0, 0, 0], [0, 0, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 7, 7, 8, 8, 0, 0], [0, 2, 2, 8, 8, 8, 7, 7, 8, 8, 0, 0], [0, 2, 2, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 9, 9, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 9, 9, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 7], [1, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 0], [0, 2]]}]}"
oRAj9KuhUkw3KAyn7NaSTb,2025-07-21T15:52:23.175341,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 8, 8, 8, 8, 4, 4, 8, 0, 0, 0], [0, 0, 0, 7, 7, 8, 8, 8, 8, 4, 4, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 5, 5, 8, 0, 0, 0], [0, 0, 0, 8, 8, 1, 1, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 1, 1, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 4], [1, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 3, 3, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 3, 3, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 9, 9, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 9, 9, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 3, 3, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 3, 3, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 3, 3, 8, 8, 8, 8, 0], [0, 8, 8, 3, 3, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [0, 0]]}]}"
dXarq82YXv6Ait8J8zjVgp,2025-07-21T15:52:23.178975,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 3, 3, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 6, 6, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 6, 6, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [1, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 7, 7, 5, 0], [0, 5, 5, 5, 5, 5, 7, 7, 5, 0], [0, 5, 5, 9, 9, 5, 5, 5, 5, 0], [0, 5, 5, 9, 9, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 3, 3, 5, 0], [0, 5, 5, 5, 5, 5, 3, 3, 5, 0], [0, 1, 1, 5, 5, 5, 5, 5, 5, 0], [0, 1, 1, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [1, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 5, 5, 0, 0], [0, 5, 5, 2, 2, 5, 5, 5, 5, 7, 7, 5, 5, 0, 0], [0, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [2, 7]]}]}"
G4avPEE7u4AgMtn4tSrqfu,2025-07-21T15:52:23.181878,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 9, 9, 7, 7, 7, 7, 5, 5, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 5], [8, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 0], [0, 7, 4, 4, 7, 7, 7, 7, 7, 7, 8, 8, 7, 0], [0, 7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 2, 2, 7, 7, 1, 1, 7, 7, 7, 0], [0, 7, 7, 7, 2, 2, 7, 7, 1, 1, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 8], [2, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 3, 3, 7, 7, 7, 2, 2, 0], [0, 7, 7, 3, 3, 7, 7, 7, 2, 2, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 2], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 6, 6, 7, 7, 7, 7, 7, 0], [0, 7, 6, 6, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [6, 0]]}]}"
YXmXrMEQmw83RBtYZ2zB3y,2025-07-21T15:52:23.184731,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color cyan."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 8
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 9, 9, 8, 8, 7, 7, 8, 0, 0, 0], [0, 0, 0, 8, 9, 9, 8, 8, 7, 7, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 6, 6, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 6, 6, 0, 0, 0], [0, 0, 0, 8, 8, 5, 5, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 5, 5, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 7], [5, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 0], [0, 8, 8, 8, 3, 3, 8, 2, 2, 8, 8, 8, 0], [0, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 2], [6, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 3, 3, 0], [0, 8, 8, 7, 7, 8, 8, 3, 3, 0], [0, 8, 8, 7, 7, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 6, 6, 8, 8, 8, 1, 1, 8, 0], [0, 6, 6, 8, 8, 8, 1, 1, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 3], [6, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 9, 9, 8, 0, 0], [0, 8, 8, 8, 8, 8, 9, 9, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 7, 7, 0], [0, 8, 8, 1, 1, 8, 8, 7, 7, 0], [0, 8, 8, 1, 1, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [1, 7]]}]}"
LPrigWgaZM9Juyn4yA4KmR,2025-07-21T15:52:23.187334,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 9, 9, 1, 1, 1, 3, 3, 0, 0, 0], [0, 0, 1, 1, 9, 9, 1, 1, 1, 3, 3, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 6, 6, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 6, 6, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 3], [2, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 7, 7, 1, 1, 1, 2, 2, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 2, 2, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 9, 9, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 9, 9, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 2], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 6], [0, 9]]}]}"
PJzk7r99DgsUUmjXMzUsSY,2025-07-21T15:52:23.190158,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 4, 4, 7, 6, 6, 7, 7, 0, 0], [0, 0, 7, 7, 7, 4, 4, 7, 6, 6, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 8, 8, 7, 7, 7, 9, 9, 0, 0], [0, 0, 7, 7, 7, 8, 8, 7, 7, 7, 9, 9, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[4, 6], [8, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 3, 3, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 3, 3, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 5, 5, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 3], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 2, 2, 7, 7, 5, 5, 7, 7, 0], [0, 7, 2, 2, 7, 7, 5, 5, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 9, 9, 7, 7, 7, 7, 7, 0], [0, 7, 7, 9, 9, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 5], [9, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 5, 5, 7, 0], [0, 7, 7, 7, 7, 7, 5, 5, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 4, 4, 7, 7, 0], [0, 7, 7, 7, 7, 7, 4, 4, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 5, 5, 0], [0, 7, 7, 7, 7, 7, 7, 7, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 5]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 3, 3, 7, 7, 7, 9, 9, 7, 7, 7, 0, 0], [0, 0, 3, 3, 7, 7, 7, 9, 9, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 1], [3, 9]]}]}"
5dmD67znmLs3jYW6DnZ7MJ,2025-07-21T15:52:23.193222,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 6, 6, 5, 5, 5, 0, 0, 0], [0, 0, 0, 3, 3, 5, 5, 6, 6, 5, 5, 5, 0, 0, 0], [0, 0, 0, 3, 3, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 9, 9, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [2, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 3, 3, 5, 5, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 3, 3, 5, 5, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 4, 4, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 4, 4, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 9], [0, 4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 6, 6, 5, 0], [0, 5, 5, 5, 5, 5, 6, 6, 5, 0], [0, 9, 9, 5, 5, 5, 5, 5, 5, 0], [0, 9, 9, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 4, 4, 5, 5, 5, 5, 0], [0, 5, 5, 4, 4, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 6], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0], [0, 5, 5, 1, 1, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 3, 3, 5, 5, 7, 7, 0, 0], [0, 5, 5, 3, 3, 5, 5, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [3, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 1, 1, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 1, 1, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 0], [0, 0]]}]}"
RaUdnZSFXRxSezHYFLrusx,2025-07-21T15:52:23.199504,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color blue."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 1
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 0, 0], [0, 1, 1, 2, 2, 1, 1, 1, 1, 5, 5, 1, 1, 0, 0], [0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 5], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 0], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 8, 8, 1, 1, 4, 4, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 4], [3, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 5, 5, 1, 1, 1, 1, 2, 2, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 6], [5, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 5, 5, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[5, 0], [0, 0]]}]}"
F2g9zNwiVPzapgctKvffBn,2025-07-21T15:52:23.203270,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color green."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 3
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 0, 3, 3, 3, 1, 1, 3, 3, 3, 4, 4, 0, 0, 0], [0, 0, 0, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 4], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 3, 4, 4, 3, 3, 3, 3, 3, 0, 0], [0, 3, 4, 4, 3, 3, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [4, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 6, 6, 3, 3, 3, 3, 3, 3, 3, 0], [0, 6, 6, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 0], [0, 0]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 2, 2, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 2, 2, 3, 3, 3, 9, 9, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 9, 9, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 4, 4, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2, 9], [0, 4]]}]}"
bgQCNbjomGtq4MY2LAhsR6,2025-07-21T15:52:23.206033,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color orange."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 7
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 4, 4, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 4, 4, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 4], [0, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 8, 8, 7, 7, 7, 7, 7, 0, 0], [0, 7, 8, 8, 7, 7, 7, 9, 9, 0, 0], [0, 7, 7, 7, 7, 7, 7, 9, 9, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 3, 3, 7, 7, 7, 7, 7, 7, 0, 0], [0, 3, 3, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0], [0, 7, 7, 7, 7, 7, 6, 6, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 9], [3, 6]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 9, 9, 7, 0], [0, 7, 7, 7, 7, 7, 9, 9, 7, 0], [0, 7, 7, 1, 1, 7, 7, 7, 7, 0], [0, 7, 7, 1, 1, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 7, 7, 3, 3, 0], [0, 7, 7, 7, 7, 7, 7, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 9], [1, 3]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 8, 8, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 8, 8, 7, 7, 7, 0, 0], [0, 1, 1, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 1, 1, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 9, 9, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 9, 9, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[1, 8], [9, 0]]}]}"
Xjdv2L4VmMqZJ6V9nDRQbJ,2025-07-21T15:52:23.208681,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color pink."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 6
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 5, 5, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 8], [5, 2]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 3, 3, 6, 6, 0], [0, 6, 6, 6, 6, 3, 3, 6, 6, 0], [0, 7, 7, 6, 6, 6, 6, 6, 6, 0], [0, 7, 7, 6, 6, 6, 6, 6, 6, 0], [0, 6, 6, 6, 6, 9, 9, 6, 6, 0], [0, 6, 6, 6, 6, 9, 9, 6, 6, 0], [0, 2, 2, 6, 6, 6, 6, 6, 6, 0], [0, 2, 2, 6, 6, 6, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 3], [2, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0], [0, 6, 6, 6, 6, 2, 2, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0], [0, 6, 6, 6, 6, 6, 6, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 2], [0, 9]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 0], [5, 0]]}]}"
MmekqWE92NGpamTGXmAuZG,2025-07-21T15:52:23.211920,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color grey."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 5
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 7, 7, 5, 0], [0, 5, 8, 8, 5, 5, 7, 7, 5, 0], [0, 5, 8, 8, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 2, 2, 5, 5, 9, 9, 5, 5, 0], [0, 2, 2, 5, 5, 9, 9, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[8, 7], [2, 9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 4, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 6, 6, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 6, 6, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 5, 5, 1, 1, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 5, 5, 1, 1, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[6, 4], [3, 1]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 9, 9, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 9, 9, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 7, 7, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 7, 7, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9, 0], [7, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 2, 2, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [2, 0]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 3, 3, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3, 1], [6, 8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 8, 8, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 8]]}]}"
DbDRoWFqRuwVGpTMVvuRR8,2025-07-21T15:52:23.214904,task19bb5feb,"[""Input grids are of different sizes."", ""Each input grid contains a single rectangular or square region filled with a background color yellow."", ""Within that region you will find between 1 and 4 non-overlapping, well-spaced 2\u00d72 sub-blocks, each in a unique color.""]","[""The output grid is of size 2x2."", ""Imagine dividing the input grid colored region into four quadrants."", ""For each quadrant, if it contains one of the 2\u00d72 sub-blocks, paint the corresponding cell in the output grid with that sub-block color."", ""If a quadrant has no sub-block, leave its output cell empty (0).""]","{""bg_color"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 2x2 output based on quadrant contents.""""""
    bg_color = 4
    
    # Find the colored region (background colored area)
    bg_mask = grid == bg_color
    if not np.any(bg_mask):
        return np.zeros((2, 2), dtype=int)
    
    # Get bounding box of colored region
    rows, cols = np.where(bg_mask)
    min_row, max_row = rows.min(), rows.max()
    min_col, max_col = cols.min(), cols.max()
    
    # Calculate quadrant boundaries
    region_height = max_row - min_row + 1
    region_width = max_col - min_col + 1
    mid_row = min_row + region_height // 2
    mid_col = min_col + region_width // 2
    
    quadrants = [
        (min_row, mid_row, min_col, mid_col),                    # Top-left -> output[0,0]
        (min_row, mid_row, mid_col, max_col + 1),               # Top-right -> output[0,1]
        (mid_row, max_row + 1, min_col, mid_col),               # Bottom-left -> output[1,0]
        (mid_row, max_row + 1, mid_col, max_col + 1)            # Bottom-right -> output[1,1]
    ]
    
    output = np.zeros((2, 2), dtype=int)
    
    # Check each quadrant for 2x2 blocks
    for quad_idx, (r1, r2, c1, c2) in enumerate(quadrants):
        # Scan this quadrant for 2x2 blocks
        for r in range(r1, r2 - 1):
            for c in range(c1, c2 - 1):
                if r + 2 <= r2 and c + 2 <= c2:
                    block_region = grid[r:r+2, c:c+2]
                    unique_colors = np.unique(block_region)
                    
                    # Check if this is a 2x2 block of the same non-background color
                    if len(unique_colors) == 1 and unique_colors[0] != bg_color and unique_colors[0] != 0:
                        output_row = quad_idx // 2
                        output_col = quad_idx % 2
                        output[output_row, output_col] = unique_colors[0]
                        break
            else:
                continue
            break
    
    return output","{""train"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 8], [0, 5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 8, 8, 4, 4, 0], [0, 4, 4, 4, 4, 8, 8, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [0, 8]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 5, 5, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 2, 2, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[0, 0], [5, 2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 7, 7, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 7, 7, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 9, 9, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 9, 9, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[7, 9], [0, 0]]}]}"
6yjCpBDtsc2NuJAet2STEt,2025-07-21T15:52:23.219204,task1a2e2828,"[""Input grids are of size 13 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 3, 3, 3], [2, 2, 2, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[4]]}, {""input"": [[9, 9, 9, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 8, 8, 1], [9, 9, 9, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 8, 8, 1], [9, 9, 9, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 8, 8, 1], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 6, 6, 6, 6, 4, 4, 4, 6, 6, 6, 8, 8, 6], [9, 9, 9, 6, 6, 6, 6, 4, 4, 4, 6, 6, 6, 8, 8, 6], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 8, 8, 0], [9, 9, 9, 5, 5, 5, 5, 4, 4, 4, 5, 5, 5, 8, 8, 5]], ""output"": [[8]]}, {""input"": [[0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [7, 7, 7, 4, 4, 4, 7, 7, 2, 7, 7, 7, 6, 6, 7, 7], [7, 7, 7, 4, 4, 4, 7, 7, 2, 7, 7, 7, 6, 6, 7, 7], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 2, 0, 0, 0, 6, 6, 0, 0], [1, 1, 1, 4, 4, 4, 1, 1, 2, 1, 1, 1, 6, 6, 1, 1], [1, 1, 1, 4, 4, 4, 1, 1, 2, 1, 1, 1, 6, 6, 1, 1], [1, 1, 1, 4, 4, 4, 1, 1, 2, 1, 1, 1, 6, 6, 1, 1]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 9, 9, 1, 1], [1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 9, 9, 1, 1], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 9, 9, 8, 8]], ""output"": [[3]]}]}"
6mskGvXs6CwZdin6EPkpE8,2025-07-21T15:52:23.222084,task1a2e2828,"[""Input grids are of size 17 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5, 5, 7, 7, 7, 5, 5], [4, 4, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5, 5, 7, 7, 7, 5, 5], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [4, 4, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6], [4, 4, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6]], ""output"": [[8]]}, {""input"": [[0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [9, 9, 9, 8, 8, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 2, 2, 2], [9, 9, 9, 8, 8, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [3, 3, 3, 8, 8, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [7, 7, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 7, 7], [7, 7, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 7, 7], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9], [9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9], [9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0]], ""output"": [[1]]}, {""input"": [[0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5], [4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}], ""test"": [{""input"": [[1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 4], [1, 1, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4], [1, 1, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]], ""output"": [[1]]}]}"
hvDDNeRGs4r5Bk2cqBpqRC,2025-07-21T15:52:23.225182,task1a2e2828,"[""Input grids are of size 12 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9], [1, 1, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [1, 1, 5, 5, 5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5]], ""output"": [[1]]}, {""input"": [[1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 8, 8, 8, 4, 8, 8, 8, 8, 8, 9, 9, 8, 8], [1, 1, 8, 8, 8, 4, 8, 8, 8, 8, 8, 9, 9, 8, 8], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 7, 7, 7, 4, 7, 7, 7, 7, 7, 9, 9, 7, 7], [1, 1, 7, 7, 7, 4, 7, 7, 7, 7, 7, 9, 9, 7, 7], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0], [1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1], [1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 6, 6], [6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 6, 6]], ""output"": [[9]]}, {""input"": [[5, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 8, 8], [5, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 8, 8], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7], [5, 5, 5, 7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [5, 5, 5, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2], [8, 8, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]], ""output"": [[1]]}]}"
erwbZRQvRfFJtt3LLZcDFi,2025-07-21T15:52:23.230949,task1a2e2828,"[""Input grids are of size 17 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 6, 6, 8, 8, 8], [9, 9, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 6, 6, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 6, 6, 1, 1, 1], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 6, 6, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 6, 4, 4, 6, 6, 3, 3, 3], [6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 6, 4, 4, 6, 6, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 4, 4, 8, 8, 3, 3, 3], [8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 4, 4, 8, 8, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 4, 4, 1, 1, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 3]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [3, 3, 3, 3, 7, 7, 3, 3, 3, 4, 4, 3, 3, 3, 3, 5, 5, 5], [3, 3, 3, 3, 7, 7, 3, 3, 3, 4, 4, 3, 3, 3, 3, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [1, 1, 1, 1, 7, 7, 1, 1, 1, 4, 4, 1, 1, 1, 1, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5], [6, 6, 6, 6, 7, 7, 6, 6, 6, 4, 4, 6, 6, 6, 6, 5, 5, 5], [6, 6, 6, 6, 7, 7, 6, 6, 6, 4, 4, 6, 6, 6, 6, 5, 5, 5], [0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 5, 5, 5]], ""output"": [[4]]}, {""input"": [[4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 7, 7, 7, 9, 9, 9], [4, 4, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 7, 7, 7, 9, 9, 9], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 6, 6, 1, 1, 6, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6, 6], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9], [2, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9], [2, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5]], ""output"": [[8]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 9, 9, 8], [9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 9, 9, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8], [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 8], [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 8], [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 8], [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 8]], ""output"": [[8]]}]}"
PaSz2dYAc7QCFT6Dec7Z5q,2025-07-21T15:52:23.234779,task1a2e2828,"[""Input grids are of size 17 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [3, 1, 1, 3, 3, 3, 6, 6, 3, 3, 3, 4, 4, 3, 3], [3, 1, 1, 3, 3, 3, 6, 6, 3, 3, 3, 4, 4, 3, 3], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [5, 1, 1, 5, 5, 5, 6, 6, 5, 5, 5, 4, 4, 5, 5], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 6, 6, 0, 0, 0, 4, 4, 0, 0]], ""output"": [[1]]}, {""input"": [[5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 6, 6], [5, 5, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 6, 6], [5, 5, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 6, 6], [5, 5, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[5]]}, {""input"": [[5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8], [5, 5, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7], [5, 5, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7], [5, 5, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0]], ""output"": [[5]]}, {""input"": [[7, 7, 7, 7, 6, 6, 7, 7, 9, 9, 9, 7, 2, 2, 2], [7, 7, 7, 7, 6, 6, 7, 7, 9, 9, 9, 7, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [5, 5, 5, 5, 6, 6, 5, 5, 9, 9, 9, 5, 2, 2, 2], [5, 5, 5, 5, 6, 6, 5, 5, 9, 9, 9, 5, 2, 2, 2], [5, 5, 5, 5, 6, 6, 5, 5, 9, 9, 9, 5, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2], [3, 3, 3, 3, 6, 6, 3, 3, 9, 9, 9, 3, 2, 2, 2], [0, 0, 0, 0, 6, 6, 0, 0, 9, 9, 9, 0, 2, 2, 2]], ""output"": [[6]]}], ""test"": [{""input"": [[4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 3, 3, 3], [4, 4, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3], [4, 4, 9, 9, 9, 7, 7, 9, 9, 9, 9, 9, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[4]]}]}"
dmedz6VWGzHeDPbBVkvL4P,2025-07-21T15:52:23.238174,task1a2e2828,"[""Input grids are of size 14 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 2, 2, 5, 5, 2, 2, 2, 2, 2, 7, 7], [1, 1, 1, 2, 2, 5, 5, 2, 2, 2, 2, 2, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 4, 4, 5, 5, 4, 4, 4, 4, 4, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7], [1, 1, 1, 0, 0, 5, 5, 0, 0, 0, 0, 0, 7, 7]], ""output"": [[5]]}, {""input"": [[4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 5, 5, 5, 5, 6, 6, 6, 5, 5, 9, 9, 5, 5], [4, 5, 5, 5, 5, 6, 6, 6, 5, 5, 9, 9, 5, 5], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 1, 1, 1, 1, 6, 6, 6, 1, 1, 9, 9, 1, 1], [4, 1, 1, 1, 1, 6, 6, 6, 1, 1, 9, 9, 1, 1], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0], [4, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 0, 0]], ""output"": [[4]]}, {""input"": [[1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 6, 6], [1, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 6, 6], [1, 1, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 6, 6], [1, 1, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 6, 6], [1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [7, 7, 7, 7, 7, 8, 8, 8, 7, 7, 7, 7, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6], [9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 6, 6], [9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 6, 6], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 6, 6]], ""output"": [[6]]}, {""input"": [[0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [3, 3, 4, 3, 3, 3, 1, 1, 3, 3, 3, 3, 2, 2], [3, 3, 4, 3, 3, 3, 1, 1, 3, 3, 3, 3, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [5, 5, 4, 5, 5, 5, 1, 1, 5, 5, 5, 5, 2, 2], [5, 5, 4, 5, 5, 5, 1, 1, 5, 5, 5, 5, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2]], ""output"": [[4]]}], ""test"": [{""input"": [[3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1], [3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1], [3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1], [3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]], ""output"": [[1]]}]}"
bpBsTTj78FB2ushZumo5DL,2025-07-21T15:52:23.241523,task1a2e2828,"[""Input grids are of size 13 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9, 9], [4, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9, 9], [4, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9, 9], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5], [4, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [8, 8, 8, 6, 6, 8, 8, 8, 8, 5, 5, 5], [8, 8, 8, 6, 6, 8, 8, 8, 8, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [1, 1, 1, 6, 6, 1, 1, 1, 1, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 0, 5, 5, 5], [4, 4, 4, 6, 6, 4, 4, 4, 4, 5, 5, 5], [4, 4, 4, 6, 6, 4, 4, 4, 4, 5, 5, 5]], ""output"": [[6]]}, {""input"": [[1, 1, 9, 9, 9, 1, 1, 1, 3, 3, 1, 1], [1, 1, 9, 9, 9, 1, 1, 1, 3, 3, 1, 1], [1, 1, 9, 9, 9, 1, 1, 1, 3, 3, 1, 1], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [5, 5, 9, 9, 9, 5, 5, 5, 3, 3, 5, 5], [5, 5, 9, 9, 9, 5, 5, 5, 3, 3, 5, 5], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [0, 0, 9, 9, 9, 0, 0, 0, 3, 3, 0, 0], [4, 4, 9, 9, 9, 4, 4, 4, 3, 3, 4, 4]], ""output"": [[3]]}, {""input"": [[5, 5, 1, 1, 1, 5, 5, 5, 5, 4, 4, 5], [5, 5, 1, 1, 1, 5, 5, 5, 5, 4, 4, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [3, 3, 1, 1, 1, 3, 3, 3, 3, 4, 4, 3], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 4, 4, 0], [8, 8, 1, 1, 1, 8, 8, 8, 8, 4, 4, 8], [8, 8, 1, 1, 1, 8, 8, 8, 8, 4, 4, 8]], ""output"": [[4]]}], ""test"": [{""input"": [[8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 4], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6, 4], [6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6, 4], [6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4]], ""output"": [[4]]}]}"
HGZ7LNxttKXuWR2ow2vrhX,2025-07-21T15:52:23.245369,task1a2e2828,"[""Input grids are of size 11 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1], [8, 2, 2, 8, 8, 8, 8, 8, 8, 8, 1, 1], [8, 2, 2, 8, 8, 8, 8, 8, 8, 8, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1], [4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1], [4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1], [4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1]], ""output"": [[1]]}, {""input"": [[9, 9, 9, 8, 8, 8, 2, 2, 8, 8, 1, 1], [9, 9, 9, 8, 8, 8, 2, 2, 8, 8, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 5, 5, 5, 2, 2, 5, 5, 1, 1], [9, 9, 9, 5, 5, 5, 2, 2, 5, 5, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 0, 0, 0, 2, 2, 0, 0, 1, 1], [9, 9, 9, 4, 4, 4, 2, 2, 4, 4, 1, 1]], ""output"": [[1]]}, {""input"": [[1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 4, 4, 2, 2, 4, 4, 4, 9, 9, 9], [1, 1, 4, 4, 2, 2, 4, 4, 4, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 6, 6, 2, 2, 6, 6, 6, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9]], ""output"": [[1]]}, {""input"": [[0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0], [3, 4, 4, 3, 3, 5, 5, 3, 3, 3, 8, 3], [3, 4, 4, 3, 3, 5, 5, 3, 3, 3, 8, 3], [3, 4, 4, 3, 3, 5, 5, 3, 3, 3, 8, 3], [0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0], [0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0], [0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0], [0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0], [1, 4, 4, 1, 1, 5, 5, 1, 1, 1, 8, 1], [1, 4, 4, 1, 1, 5, 5, 1, 1, 1, 8, 1], [0, 4, 4, 0, 0, 5, 5, 0, 0, 0, 8, 0]], ""output"": [[8]]}, {""input"": [[2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 8, 8, 4, 4, 4, 8, 8, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 0, 0, 4, 4, 4, 0, 0, 3, 3], [2, 2, 2, 5, 5, 4, 4, 4, 5, 5, 3, 3], [2, 2, 2, 5, 5, 4, 4, 4, 5, 5, 3, 3]], ""output"": [[3]]}], ""test"": [{""input"": [[9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 3, 3, 3, 7, 7, 3, 3, 3, 3], [9, 9, 9, 3, 3, 3, 7, 7, 3, 3, 3, 3], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 2, 2, 2, 7, 7, 2, 2, 2, 2], [9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0]], ""output"": [[7]]}]}"
QfpvVMGEykcFgLznaitmh4,2025-07-21T15:52:23.250982,task1a2e2828,"[""Input grids are of size 17 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [1, 1, 1, 2, 2, 1, 1, 1, 6, 6], [1, 1, 1, 2, 2, 1, 1, 1, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [8, 8, 8, 2, 2, 8, 8, 8, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6], [0, 0, 0, 2, 2, 0, 0, 0, 6, 6]], ""output"": [[2]]}, {""input"": [[0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [7, 7, 1, 1, 1, 7, 7, 7, 9, 9], [7, 7, 1, 1, 1, 7, 7, 7, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [6, 6, 1, 1, 1, 6, 6, 6, 9, 9], [6, 6, 1, 1, 1, 6, 6, 6, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9], [0, 0, 1, 1, 1, 0, 0, 0, 9, 9]], ""output"": [[9]]}, {""input"": [[4, 4, 3, 3, 1, 1, 3, 3, 9, 3], [4, 4, 3, 3, 1, 1, 3, 3, 9, 3], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 8, 8, 1, 1, 8, 8, 9, 8], [4, 4, 8, 8, 1, 1, 8, 8, 9, 8], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0], [4, 4, 0, 0, 1, 1, 0, 0, 9, 0]], ""output"": [[9]]}, {""input"": [[9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 8, 7, 7, 8, 8, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 5, 7, 7, 5, 5, 4, 4], [9, 9, 9, 5, 7, 7, 5, 5, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 0, 7, 7, 0, 0, 4, 4], [9, 9, 9, 6, 7, 7, 6, 6, 4, 4], [9, 9, 9, 6, 7, 7, 6, 6, 4, 4]], ""output"": [[4]]}, {""input"": [[3, 3, 3, 1, 1, 1, 8, 8, 1, 1], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 5, 5, 5, 8, 8, 5, 5], [3, 3, 3, 5, 5, 5, 8, 8, 5, 5], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [3, 3, 3, 4, 4, 4, 8, 8, 4, 4], [3, 3, 3, 4, 4, 4, 8, 8, 4, 4], [3, 3, 3, 4, 4, 4, 8, 8, 4, 4]], ""output"": [[8]]}], ""test"": [{""input"": [[0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [2, 9, 2, 2, 2, 2, 4, 4, 2, 2], [2, 9, 2, 2, 2, 2, 4, 4, 2, 2], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [1, 9, 1, 1, 1, 1, 4, 4, 1, 1], [1, 9, 1, 1, 1, 1, 4, 4, 1, 1], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0], [0, 9, 0, 0, 0, 0, 4, 4, 0, 0]], ""output"": [[9]]}]}"
dYEv8N73ZRoXrZEbsVBkr5,2025-07-21T15:52:23.255433,task1a2e2828,"[""Input grids are of size 15 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 1, 1, 5, 5, 1, 1, 1, 1], [7, 7, 7, 1, 1, 5, 5, 1, 1, 1, 1], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 6, 6, 5, 5, 6, 6, 6, 6], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 7, 0, 0, 5, 5, 0, 0, 0, 0]], ""output"": [[5]]}, {""input"": [[0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [6, 1, 1, 6, 6, 4, 4, 6, 3, 3, 6], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0], [8, 1, 1, 8, 8, 4, 4, 8, 3, 3, 8], [8, 1, 1, 8, 8, 4, 4, 8, 3, 3, 8], [0, 1, 1, 0, 0, 4, 4, 0, 3, 3, 0]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [6, 6, 6, 2, 2, 6, 6, 6, 6, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [3, 3, 3, 2, 2, 3, 3, 3, 3, 9, 9], [3, 3, 3, 2, 2, 3, 3, 3, 3, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9], [5, 5, 5, 2, 2, 5, 5, 5, 5, 9, 9], [5, 5, 5, 2, 2, 5, 5, 5, 5, 9, 9], [5, 5, 5, 2, 2, 5, 5, 5, 5, 9, 9]], ""output"": [[2]]}, {""input"": [[1, 7, 7, 7, 1, 1, 1, 6, 6, 1, 1], [1, 7, 7, 7, 1, 1, 1, 6, 6, 1, 1], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [8, 7, 7, 7, 8, 8, 8, 6, 6, 8, 8], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [0, 7, 7, 7, 0, 0, 0, 6, 6, 0, 0], [3, 7, 7, 7, 3, 3, 3, 6, 6, 3, 3], [3, 7, 7, 7, 3, 3, 3, 6, 6, 3, 3]], ""output"": [[6]]}, {""input"": [[6, 6, 7, 7, 3, 7, 7, 7, 4, 4, 7], [6, 6, 7, 7, 3, 7, 7, 7, 4, 4, 7], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 2, 2, 3, 2, 2, 2, 4, 4, 2], [6, 6, 2, 2, 3, 2, 2, 2, 4, 4, 2], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 8, 8, 3, 8, 8, 8, 4, 4, 8], [6, 6, 8, 8, 3, 8, 8, 8, 4, 4, 8], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0], [6, 6, 0, 0, 3, 0, 0, 0, 4, 4, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[5, 2, 2, 5, 5, 5, 7, 7, 5, 5, 5], [5, 2, 2, 5, 5, 5, 7, 7, 5, 5, 5], [5, 2, 2, 5, 5, 5, 7, 7, 5, 5, 5], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [6, 2, 2, 6, 6, 6, 7, 7, 6, 6, 6], [6, 2, 2, 6, 6, 6, 7, 7, 6, 6, 6], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [0, 2, 2, 0, 0, 0, 7, 7, 0, 0, 0], [9, 2, 2, 9, 9, 9, 7, 7, 9, 9, 9]], ""output"": [[2]]}]}"
hm5xg6pix5rxWboECQVgYA,2025-07-21T15:52:23.258735,task1a2e2828,"[""Input grids are of size 11 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [3, 3, 3, 9, 9, 3, 3, 3, 3, 5, 5, 5], [3, 3, 3, 9, 9, 3, 3, 3, 3, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [7, 7, 7, 9, 9, 7, 7, 7, 7, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5]], ""output"": [[9]]}, {""input"": [[5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6], [8, 1, 1, 8, 8, 8, 8, 8, 8, 8, 6, 6], [8, 1, 1, 8, 8, 8, 8, 8, 8, 8, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6], [3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 6, 6], [3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[1]]}, {""input"": [[0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [9, 8, 8, 8, 9, 9, 9, 3, 3, 9, 2, 2], [9, 8, 8, 8, 9, 9, 9, 3, 3, 9, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [4, 8, 8, 8, 4, 4, 4, 3, 3, 4, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 3, 3, 0, 2, 2]], ""output"": [[2]]}, {""input"": [[4, 4, 4, 0, 0, 0, 0, 3, 3, 0, 0, 9], [4, 4, 4, 0, 0, 0, 0, 3, 3, 0, 0, 9], [4, 4, 4, 8, 8, 8, 8, 3, 3, 8, 8, 9], [4, 4, 4, 8, 8, 8, 8, 3, 3, 8, 8, 9], [4, 4, 4, 0, 0, 0, 0, 3, 3, 0, 0, 9], [4, 4, 4, 7, 7, 7, 7, 3, 3, 7, 7, 9], [4, 4, 4, 7, 7, 7, 7, 3, 3, 7, 7, 9], [4, 4, 4, 0, 0, 0, 0, 3, 3, 0, 0, 9], [4, 4, 4, 1, 1, 1, 1, 3, 3, 1, 1, 9], [4, 4, 4, 1, 1, 1, 1, 3, 3, 1, 1, 9], [4, 4, 4, 0, 0, 0, 0, 3, 3, 0, 0, 9]], ""output"": [[9]]}, {""input"": [[5, 5, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 6, 6, 6, 9, 9, 6, 6, 6, 6, 6], [5, 5, 6, 6, 6, 9, 9, 6, 6, 6, 6, 6], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8], [5, 5, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8]], ""output"": [[5]]}], ""test"": [{""input"": [[7, 5, 5, 7, 7, 7, 3, 3, 7, 7, 7, 8], [7, 5, 5, 7, 7, 7, 3, 3, 7, 7, 7, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 8], [6, 5, 5, 6, 6, 6, 3, 3, 6, 6, 6, 8], [6, 5, 5, 6, 6, 6, 3, 3, 6, 6, 6, 8], [6, 5, 5, 6, 6, 6, 3, 3, 6, 6, 6, 8]], ""output"": [[8]]}]}"
YNf2V58EhAe6YAFSjLmfXg,2025-07-21T15:52:23.261483,task1a2e2828,"[""Input grids are of size 14 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 5, 5], [6, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 5, 5], [6, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5]], ""output"": [[6]]}, {""input"": [[8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 7, 7, 8, 8], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 7, 7, 8, 8], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 7, 7, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 7, 7, 3, 3], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 7, 7, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0]], ""output"": [[2]]}, {""input"": [[9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 2, 2, 2, 6, 6, 6, 2, 2, 2, 2, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 7, 7], [9, 9, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7], [9, 9, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 7, 7]], ""output"": [[7]]}], ""test"": [{""input"": [[5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8, 4, 4], [5, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 3, 3, 3, 3, 2, 2, 3, 3, 3, 4, 4], [5, 5, 5, 3, 3, 3, 3, 2, 2, 3, 3, 3, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 7, 7, 7, 7, 2, 2, 7, 7, 7, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4], [5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0, 4, 4]], ""output"": [[2]]}]}"
BabENrsc6GpeE6ryxD7sfb,2025-07-21T15:52:23.264923,task1a2e2828,"[""Input grids are of size 15 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [6, 6, 4, 4, 6, 6, 6, 6, 1, 1, 1, 6, 6, 6, 8, 6, 6, 6], [6, 6, 4, 4, 6, 6, 6, 6, 1, 1, 1, 6, 6, 6, 8, 6, 6, 6], [6, 6, 4, 4, 6, 6, 6, 6, 1, 1, 1, 6, 6, 6, 8, 6, 6, 6], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [3, 3, 4, 4, 3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 8, 3, 3, 3], [3, 3, 4, 4, 3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 8, 3, 3, 3], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0]], ""output"": [[8]]}, {""input"": [[0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [4, 3, 3, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 7, 7, 7], [4, 3, 3, 4, 4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 7, 7, 7], [5, 3, 3, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 7, 7, 7], [5, 3, 3, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 7, 7, 7]], ""output"": [[1]]}, {""input"": [[0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [6, 6, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 9, 6], [6, 6, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 9, 6], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [5, 5, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5], [5, 5, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5], [5, 5, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 9, 5], [5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 9, 5], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 9, 3], [3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 9, 3], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 0], [2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 2], [2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 2], [2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 2]], ""output"": [[9]]}, {""input"": [[0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [2, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 2, 2, 2], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [1, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1], [1, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [3, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3, 3], [3, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3, 3]], ""output"": [[9]]}], ""test"": [{""input"": [[4, 4, 4, 4, 4, 6, 6, 4, 4, 9, 4, 4, 4, 4, 1, 1, 1, 4], [4, 4, 4, 4, 4, 6, 6, 4, 4, 9, 4, 4, 4, 4, 1, 1, 1, 4], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [8, 8, 8, 8, 8, 6, 6, 8, 8, 9, 8, 8, 8, 8, 1, 1, 1, 8], [8, 8, 8, 8, 8, 6, 6, 8, 8, 9, 8, 8, 8, 8, 1, 1, 1, 8], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 6, 6, 0, 0, 9, 0, 0, 0, 0, 1, 1, 1, 0]], ""output"": [[9]]}]}"
MTRKmw3L3M8Ng5285sHgvf,2025-07-21T15:52:23.268195,task1a2e2828,"[""Input grids are of size 15 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [5, 6, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 7, 7], [5, 6, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 7, 7], [5, 6, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [3, 6, 3, 3, 3, 3, 3, 9, 9, 3, 3, 3, 7, 7], [3, 6, 3, 3, 3, 3, 3, 9, 9, 3, 3, 3, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [0, 6, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7], [1, 6, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 7, 7], [1, 6, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 7, 7], [1, 6, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 7, 7]], ""output"": [[6]]}, {""input"": [[0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [6, 6, 3, 3, 6, 6, 6, 6, 5, 5, 5, 6, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [2, 2, 3, 3, 2, 2, 2, 2, 5, 5, 5, 2, 1, 1], [2, 2, 3, 3, 2, 2, 2, 2, 5, 5, 5, 2, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1], [9, 9, 3, 3, 9, 9, 9, 9, 5, 5, 5, 9, 1, 1], [9, 9, 3, 3, 9, 9, 9, 9, 5, 5, 5, 9, 1, 1], [9, 9, 3, 3, 9, 9, 9, 9, 5, 5, 5, 9, 1, 1]], ""output"": [[1]]}, {""input"": [[6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 9, 9, 9, 8, 8, 9, 9, 9, 2, 2, 9, 9], [6, 6, 9, 9, 9, 8, 8, 9, 9, 9, 2, 2, 9, 9], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 4, 4, 4, 8, 8, 4, 4, 4, 2, 2, 4, 4], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0], [6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 2, 2, 0, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [8, 8, 1, 1, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [9, 9, 1, 1, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9], [9, 9, 1, 1, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9]], ""output"": [[1]]}], ""test"": [{""input"": [[8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 4, 4, 4, 4, 3, 3, 4, 4, 7, 7, 7], [8, 8, 8, 4, 4, 4, 4, 3, 3, 4, 4, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 6, 6, 6, 6, 3, 3, 6, 6, 7, 7, 7], [8, 8, 8, 6, 6, 6, 6, 3, 3, 6, 6, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7], [8, 8, 8, 2, 2, 2, 2, 3, 3, 2, 2, 7, 7, 7], [8, 8, 8, 0, 0, 0, 0, 3, 3, 0, 0, 7, 7, 7]], ""output"": [[3]]}]}"
EaYJY32RMNKhpFaq6jHUsQ,2025-07-21T15:52:23.271318,task1a2e2828,"[""Input grids are of size 12 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 2, 2, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 4, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1], [6, 2, 2, 6, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 1, 1], [6, 2, 2, 6, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 1, 1], [0, 2, 2, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 1, 1]], ""output"": [[1]]}, {""input"": [[8, 8, 3, 3, 3, 3, 3, 3, 7, 3, 3, 3, 1, 1, 3, 3], [8, 8, 3, 3, 3, 3, 3, 3, 7, 3, 3, 3, 1, 1, 3, 3], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0], [8, 8, 9, 9, 9, 9, 9, 9, 7, 9, 9, 9, 1, 1, 9, 9], [8, 8, 9, 9, 9, 9, 9, 9, 7, 9, 9, 9, 1, 1, 9, 9], [8, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 1, 0, 0]], ""output"": [[7]]}, {""input"": [[2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 6, 6, 1], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 9, 9, 9, 9, 5, 5, 9, 9, 9, 9, 6, 6, 9], [2, 2, 2, 9, 9, 9, 9, 5, 5, 9, 9, 9, 9, 6, 6, 9], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 6, 6, 0]], ""output"": [[5]]}, {""input"": [[5, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5], [5, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5], [5, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5], [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [6, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [6, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [6, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2], [2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2], [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0]], ""output"": [[9]]}, {""input"": [[0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [9, 9, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 9, 9], [9, 9, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 9, 9], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1], [1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1], [1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 3], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 5, 5, 5, 8], [8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 5, 5, 5, 8], [0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0]], ""output"": [[4]]}]}"
5hJxxJSrQZz7juXeS64LRu,2025-07-21T15:52:23.274524,task1a2e2828,"[""Input grids are of size 12 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 5, 5, 5, 6, 6, 5, 5, 5, 5], [9, 9, 9, 5, 5, 5, 6, 6, 5, 5, 5, 5], [9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 4, 4, 4, 6, 6, 4, 4, 4, 4], [9, 9, 9, 4, 4, 4, 6, 6, 4, 4, 4, 4], [9, 9, 9, 4, 4, 4, 6, 6, 4, 4, 4, 4], [9, 9, 9, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 9, 1, 1, 1, 6, 6, 1, 1, 1, 1]], ""output"": [[6]]}, {""input"": [[6, 9, 9, 6, 6, 6, 6, 6, 3, 6, 6, 6], [6, 9, 9, 6, 6, 6, 6, 6, 3, 6, 6, 6], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [8, 9, 9, 8, 8, 8, 8, 8, 3, 8, 8, 8], [8, 9, 9, 8, 8, 8, 8, 8, 3, 8, 8, 8], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 3, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [7, 7, 7, 3, 3, 7, 7, 7, 7, 9, 9, 7], [7, 7, 7, 3, 3, 7, 7, 7, 7, 9, 9, 7], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [4, 4, 4, 3, 3, 4, 4, 4, 4, 9, 9, 4], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0], [6, 6, 6, 3, 3, 6, 6, 6, 6, 9, 9, 6], [6, 6, 6, 3, 3, 6, 6, 6, 6, 9, 9, 6], [0, 0, 0, 3, 3, 0, 0, 0, 0, 9, 9, 0]], ""output"": [[3]]}, {""input"": [[9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 4, 1, 1, 4, 4, 4, 4, 3, 3], [9, 9, 9, 4, 1, 1, 4, 4, 4, 4, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 1, 1, 0, 0, 0, 0, 3, 3], [9, 9, 9, 6, 1, 1, 6, 6, 6, 6, 3, 3]], ""output"": [[1]]}, {""input"": [[1, 1, 5, 5, 7, 7, 5, 5, 5, 5, 6, 6], [1, 1, 5, 5, 7, 7, 5, 5, 5, 5, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 3, 3, 7, 7, 3, 3, 3, 3, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 3, 3], [7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 3, 3]], ""output"": [[3]]}]}"
3xP5Tmy7A4hdF4LaUxzQr8,2025-07-21T15:52:23.277440,task1a2e2828,"[""Input grids are of size 12 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8], [5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0]], ""output"": [[5]]}, {""input"": [[5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7], [5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7]], ""output"": [[1]]}, {""input"": [[1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 1, 1], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7, 7], [7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7, 7], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [4, 4, 4, 7, 7, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 6, 6], [4, 4, 4, 7, 7, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [9, 9, 9, 7, 7, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 6, 6], [9, 9, 9, 7, 7, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 6, 6], [9, 9, 9, 7, 7, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 6, 6], [8, 8, 8, 7, 7, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 6, 6]], ""output"": [[3]]}, {""input"": [[1, 1, 1, 3, 3, 1, 1, 1, 1, 7, 7, 7, 1, 1, 1, 2, 2, 1], [1, 1, 1, 3, 3, 1, 1, 1, 1, 7, 7, 7, 1, 1, 1, 2, 2, 1], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [5, 5, 5, 3, 3, 5, 5, 5, 5, 7, 7, 7, 5, 5, 5, 2, 2, 5], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 2, 2, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 3], [3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 3], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 5], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 7], [7, 7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 7]], ""output"": [[2]]}]}"
g66PSpx8JTBoKCNTbQYFQc,2025-07-21T15:52:23.281101,task1a2e2828,"[""Input grids are of size 18 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 8, 8, 8, 8, 6, 6, 8, 8, 8, 1, 1, 8, 8], [2, 8, 8, 8, 8, 6, 6, 8, 8, 8, 1, 1, 8, 8], [2, 8, 8, 8, 8, 6, 6, 8, 8, 8, 1, 1, 8, 8], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 4, 4, 4, 4, 6, 6, 4, 4, 4, 1, 1, 4, 4], [2, 4, 4, 4, 4, 6, 6, 4, 4, 4, 1, 1, 4, 4], [2, 4, 4, 4, 4, 6, 6, 4, 4, 4, 1, 1, 4, 4], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 3, 3, 3, 3, 6, 6, 3, 3, 3, 1, 1, 3, 3], [2, 3, 3, 3, 3, 6, 6, 3, 3, 3, 1, 1, 3, 3], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0], [2, 0, 0, 0, 0, 6, 6, 0, 0, 0, 1, 1, 0, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [2, 2, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 3, 3], [2, 2, 2, 9, 9, 2, 2, 2, 2, 2, 2, 2, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3], [1, 1, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 3, 3], [0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 3, 3]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 7, 7, 7, 4], [4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 7, 7, 7, 4], [4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 7, 7, 7, 4], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 7, 7, 7, 9], [9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 7, 7, 7, 9], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 7, 7, 7, 5], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 7, 7, 7, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6], [9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[6]]}]}"
do59hjVKNWVHnRVwWVpYES,2025-07-21T15:52:23.284284,task1a2e2828,"[""Input grids are of size 11 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 8, 8], [6, 6, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8], [6, 6, 2, 2, 2, 2, 2, 2, 9, 9, 2, 2, 2, 2, 2, 2, 8, 8], [6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 8, 8]], ""output"": [[6]]}, {""input"": [[5, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2], [5, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2], [5, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [5, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2], [5, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2], [5, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2]], ""output"": [[5]]}, {""input"": [[1, 1, 1, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 7, 0], [1, 1, 1, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 7, 7, 9], [1, 1, 1, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 7, 7, 9], [1, 1, 1, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 7, 7, 9], [1, 1, 1, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 7, 0], [1, 1, 1, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 7, 0], [1, 1, 1, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 7, 0], [1, 1, 1, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 7, 7, 6], [1, 1, 1, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 7, 7, 6], [1, 1, 1, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 7, 0], [1, 1, 1, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 7, 7, 3]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4], [6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]], ""output"": [[5]]}], ""test"": [{""input"": [[2, 2, 2, 6, 6, 9, 9, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6], [2, 2, 2, 6, 6, 9, 9, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6], [2, 2, 2, 6, 6, 9, 9, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6], [2, 2, 2, 0, 0, 9, 9, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [2, 2, 2, 0, 0, 9, 9, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [2, 2, 2, 5, 5, 9, 9, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5], [2, 2, 2, 5, 5, 9, 9, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5], [2, 2, 2, 0, 0, 9, 9, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [2, 2, 2, 0, 0, 9, 9, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [2, 2, 2, 0, 0, 9, 9, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [2, 2, 2, 1, 1, 9, 9, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1]], ""output"": [[8]]}]}"
JtVbCP9D9fPjcX3sbSpSMV,2025-07-21T15:52:23.287218,task1a2e2828,"[""Input grids are of size 15 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 8, 8], [7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 8, 8], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 9, 9]], ""output"": [[6]]}, {""input"": [[4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [6, 6, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 6, 9, 9, 9, 6], [6, 6, 6, 6, 6, 7, 7, 6, 6, 6, 6, 6, 6, 9, 9, 9, 6], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0]], ""output"": [[7]]}, {""input"": [[0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [6, 6, 6, 8, 8, 8, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6], [6, 6, 6, 8, 8, 8, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9], [9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9], [9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [7, 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7, 4, 4, 7, 7, 7]], ""output"": [[4]]}], ""test"": [{""input"": [[2, 2, 7, 7, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 3, 3], [2, 2, 7, 7, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [8, 8, 7, 7, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 3, 3], [8, 8, 7, 7, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [0, 0, 7, 7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3], [9, 9, 7, 7, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 3, 3], [9, 9, 7, 7, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 3, 3]], ""output"": [[1]]}]}"
YF7WMmySUAAasbzhUwFJZe,2025-07-21T15:52:23.290114,task1a2e2828,"[""Input grids are of size 18 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2], [9, 9, 9, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 7, 7, 7, 4, 4, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7]], ""output"": [[1]]}, {""input"": [[0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [6, 8, 8, 8, 6, 6, 6, 6, 6, 9, 9, 6, 6, 6, 6, 3, 3, 3], [6, 8, 8, 8, 6, 6, 6, 6, 6, 9, 9, 6, 6, 6, 6, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [1, 8, 8, 8, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 3, 3, 3], [1, 8, 8, 8, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [5, 8, 8, 8, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [0, 8, 8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[9]]}, {""input"": [[0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7], [7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 9, 9], [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 9, 9], [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 9, 9]], ""output"": [[2]]}]}"
RtWnDt77ENvB4BVXMt6tSL,2025-07-21T15:52:23.294214,task1a2e2828,"[""Input grids are of size 13 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 4, 9, 9, 4, 4, 6, 6, 6, 4, 7, 7, 4, 4, 4, 4], [4, 4, 4, 9, 9, 4, 4, 6, 6, 6, 4, 7, 7, 4, 4, 4, 4], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [5, 5, 5, 9, 9, 5, 5, 6, 6, 6, 5, 7, 7, 5, 5, 5, 5], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 9, 9, 0, 0, 6, 6, 6, 0, 7, 7, 0, 0, 0, 0]], ""output"": [[7]]}, {""input"": [[8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 5, 5, 8, 8, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 1, 1, 6, 6, 6], [1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 1, 1, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6], [0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 6, 6, 6]], ""output"": [[5]]}, {""input"": [[7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 8, 8, 8, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8], [7, 7, 7, 8, 8, 8, 5, 5, 8, 8, 8, 8, 2, 2, 8, 8, 8], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 6, 6, 6, 5, 5, 6, 6, 6, 6, 2, 2, 6, 6, 6], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [7, 7, 7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [1, 1, 6, 6, 6, 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [7, 7, 6, 6, 6, 7, 7, 7, 4, 4, 4, 7, 7, 7, 7, 8, 8], [7, 7, 6, 6, 6, 7, 7, 7, 4, 4, 4, 7, 7, 7, 7, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8], [0, 0, 6, 6, 6, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 8, 8]], ""output"": [[8]]}, {""input"": [[0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 3, 0, 0, 1, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 3, 0, 0, 1, 0, 0, 0], [8, 8, 8, 5, 5, 8, 8, 8, 3, 3, 3, 8, 8, 1, 8, 8, 8], [8, 8, 8, 5, 5, 8, 8, 8, 3, 3, 3, 8, 8, 1, 8, 8, 8], [8, 8, 8, 5, 5, 8, 8, 8, 3, 3, 3, 8, 8, 1, 8, 8, 8], [0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 3, 0, 0, 1, 0, 0, 0], [7, 7, 7, 5, 5, 7, 7, 7, 3, 3, 3, 7, 7, 1, 7, 7, 7], [7, 7, 7, 5, 5, 7, 7, 7, 3, 3, 3, 7, 7, 1, 7, 7, 7], [7, 7, 7, 5, 5, 7, 7, 7, 3, 3, 3, 7, 7, 1, 7, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 3, 0, 0, 1, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 3, 0, 0, 1, 0, 0, 0], [4, 4, 4, 5, 5, 4, 4, 4, 3, 3, 3, 4, 4, 1, 4, 4, 4], [4, 4, 4, 5, 5, 4, 4, 4, 3, 3, 3, 4, 4, 1, 4, 4, 4]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9], [8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9]], ""output"": [[5]]}]}"
7ocJmczy6fz2skw5yhniai,2025-07-21T15:52:23.298122,task1a2e2828,"[""Input grids are of size 10 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 9, 9], [4, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 9, 9], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 9, 9]], ""output"": [[1]]}, {""input"": [[7, 7, 8, 4, 4, 8, 8, 8, 8, 9, 9, 9, 8], [7, 7, 8, 4, 4, 8, 8, 8, 8, 9, 9, 9, 8], [7, 7, 8, 4, 4, 8, 8, 8, 8, 9, 9, 9, 8], [7, 7, 0, 4, 4, 0, 0, 0, 0, 9, 9, 9, 0], [7, 7, 0, 4, 4, 0, 0, 0, 0, 9, 9, 9, 0], [7, 7, 3, 4, 4, 3, 3, 3, 3, 9, 9, 9, 3], [7, 7, 0, 4, 4, 0, 0, 0, 0, 9, 9, 9, 0], [7, 7, 0, 4, 4, 0, 0, 0, 0, 9, 9, 9, 0], [7, 7, 5, 4, 4, 5, 5, 5, 5, 9, 9, 9, 5], [7, 7, 5, 4, 4, 5, 5, 5, 5, 9, 9, 9, 5]], ""output"": [[4]]}, {""input"": [[1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 7, 7, 7, 9, 9, 7, 7, 7, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 5, 5], [1, 1, 1, 4, 4, 4, 9, 9, 4, 4, 4, 5, 5], [1, 1, 1, 4, 4, 4, 9, 9, 4, 4, 4, 5, 5]], ""output"": [[5]]}], ""test"": [{""input"": [[7, 2, 2, 7, 7, 3, 3, 7, 7, 5, 5, 7, 7], [7, 2, 2, 7, 7, 3, 3, 7, 7, 5, 5, 7, 7], [7, 2, 2, 7, 7, 3, 3, 7, 7, 5, 5, 7, 7], [0, 2, 2, 0, 0, 3, 3, 0, 0, 5, 5, 0, 0], [4, 2, 2, 4, 4, 3, 3, 4, 4, 5, 5, 4, 4], [4, 2, 2, 4, 4, 3, 3, 4, 4, 5, 5, 4, 4], [0, 2, 2, 0, 0, 3, 3, 0, 0, 5, 5, 0, 0], [0, 2, 2, 0, 0, 3, 3, 0, 0, 5, 5, 0, 0], [0, 2, 2, 0, 0, 3, 3, 0, 0, 5, 5, 0, 0], [0, 2, 2, 0, 0, 3, 3, 0, 0, 5, 5, 0, 0]], ""output"": [[2]]}]}"
eSGsPHs7YRjjZRHybrL2e6,2025-07-21T15:52:23.301544,task1a2e2828,"[""Input grids are of size 15 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 4, 4, 4, 4, 2, 2, 2, 4], [5, 5, 4, 4, 4, 4, 2, 2, 2, 4], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 3, 3, 3, 3, 2, 2, 2, 3], [5, 5, 3, 3, 3, 3, 2, 2, 2, 3], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0], [5, 5, 0, 0, 0, 0, 2, 2, 2, 0]], ""output"": [[5]]}, {""input"": [[0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [6, 6, 9, 9, 9, 6, 6, 6, 8, 8], [6, 6, 9, 9, 9, 6, 6, 6, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [0, 0, 9, 9, 9, 0, 0, 0, 8, 8], [7, 7, 9, 9, 9, 7, 7, 7, 8, 8], [7, 7, 9, 9, 9, 7, 7, 7, 8, 8]], ""output"": [[8]]}, {""input"": [[7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 9, 9, 9, 9, 9, 1, 1, 9, 9], [7, 9, 9, 9, 9, 9, 1, 1, 9, 9], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 0, 0, 1, 1, 0, 0], [7, 6, 6, 6, 6, 6, 1, 1, 6, 6], [7, 6, 6, 6, 6, 6, 1, 1, 6, 6]], ""output"": [[7]]}, {""input"": [[0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [6, 6, 6, 4, 4, 6, 6, 5, 5, 5], [6, 6, 6, 4, 4, 6, 6, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5], [2, 2, 2, 4, 4, 2, 2, 5, 5, 5], [0, 0, 0, 4, 4, 0, 0, 5, 5, 5]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [4, 8, 8, 4, 4, 4, 4, 9, 9, 4], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [2, 8, 8, 2, 2, 2, 2, 9, 9, 2], [2, 8, 8, 2, 2, 2, 2, 9, 9, 2], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0], [0, 8, 8, 0, 0, 0, 0, 9, 9, 0]], ""output"": [[8]]}]}"
PkCnT66LcQbGuirsUiffCh,2025-07-21T15:52:23.304802,task1a2e2828,"[""Input grids are of size 18 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 4, 4, 4, 1, 4, 4, 4, 4, 4, 2, 2, 4, 4], [5, 5, 4, 4, 4, 1, 4, 4, 4, 4, 4, 2, 2, 4, 4], [5, 5, 4, 4, 4, 1, 4, 4, 4, 4, 4, 2, 2, 4, 4], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 9, 9, 9, 1, 9, 9, 9, 9, 9, 2, 2, 9, 9], [5, 5, 9, 9, 9, 1, 9, 9, 9, 9, 9, 2, 2, 9, 9], [5, 5, 9, 9, 9, 1, 9, 9, 9, 9, 9, 2, 2, 9, 9], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 8, 8, 8, 1, 8, 8, 8, 8, 8, 2, 2, 8, 8], [5, 5, 8, 8, 8, 1, 8, 8, 8, 8, 8, 2, 2, 8, 8], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0], [5, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0]], ""output"": [[1]]}, {""input"": [[4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 8, 6, 6, 8, 8, 8, 8, 8, 8, 5, 5, 8], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 2, 6, 6, 2, 2, 2, 2, 2, 2, 5, 5, 2], [4, 4, 4, 2, 6, 6, 2, 2, 2, 2, 2, 2, 5, 5, 2], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 4, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5, 0]], ""output"": [[5]]}, {""input"": [[0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 3, 3, 6, 6], [6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 3, 3, 6, 6], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4], [4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4]], ""output"": [[5]]}, {""input"": [[7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 6, 6, 8, 8, 8, 6, 6, 3, 3, 3, 6, 6, 6], [7, 7, 6, 6, 8, 8, 8, 6, 6, 3, 3, 3, 6, 6, 6], [7, 7, 6, 6, 8, 8, 8, 6, 6, 3, 3, 3, 6, 6, 6], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 1, 1, 8, 8, 8, 1, 1, 3, 3, 3, 1, 1, 1], [7, 7, 1, 1, 8, 8, 8, 1, 1, 3, 3, 3, 1, 1, 1], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 0, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 4, 4, 8, 8, 8, 4, 4, 3, 3, 3, 4, 4, 4]], ""output"": [[7]]}], ""test"": [{""input"": [[4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 4], [4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 4], [4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 4], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 3], [3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 3], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 8], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]], ""output"": [[5]]}]}"
FZ7d3GaeyA3QzCErAQnuAs,2025-07-21T15:52:23.307973,task1a2e2828,"[""Input grids are of size 18 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 6, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5], [6, 6, 6, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5], [6, 6, 6, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4], [6, 6, 6, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0]], ""output"": [[8]]}, {""input"": [[5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 9, 9, 7, 7, 7, 9, 4, 4, 4, 9, 9], [5, 5, 9, 9, 7, 7, 7, 9, 4, 4, 4, 9, 9], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 0, 0, 7, 7, 7, 0, 4, 4, 4, 0, 0], [5, 5, 8, 8, 7, 7, 7, 8, 4, 4, 4, 8, 8]], ""output"": [[5]]}, {""input"": [[0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [2, 2, 2, 4, 4, 2, 2, 2, 7, 7, 2, 2, 2], [2, 2, 2, 4, 4, 2, 2, 2, 7, 7, 2, 2, 2], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [8, 8, 8, 4, 4, 8, 8, 8, 7, 7, 8, 8, 8], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [5, 4, 4, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5], [5, 4, 4, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5], [5, 4, 4, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [8, 4, 4, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8], [8, 4, 4, 8, 8, 8, 8, 8, 8, 3, 8, 8, 8], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0]], ""output"": [[3]]}]}"
PYHZi7otYc3VodJcyPPxjh,2025-07-21T15:52:23.311465,task1a2e2828,"[""Input grids are of size 16 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 16, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 5, 5], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}, {""input"": [[7, 7, 7, 7, 4, 4, 7, 7, 9, 9, 9, 7, 3, 3, 7], [7, 7, 7, 7, 4, 4, 7, 7, 9, 9, 9, 7, 3, 3, 7], [7, 7, 7, 7, 4, 4, 7, 7, 9, 9, 9, 7, 3, 3, 7], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [2, 2, 2, 2, 4, 4, 2, 2, 9, 9, 9, 2, 3, 3, 2], [2, 2, 2, 2, 4, 4, 2, 2, 9, 9, 9, 2, 3, 3, 2], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0], [1, 1, 1, 1, 4, 4, 1, 1, 9, 9, 9, 1, 3, 3, 1], [0, 0, 0, 0, 4, 4, 0, 0, 9, 9, 9, 0, 3, 3, 0]], ""output"": [[3]]}, {""input"": [[9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9], [9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 2, 2, 7, 7], [7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 2, 2, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [2, 2, 7, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2], [2, 2, 7, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [1, 1, 7, 7, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1], [1, 1, 7, 7, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1]], ""output"": [[7]]}], ""test"": [{""input"": [[0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [4, 4, 2, 2, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [7, 7, 2, 2, 7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7], [7, 7, 2, 2, 7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [5, 5, 2, 2, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5], [5, 5, 2, 2, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5], [5, 5, 2, 2, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5]], ""output"": [[2]]}]}"
mH75GAeq4qHybESYryAfYW,2025-07-21T15:52:23.315585,task1a2e2828,"[""Input grids are of size 11 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 5, 5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1], [8, 8, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 1, 9, 9, 1], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0]], ""output"": [[6]]}, {""input"": [[6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 8, 8, 8, 8, 2, 2, 8, 8, 8, 1, 1, 8, 8, 8, 8], [6, 6, 6, 8, 8, 8, 8, 2, 2, 8, 8, 8, 1, 1, 8, 8, 8, 8], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 3, 3, 3, 3, 2, 2, 3, 3, 3, 1, 1, 3, 3, 3, 3]], ""output"": [[1]]}, {""input"": [[5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 7], [5, 5, 5, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 7], [5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 6, 6, 6, 9], [5, 5, 5, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 6, 6, 6, 9], [5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 6, 6, 6, 3], [5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0], [5, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 6, 6, 6, 0]], ""output"": [[8]]}, {""input"": [[1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [9, 9, 7, 7, 7, 9, 9, 9, 9, 9, 2, 2, 9, 9, 9, 9, 5, 5], [9, 9, 7, 7, 7, 9, 9, 9, 9, 9, 2, 2, 9, 9, 9, 9, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 5, 5], [6, 6, 7, 7, 7, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6, 5, 5], [6, 6, 7, 7, 7, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6, 5, 5]], ""output"": [[2]]}, {""input"": [[8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 5, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 4, 5, 5, 5, 5], [8, 8, 5, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 4, 5, 5, 5, 5], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0], [8, 8, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 4, 9, 9, 9, 9], [8, 8, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 4, 9, 9, 9, 9], [8, 8, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 3, 3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 4, 4], [9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 4, 4], [9, 9, 9, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 4, 4], [9, 9, 9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 9, 9, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 4, 4], [9, 9, 9, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 4, 4]], ""output"": [[4]]}]}"
42WLXLvDA6qDf3Y2YQYzgJ,2025-07-21T15:52:23.319496,task1a2e2828,"[""Input grids are of size 18 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 9, 9, 5, 5, 9, 9, 8, 8, 9, 9], [6, 6, 6, 9, 9, 5, 5, 9, 9, 8, 8, 9, 9], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 3, 3, 5, 5, 3, 3, 8, 8, 3, 3], [6, 6, 6, 3, 3, 5, 5, 3, 3, 8, 8, 3, 3], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 8, 8, 0, 0], [6, 6, 6, 7, 7, 5, 5, 7, 7, 8, 8, 7, 7]], ""output"": [[5]]}, {""input"": [[7, 4, 4, 4, 2, 2, 2, 4, 4, 4, 3, 3, 4], [7, 4, 4, 4, 2, 2, 2, 4, 4, 4, 3, 3, 4], [7, 4, 4, 4, 2, 2, 2, 4, 4, 4, 3, 3, 4], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 1, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 1], [7, 1, 1, 1, 2, 2, 2, 1, 1, 1, 3, 3, 1], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0], [7, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 0]], ""output"": [[7]]}, {""input"": [[6, 6, 6, 7, 4, 4, 7, 7, 7, 5, 5, 7, 7], [6, 6, 6, 7, 4, 4, 7, 7, 7, 5, 5, 7, 7], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 2, 4, 4, 2, 2, 2, 5, 5, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0], [6, 6, 6, 0, 4, 4, 0, 0, 0, 5, 5, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 7, 3], [3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 7, 3], [3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 7, 3], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [6, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 7, 6], [6, 6, 6, 2, 2, 6, 6, 6, 6, 6, 6, 7, 6], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 7, 9], [9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 7, 9]], ""output"": [[7]]}]}"
g5WmaDwnDFYLKkFXBGbHWo,2025-07-21T15:52:23.324186,task1a2e2828,"[""Input grids are of size 17 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 3, 3, 3, 1, 1, 1, 2, 2], [1, 1, 3, 3, 3, 1, 1, 1, 2, 2], [1, 1, 3, 3, 3, 1, 1, 1, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [7, 7, 3, 3, 3, 7, 7, 7, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [4, 4, 3, 3, 3, 4, 4, 4, 2, 2], [4, 4, 3, 3, 3, 4, 4, 4, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2], [0, 0, 3, 3, 3, 0, 0, 0, 2, 2]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [1, 1, 1, 8, 8, 1, 1, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [2, 2, 2, 8, 8, 2, 2, 5, 5, 5], [2, 2, 2, 8, 8, 2, 2, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 5, 5, 5]], ""output"": [[8]]}, {""input"": [[6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 3, 2, 2, 3, 3, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 7, 2, 2, 7, 7, 9, 9], [6, 6, 6, 7, 2, 2, 7, 7, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9]], ""output"": [[2]]}, {""input"": [[5, 5, 9, 7, 7, 9, 9, 9, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 1, 7, 7, 1, 1, 1, 3, 3], [5, 5, 1, 7, 7, 1, 1, 1, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3], [5, 5, 0, 7, 7, 0, 0, 0, 3, 3]], ""output"": [[3]]}, {""input"": [[0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [1, 1, 9, 9, 1, 1, 1, 8, 8, 1], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [7, 7, 9, 9, 7, 7, 7, 8, 8, 7], [7, 7, 9, 9, 7, 7, 7, 8, 8, 7], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [5, 5, 9, 9, 5, 5, 5, 8, 8, 5], [5, 5, 9, 9, 5, 5, 5, 8, 8, 5], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0], [0, 0, 9, 9, 0, 0, 0, 8, 8, 0]], ""output"": [[8]]}], ""test"": [{""input"": [[7, 7, 7, 2, 2, 9, 9, 2, 2, 2], [7, 7, 7, 2, 2, 9, 9, 2, 2, 2], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 5, 5, 9, 9, 5, 5, 5], [7, 7, 7, 5, 5, 9, 9, 5, 5, 5], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 6, 6, 9, 9, 6, 6, 6], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0], [7, 7, 7, 0, 0, 9, 9, 0, 0, 0]], ""output"": [[9]]}]}"
7sLQEYB3dgsWhXMJAk3jbS,2025-07-21T15:52:23.327925,task1a2e2828,"[""Input grids are of size 11 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 2, 2, 5, 5, 5, 5, 5, 8, 8, 5], [5, 5, 2, 2, 5, 5, 5, 5, 5, 8, 8, 5], [5, 5, 2, 2, 5, 5, 5, 5, 5, 8, 8, 5], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [9, 9, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9], [9, 9, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [6, 6, 2, 2, 6, 6, 6, 6, 6, 8, 8, 6]], ""output"": [[2]]}, {""input"": [[1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8], [1, 1, 8, 8, 8, 8, 8, 8, 8, 5, 5, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0]], ""output"": [[1]]}, {""input"": [[8, 8, 6, 6, 8, 8, 8, 8, 8, 8, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2], [1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 2, 2], [1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 2, 2], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 1, 1], [7, 7, 7, 7, 2, 2, 7, 7, 7, 7, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 1], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 1, 1]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [5, 5, 5, 6, 6, 5, 9, 9, 5, 5, 2, 5], [5, 5, 5, 6, 6, 5, 9, 9, 5, 5, 2, 5], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [1, 1, 1, 6, 6, 1, 9, 9, 1, 1, 2, 1], [1, 1, 1, 6, 6, 1, 9, 9, 1, 1, 2, 1], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0], [0, 0, 0, 6, 6, 0, 9, 9, 0, 0, 2, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [4, 4, 8, 8, 4, 4, 4, 4, 4, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 8, 8, 5, 5, 5, 5, 5, 9, 9, 9], [5, 5, 8, 8, 5, 5, 5, 5, 5, 9, 9, 9]], ""output"": [[8]]}]}"
3r3QL8zQujLrEiigzr98TU,2025-07-21T15:52:23.333450,task1a2e2828,"[""Input grids are of size 12 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [5, 7, 7, 7, 5, 5, 5, 3, 3, 5, 5, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4], [2, 7, 7, 7, 2, 2, 2, 3, 3, 2, 2, 4, 4], [2, 7, 7, 7, 2, 2, 2, 3, 3, 2, 2, 4, 4], [0, 7, 7, 7, 0, 0, 0, 3, 3, 0, 0, 4, 4]], ""output"": [[3]]}, {""input"": [[4, 4, 2, 2, 5, 5, 2, 2, 2, 7, 2, 2, 2], [4, 4, 2, 2, 5, 5, 2, 2, 2, 7, 2, 2, 2], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 1, 1, 5, 5, 1, 1, 1, 7, 1, 1, 1], [4, 4, 1, 1, 5, 5, 1, 1, 1, 7, 1, 1, 1], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0], [4, 4, 0, 0, 5, 5, 0, 0, 0, 7, 0, 0, 0]], ""output"": [[7]]}, {""input"": [[9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 6, 6, 6, 6, 6, 6, 5, 5, 5, 6, 6], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4], [9, 9, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [9, 9, 8, 8, 8, 8, 8, 8, 5, 5, 5, 8, 8], [9, 9, 8, 8, 8, 8, 8, 8, 5, 5, 5, 8, 8]], ""output"": [[9]]}, {""input"": [[4, 7, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4], [4, 7, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4], [4, 7, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [9, 7, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9, 9], [9, 7, 9, 9, 9, 9, 9, 9, 2, 2, 9, 9, 9], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0]], ""output"": [[7]]}], ""test"": [{""input"": [[0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [8, 8, 8, 4, 4, 8, 8, 8, 1, 1, 8, 5, 5], [8, 8, 8, 4, 4, 8, 8, 8, 1, 1, 8, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [6, 6, 6, 4, 4, 6, 6, 6, 1, 1, 6, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5], [0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 5, 5]], ""output"": [[1]]}]}"
A3LdmirEmpYT4ZRrpkvNft,2025-07-21T15:52:23.336798,task1a2e2828,"[""Input grids are of size 10 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 8, 8, 8, 3, 3, 3, 9, 9, 3, 3, 2, 2], [3, 8, 8, 8, 3, 3, 3, 9, 9, 3, 3, 2, 2], [0, 8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 2, 2], [4, 8, 8, 8, 4, 4, 4, 9, 9, 4, 4, 2, 2], [4, 8, 8, 8, 4, 4, 4, 9, 9, 4, 4, 2, 2], [0, 8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 2, 2], [0, 8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 2, 2], [7, 8, 8, 8, 7, 7, 7, 9, 9, 7, 7, 2, 2]], ""output"": [[2]]}, {""input"": [[2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1], [2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1], [2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 7]], ""output"": [[2]]}, {""input"": [[5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 3, 3, 9, 9, 3, 3, 3, 4, 4, 3], [5, 5, 5, 3, 3, 9, 9, 3, 3, 3, 4, 4, 3], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 1, 1, 9, 9, 1, 1, 1, 4, 4, 1], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6], [0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6], [1, 1, 1, 2, 2, 1, 1, 7, 7, 7, 1, 1, 6], [1, 1, 1, 2, 2, 1, 1, 7, 7, 7, 1, 1, 6], [0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6], [0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6], [0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6], [9, 9, 9, 2, 2, 9, 9, 7, 7, 7, 9, 9, 6], [9, 9, 9, 2, 2, 9, 9, 7, 7, 7, 9, 9, 6], [0, 0, 0, 2, 2, 0, 0, 7, 7, 7, 0, 0, 6]], ""output"": [[6]]}]}"
CEHyKpV6NGm9d38qrstUFX,2025-07-21T15:52:23.340128,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[7, 7, 4, 4, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7], [7, 7, 4, 4, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 3, 4, 4, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7, 7], [3, 3, 3, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7, 7], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [3, 3, 3, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6], [3, 3, 3, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6], [3, 3, 3, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6, 6], [3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 7, 7, 7], [4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 7, 7, 7], [4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 7, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 7, 7, 7], [2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 7, 7, 7], [2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 7, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 7, 7, 7], [3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 7, 7, 7], [3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 7, 7, 7], [3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 7, 7, 7]], ""output"": [[5]]}, {""input"": [[6, 6, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2], [6, 6, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2], [6, 6, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1], [6, 6, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0]], ""output"": [[7]]}], ""test"": [{""input"": [[0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 4, 4, 4, 2, 2, 2, 6, 6, 2, 2, 2, 2], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [8, 8, 4, 4, 4, 8, 8, 8, 6, 6, 8, 8, 8, 8], [8, 8, 4, 4, 4, 8, 8, 8, 6, 6, 8, 8, 8, 8], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0, 0], [9, 9, 4, 4, 4, 9, 9, 9, 6, 6, 9, 9, 9, 9], [9, 9, 4, 4, 4, 9, 9, 9, 6, 6, 9, 9, 9, 9]], ""output"": [[6]]}]}"
AiX9phdXNVoXDDcCAid8BH,2025-07-21T15:52:23.343374,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [1, 1, 1, 5, 5, 5, 1, 4, 4, 1, 6, 6, 1, 1], [1, 1, 1, 5, 5, 5, 1, 4, 4, 1, 6, 6, 1, 1], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [7, 7, 7, 5, 5, 5, 7, 4, 4, 7, 6, 6, 7, 7], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0], [0, 0, 0, 5, 5, 5, 0, 4, 4, 0, 6, 6, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [2, 1, 1, 2, 2, 3, 3, 2, 2, 5, 2, 2, 2, 2], [2, 1, 1, 2, 2, 3, 3, 2, 2, 5, 2, 2, 2, 2], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [0, 1, 1, 0, 0, 3, 3, 0, 0, 5, 0, 0, 0, 0], [7, 1, 1, 7, 7, 3, 3, 7, 7, 5, 7, 7, 7, 7], [7, 1, 1, 7, 7, 3, 3, 7, 7, 5, 7, 7, 7, 7]], ""output"": [[5]]}, {""input"": [[8, 8, 2, 4, 4, 2, 2, 2, 2, 2, 2, 9, 9, 9], [8, 8, 2, 4, 4, 2, 2, 2, 2, 2, 2, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 9, 9, 9], [8, 8, 3, 4, 4, 3, 3, 3, 3, 3, 3, 9, 9, 9]], ""output"": [[4]]}, {""input"": [[0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [7, 7, 8, 8, 7, 7, 7, 9, 9, 9, 7, 7, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1], [4, 4, 8, 8, 4, 4, 4, 9, 9, 9, 4, 4, 1, 1], [4, 4, 8, 8, 4, 4, 4, 9, 9, 9, 4, 4, 1, 1], [0, 0, 8, 8, 0, 0, 0, 9, 9, 9, 0, 0, 1, 1]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4], [1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4], [7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4]], ""output"": [[3]]}]}"
oUP7LcKFR6oFkLiyoGL2Cv,2025-07-21T15:52:23.347311,task1a2e2828,"[""Input grids are of size 11 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[2, 2, 2, 6, 6, 2, 2, 2, 2, 8, 8, 8], [2, 2, 2, 6, 6, 2, 2, 2, 2, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [3, 3, 3, 6, 6, 3, 3, 3, 3, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 8, 8, 8]], ""output"": [[6]]}, {""input"": [[1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 9], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 9], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9], [8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 9], [8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 9]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [5, 5, 5, 4, 5, 5, 5, 5, 5, 9, 9, 5], [5, 5, 5, 4, 5, 5, 5, 5, 5, 9, 9, 5], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [1, 1, 1, 4, 1, 1, 1, 1, 1, 9, 9, 1], [1, 1, 1, 4, 1, 1, 1, 1, 1, 9, 9, 1], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 9, 9, 0]], ""output"": [[4]]}, {""input"": [[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5], [1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[1]]}, {""input"": [[6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 1, 1, 7, 7, 1, 1, 1, 1, 1], [6, 6, 6, 1, 1, 7, 7, 1, 1, 1, 1, 1], [6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 8, 8, 7, 7, 8, 8, 8, 8, 8], [6, 6, 6, 8, 8, 7, 7, 8, 8, 8, 8, 8], [6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 3, 3, 7, 7, 3, 3, 3, 3, 3], [6, 6, 6, 0, 0, 7, 7, 0, 0, 0, 0, 0]], ""output"": [[7]]}], ""test"": [{""input"": [[5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9], [5, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9], [5, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9], [5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 2, 2, 2, 2, 2, 8, 8, 2, 2, 2, 2], [5, 2, 2, 2, 2, 2, 8, 8, 2, 2, 2, 2], [5, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0]], ""output"": [[5]]}]}"
JiMwdmpvecNRfbTX54zW9W,2025-07-21T15:52:23.350520,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[2, 2, 2, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3], [2, 2, 2, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[4, 9, 9, 4, 4, 4, 5, 5, 4, 4, 7, 4, 4, 4], [4, 9, 9, 4, 4, 4, 5, 5, 4, 4, 7, 4, 4, 4], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [3, 9, 9, 3, 3, 3, 5, 5, 3, 3, 7, 3, 3, 3], [3, 9, 9, 3, 3, 3, 5, 5, 3, 3, 7, 3, 3, 3], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [0, 9, 9, 0, 0, 0, 5, 5, 0, 0, 7, 0, 0, 0], [8, 9, 9, 8, 8, 8, 5, 5, 8, 8, 7, 8, 8, 8], [8, 9, 9, 8, 8, 8, 5, 5, 8, 8, 7, 8, 8, 8]], ""output"": [[7]]}, {""input"": [[0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [8, 3, 3, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8, 7], [8, 3, 3, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7], [9, 3, 3, 9, 9, 9, 9, 9, 5, 5, 9, 9, 9, 7], [9, 3, 3, 9, 9, 9, 9, 9, 5, 5, 9, 9, 9, 7], [0, 3, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7]], ""output"": [[7]]}, {""input"": [[0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1], [6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [3, 9, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1], [3, 9, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1], [3, 9, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1]], ""output"": [[1]]}, {""input"": [[0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [9, 2, 2, 2, 9, 9, 9, 7, 7, 9, 9, 1, 1, 1], [9, 2, 2, 2, 9, 9, 9, 7, 7, 9, 9, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1], [8, 2, 2, 2, 8, 8, 8, 7, 7, 8, 8, 1, 1, 1], [0, 2, 2, 2, 0, 0, 0, 7, 7, 0, 0, 1, 1, 1]], ""output"": [[7]]}], ""test"": [{""input"": [[2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 8, 8, 8, 4, 4, 8, 8, 8, 1, 1, 1], [2, 2, 2, 8, 8, 8, 4, 4, 8, 8, 8, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 7, 7, 7, 4, 4, 7, 7, 7, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1], [2, 2, 2, 0, 0, 0, 4, 4, 0, 0, 0, 1, 1, 1]], ""output"": [[4]]}]}"
6VbpJfTkaD6UUeWpiWvd3N,2025-07-21T15:52:23.354995,task1a2e2828,"[""Input grids are of size 14 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 5, 5, 5], [3, 3, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 7, 7, 5, 5, 5], [3, 3, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 7, 7, 5, 5, 5], [3, 3, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 7, 7, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 9, 9, 9, 9, 9, 9, 9, 2, 2, 2, 9, 9, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 5, 5, 5]], ""output"": [[3]]}, {""input"": [[0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [7, 4, 4, 7, 7, 7, 5, 5, 7, 7, 7, 3, 3, 7, 7, 7, 7], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [1, 4, 4, 1, 1, 1, 5, 5, 1, 1, 1, 3, 3, 1, 1, 1, 1], [1, 4, 4, 1, 1, 1, 5, 5, 1, 1, 1, 3, 3, 1, 1, 1, 1], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0], [2, 4, 4, 2, 2, 2, 5, 5, 2, 2, 2, 3, 3, 2, 2, 2, 2], [2, 4, 4, 2, 2, 2, 5, 5, 2, 2, 2, 3, 3, 2, 2, 2, 2], [0, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [7, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 4, 4, 7, 7, 7, 7], [7, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 4, 4, 7, 7, 7, 7], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [8, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8], [8, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [3, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [1, 1, 2, 1, 1, 1, 7, 7, 7, 1, 1, 6, 6, 1, 1, 1, 1], [1, 1, 2, 1, 1, 1, 7, 7, 7, 1, 1, 6, 6, 1, 1, 1, 1], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 2, 4, 4, 4, 7, 7, 7, 4, 4, 6, 6, 4, 4, 4, 4], [4, 4, 2, 4, 4, 4, 7, 7, 7, 4, 4, 6, 6, 4, 4, 4, 4], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 7, 7, 7, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 2, 5, 5, 5, 7, 7, 7, 5, 5, 6, 6, 5, 5, 5, 5], [5, 5, 2, 5, 5, 5, 7, 7, 7, 5, 5, 6, 6, 5, 5, 5, 5]], ""output"": [[2]]}, {""input"": [[4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 3, 3, 3, 7, 7, 7, 3, 3, 3, 3, 2, 2, 3, 3, 3], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 2, 2, 6, 6, 6], [4, 4, 6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 2, 2, 6, 6, 6], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 2, 2, 1, 1, 1], [4, 4, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 2, 2, 1, 1, 1]], ""output"": [[2]]}], ""test"": [{""input"": [[1, 1, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 3, 3, 4], [1, 1, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 3, 3, 4], [1, 1, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 3, 3, 4], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0], [1, 1, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 3, 3, 2], [1, 1, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 3, 3, 2], [1, 1, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 3, 3, 2], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0], [1, 1, 5, 5, 5, 5, 5, 5, 7, 5, 5, 5, 5, 5, 3, 3, 5], [1, 1, 5, 5, 5, 5, 5, 5, 7, 5, 5, 5, 5, 5, 3, 3, 5], [1, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 3, 0]], ""output"": [[7]]}]}"
M4MYoQBHgm3N4gtCrKNhhb,2025-07-21T15:52:23.358456,task1a2e2828,"[""Input grids are of size 17 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 6, 3, 3, 1, 1, 3, 3, 3, 3, 3, 9, 9, 9], [6, 6, 6, 3, 3, 1, 1, 3, 3, 3, 3, 3, 9, 9, 9], [6, 6, 6, 3, 3, 1, 1, 3, 3, 3, 3, 3, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 5, 5, 1, 1, 5, 5, 5, 5, 5, 9, 9, 9], [6, 6, 6, 5, 5, 1, 1, 5, 5, 5, 5, 5, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 7, 7, 1, 1, 7, 7, 7, 7, 7, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 9, 9, 9]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 6, 6, 6], [2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 9, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [5, 5, 5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 6, 6, 6], [5, 5, 5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 6, 6, 6]], ""output"": [[3]]}, {""input"": [[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2], [2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [8, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [5, 5, 5, 5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 9, 9]], ""output"": [[6]]}]}"
ZKSsRXM74KX3GGzabjAtEi,2025-07-21T15:52:23.362160,task1a2e2828,"[""Input grids are of size 17 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 4, 4, 5, 5, 5, 5, 8, 5, 5, 5, 5, 9, 9], [5, 5, 4, 4, 5, 5, 5, 5, 8, 5, 5, 5, 5, 9, 9], [5, 5, 4, 4, 5, 5, 5, 5, 8, 5, 5, 5, 5, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [1, 1, 4, 4, 1, 1, 1, 1, 8, 1, 1, 1, 1, 9, 9], [1, 1, 4, 4, 1, 1, 1, 1, 8, 1, 1, 1, 1, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 8, 0, 0, 0, 0, 9, 9]], ""output"": [[8]]}, {""input"": [[3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 5, 5, 5, 9, 9, 5, 5, 5, 5, 7, 7, 5], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 1, 1, 1, 9, 9, 1, 1, 1, 1, 7, 7, 1], [3, 3, 3, 1, 1, 1, 9, 9, 1, 1, 1, 1, 7, 7, 1], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 0, 0, 0, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 6, 6, 6, 9, 9, 6, 6, 6, 6, 7, 7, 6], [3, 3, 3, 6, 6, 6, 9, 9, 6, 6, 6, 6, 7, 7, 6], [3, 3, 3, 6, 6, 6, 9, 9, 6, 6, 6, 6, 7, 7, 6]], ""output"": [[7]]}, {""input"": [[0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [1, 1, 2, 2, 2, 1, 1, 1, 9, 9, 9, 1, 1, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8], [3, 3, 2, 2, 2, 3, 3, 3, 9, 9, 9, 3, 3, 8, 8], [3, 3, 2, 2, 2, 3, 3, 3, 9, 9, 9, 3, 3, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 9, 9, 9, 0, 0, 8, 8]], ""output"": [[8]]}, {""input"": [[0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [7, 7, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6], [7, 7, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6], [4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [3, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6]], ""output"": [[6]]}], ""test"": [{""input"": [[3, 3, 3, 9, 9, 3, 3, 3, 1, 1, 3, 3, 3, 8, 3], [3, 3, 3, 9, 9, 3, 3, 3, 1, 1, 3, 3, 3, 8, 3], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [4, 4, 4, 9, 9, 4, 4, 4, 1, 1, 4, 4, 4, 8, 4], [4, 4, 4, 9, 9, 4, 4, 4, 1, 1, 4, 4, 4, 8, 4], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0], [7, 7, 7, 9, 9, 7, 7, 7, 1, 1, 7, 7, 7, 8, 7], [7, 7, 7, 9, 9, 7, 7, 7, 1, 1, 7, 7, 7, 8, 7], [7, 7, 7, 9, 9, 7, 7, 7, 1, 1, 7, 7, 7, 8, 7], [0, 0, 0, 9, 9, 0, 0, 0, 1, 1, 0, 0, 0, 8, 0]], ""output"": [[8]]}]}"
dvSy4pNQyDLBU24CXtg3co,2025-07-21T15:52:23.365735,task1a2e2828,"[""Input grids are of size 14 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 9, 4, 4, 7, 7, 4, 4, 4, 4], [9, 9, 9, 4, 4, 7, 7, 4, 4, 4, 4], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 3, 3, 7, 7, 3, 3, 3, 3], [9, 9, 9, 3, 3, 7, 7, 3, 3, 3, 3], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 8, 8, 7, 7, 8, 8, 8, 8], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0], [9, 9, 9, 0, 0, 7, 7, 0, 0, 0, 0]], ""output"": [[7]]}, {""input"": [[0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [8, 5, 5, 5, 8, 8, 8, 8, 1, 1, 8], [8, 5, 5, 5, 8, 8, 8, 8, 1, 1, 8], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [2, 5, 5, 5, 2, 2, 2, 2, 1, 1, 2], [2, 5, 5, 5, 2, 2, 2, 2, 1, 1, 2], [2, 5, 5, 5, 2, 2, 2, 2, 1, 1, 2], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0], [0, 5, 5, 5, 0, 0, 0, 0, 1, 1, 0]], ""output"": [[1]]}, {""input"": [[4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 6, 6, 6, 9, 9, 6, 6, 6, 6], [4, 4, 6, 6, 6, 9, 9, 6, 6, 6, 6], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 1, 1, 1, 9, 9, 1, 1, 1, 1], [4, 4, 1, 1, 1, 9, 9, 1, 1, 1, 1], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 0, 0, 0, 9, 9, 0, 0, 0, 0], [4, 4, 5, 5, 5, 9, 9, 5, 5, 5, 5]], ""output"": [[4]]}], ""test"": [{""input"": [[1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 3, 2, 2, 3, 3, 3, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 0, 2, 2, 0, 0, 0, 7, 7], [1, 1, 1, 6, 2, 2, 6, 6, 6, 7, 7], [1, 1, 1, 6, 2, 2, 6, 6, 6, 7, 7]], ""output"": [[2]]}]}"
Z2nBUkAVkkFe3mwuwWVNPR,2025-07-21T15:52:23.368981,task1a2e2828,"[""Input grids are of size 14 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 6, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 1], [1, 6, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 1], [1, 6, 1, 1, 1, 1, 1, 7, 7, 1, 1, 1, 1], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [5, 6, 5, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5], [5, 6, 5, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0]], ""output"": [[6]]}, {""input"": [[1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 2, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 9, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9], [1, 1, 9, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 1, 1], [3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 1], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 1, 1], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 1, 1], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 1, 1]], ""output"": [[1]]}, {""input"": [[2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8], [2, 2, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [2, 6, 6, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2], [2, 6, 6, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]], ""output"": [[1]]}]}"
MLBHtAxb2erFdxFx7W3wFM,2025-07-21T15:52:23.372288,task1a2e2828,"[""Input grids are of size 18 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 6, 9], [7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 6, 9], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 4], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0]], ""output"": [[7]]}, {""input"": [[0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [9, 5, 5, 9, 9, 9, 6, 9, 9, 9, 9, 9, 3, 3, 3], [9, 5, 5, 9, 9, 9, 6, 9, 9, 9, 9, 9, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [7, 5, 5, 7, 7, 7, 6, 7, 7, 7, 7, 7, 3, 3, 3], [7, 5, 5, 7, 7, 7, 6, 7, 7, 7, 7, 7, 3, 3, 3], [7, 5, 5, 7, 7, 7, 6, 7, 7, 7, 7, 7, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3], [0, 5, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[6]]}, {""input"": [[1, 1, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 2, 2, 2], [1, 1, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 2, 2, 2], [1, 1, 6, 6, 6, 6, 6, 6, 5, 5, 6, 6, 2, 2, 2]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [8, 9, 8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8], [8, 9, 8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 9, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4], [4, 9, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4], [0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0]], ""output"": [[9]]}]}"
oUVieE8ErsynE56nPDCubd,2025-07-21T15:52:23.376490,task1a2e2828,"[""Input grids are of size 10 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 5, 5, 3, 3, 3, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [4, 4, 5, 5, 4, 4, 4, 1, 1, 1], [4, 4, 5, 5, 4, 4, 4, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 1, 1, 1]], ""output"": [[5]]}, {""input"": [[8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 7, 6, 6, 7, 7, 7, 7], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0], [8, 8, 8, 3, 6, 6, 3, 3, 3, 3], [8, 8, 8, 3, 6, 6, 3, 3, 3, 3], [8, 8, 8, 0, 6, 6, 0, 0, 0, 0]], ""output"": [[6]]}, {""input"": [[1, 1, 1, 2, 2, 7, 7, 2, 2, 2], [1, 1, 1, 2, 2, 7, 7, 2, 2, 2], [1, 1, 1, 2, 2, 7, 7, 2, 2, 2], [1, 1, 1, 0, 0, 7, 7, 0, 0, 0], [1, 1, 1, 6, 6, 7, 7, 6, 6, 6], [1, 1, 1, 6, 6, 7, 7, 6, 6, 6], [1, 1, 1, 0, 0, 7, 7, 0, 0, 0], [1, 1, 1, 0, 0, 7, 7, 0, 0, 0], [1, 1, 1, 0, 0, 7, 7, 0, 0, 0], [1, 1, 1, 8, 8, 7, 7, 8, 8, 8]], ""output"": [[7]]}, {""input"": [[0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [5, 7, 7, 7, 5, 5, 5, 5, 1, 1], [5, 7, 7, 7, 5, 5, 5, 5, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [0, 7, 7, 7, 0, 0, 0, 0, 1, 1], [3, 7, 7, 7, 3, 3, 3, 3, 1, 1]], ""output"": [[1]]}, {""input"": [[0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [3, 3, 9, 9, 3, 3, 3, 7, 7, 7], [3, 3, 9, 9, 3, 3, 3, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [0, 0, 9, 9, 0, 0, 0, 7, 7, 7], [2, 2, 9, 9, 2, 2, 2, 7, 7, 7]], ""output"": [[9]]}], ""test"": [{""input"": [[6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 3, 2, 2, 3, 3, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 1, 2, 2, 1, 1, 9, 9], [6, 6, 6, 1, 2, 2, 1, 1, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9], [6, 6, 6, 0, 2, 2, 0, 0, 9, 9]], ""output"": [[2]]}]}"
6kUPzTbBam6VpjtumDDDJL,2025-07-21T15:52:23.380144,task1a2e2828,"[""Input grids are of size 18 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [5, 2, 2, 5, 7, 7, 5, 1, 1, 5], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [9, 2, 2, 9, 7, 7, 9, 1, 1, 9], [9, 2, 2, 9, 7, 7, 9, 1, 1, 9], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0], [0, 2, 2, 0, 7, 7, 0, 1, 1, 0]], ""output"": [[1]]}, {""input"": [[9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 5, 5, 5, 5, 3, 3, 5, 5], [9, 9, 5, 5, 5, 5, 3, 3, 5, 5], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 2, 2, 2, 2, 3, 3, 2, 2], [9, 9, 2, 2, 2, 2, 3, 3, 2, 2], [9, 9, 2, 2, 2, 2, 3, 3, 2, 2]], ""output"": [[3]]}, {""input"": [[4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 9, 9, 9, 9, 8, 8, 8, 9], [4, 4, 9, 9, 9, 9, 8, 8, 8, 9], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 2, 2, 2, 2, 8, 8, 8, 2], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0], [4, 4, 7, 7, 7, 7, 8, 8, 8, 7], [4, 4, 7, 7, 7, 7, 8, 8, 8, 7], [4, 4, 0, 0, 0, 0, 8, 8, 8, 0]], ""output"": [[4]]}, {""input"": [[3, 3, 9, 9, 9, 9, 2, 2, 9, 9], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 4, 4, 4, 4, 2, 2, 4, 4], [3, 3, 4, 4, 4, 4, 2, 2, 4, 4], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 7, 7, 7, 7, 2, 2, 7, 7], [3, 3, 7, 7, 7, 7, 2, 2, 7, 7], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0], [3, 3, 0, 0, 0, 0, 2, 2, 0, 0]], ""output"": [[2]]}, {""input"": [[4, 9, 9, 8, 8, 9, 9, 9, 7, 7], [4, 9, 9, 8, 8, 9, 9, 9, 7, 7], [4, 9, 9, 8, 8, 9, 9, 9, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 6, 6, 8, 8, 6, 6, 6, 7, 7], [4, 6, 6, 8, 8, 6, 6, 6, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7], [4, 0, 0, 8, 8, 0, 0, 0, 7, 7]], ""output"": [[4]]}], ""test"": [{""input"": [[8, 8, 8, 4, 5, 5, 4, 4, 1, 4], [8, 8, 8, 4, 5, 5, 4, 4, 1, 4], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 9, 5, 5, 9, 9, 1, 9], [8, 8, 8, 9, 5, 5, 9, 9, 1, 9], [8, 8, 8, 9, 5, 5, 9, 9, 1, 9], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0], [8, 8, 8, 2, 5, 5, 2, 2, 1, 2], [8, 8, 8, 2, 5, 5, 2, 2, 1, 2], [8, 8, 8, 0, 5, 5, 0, 0, 1, 0]], ""output"": [[1]]}]}"
622h9syhg3QdFheVcLztzk,2025-07-21T15:52:23.383411,task1a2e2828,"[""Input grids are of size 15 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [4, 4, 4, 2, 2, 4, 4, 4, 9, 9, 9], [4, 4, 4, 2, 2, 4, 4, 4, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9], [1, 1, 1, 2, 2, 1, 1, 1, 9, 9, 9], [0, 0, 0, 2, 2, 0, 0, 0, 9, 9, 9]], ""output"": [[2]]}, {""input"": [[1, 1, 1, 8, 8, 8, 4, 4, 8, 8, 8], [1, 1, 1, 8, 8, 8, 4, 4, 8, 8, 8], [1, 1, 1, 8, 8, 8, 4, 4, 8, 8, 8], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 9, 9, 9, 4, 4, 9, 9, 9], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 6, 6, 6, 4, 4, 6, 6, 6], [1, 1, 1, 6, 6, 6, 4, 4, 6, 6, 6], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0], [1, 1, 1, 0, 0, 0, 4, 4, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [3, 3, 8, 8, 3, 3, 3, 3, 2, 2, 3], [3, 3, 8, 8, 3, 3, 3, 3, 2, 2, 3], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [4, 4, 8, 8, 4, 4, 4, 4, 2, 2, 4], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 2, 2, 0], [6, 6, 8, 8, 6, 6, 6, 6, 2, 2, 6], [6, 6, 8, 8, 6, 6, 6, 6, 2, 2, 6], [6, 6, 8, 8, 6, 6, 6, 6, 2, 2, 6]], ""output"": [[2]]}, {""input"": [[0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [5, 6, 6, 5, 5, 5, 5, 5, 4, 4, 5], [5, 6, 6, 5, 5, 5, 5, 5, 4, 4, 5], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [8, 6, 6, 8, 8, 8, 8, 8, 4, 4, 8], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [1, 6, 6, 1, 1, 1, 1, 1, 4, 4, 1], [1, 6, 6, 1, 1, 1, 1, 1, 4, 4, 1], [1, 6, 6, 1, 1, 1, 1, 1, 4, 4, 1], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0], [0, 6, 6, 0, 0, 0, 0, 0, 4, 4, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [8, 8, 9, 9, 8, 8, 8, 8, 5, 5, 5], [8, 8, 9, 9, 8, 8, 8, 8, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [3, 3, 9, 9, 3, 3, 3, 3, 5, 5, 5], [3, 3, 9, 9, 3, 3, 3, 3, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 5]], ""output"": [[9]]}]}"
UrW8uMCtv8syVydNTBmXhW,2025-07-21T15:52:23.386467,task1a2e2828,"[""Input grids are of size 17 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 6, 6, 6, 6, 5, 5, 6, 6, 6], [3, 6, 6, 6, 6, 5, 5, 6, 6, 6], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 7, 7, 7, 7, 5, 5, 7, 7, 7], [3, 7, 7, 7, 7, 5, 5, 7, 7, 7], [3, 7, 7, 7, 7, 5, 5, 7, 7, 7], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0], [3, 0, 0, 0, 0, 5, 5, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [6, 6, 1, 1, 6, 5, 6, 6, 9, 9], [6, 6, 1, 1, 6, 5, 6, 6, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9], [7, 7, 1, 1, 7, 5, 7, 7, 9, 9], [7, 7, 1, 1, 7, 5, 7, 7, 9, 9], [0, 0, 1, 1, 0, 5, 0, 0, 9, 9]], ""output"": [[5]]}, {""input"": [[0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [2, 4, 4, 2, 1, 1, 2, 2, 9, 9], [2, 4, 4, 2, 1, 1, 2, 2, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9], [5, 4, 4, 5, 1, 1, 5, 5, 9, 9], [0, 4, 4, 0, 1, 1, 0, 0, 9, 9]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [3, 3, 6, 6, 3, 3, 3, 7, 7, 3], [3, 3, 6, 6, 3, 3, 3, 7, 7, 3], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [1, 1, 6, 6, 1, 1, 1, 7, 7, 1], [0, 0, 6, 6, 0, 0, 0, 7, 7, 0]], ""output"": [[6]]}]}"
eW9Pwpd6TnbQP2eNHjxqmW,2025-07-21T15:52:23.389583,task1a2e2828,"[""Input grids are of size 13 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 8, 8], [5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 8], [4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 8, 8], [4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 8, 8], [4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 8, 8]], ""output"": [[6]]}, {""input"": [[1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 4, 4, 4, 4, 4, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7], [1, 1, 1, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[9]]}, {""input"": [[9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3], [9, 9, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 4, 4, 4, 5, 5, 5], [9, 9, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 4, 4, 4, 5, 5, 5], [9, 9, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 4, 4, 4, 5, 5, 5], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 4, 4, 4, 8, 8, 8], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0]], ""output"": [[7]]}, {""input"": [[9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6], [9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5], [9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0]], ""output"": [[9]]}, {""input"": [[0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4], [4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [6, 6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6, 6], [6, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6, 6], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [4, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 4, 4, 4], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0]], ""output"": [[1]]}]}"
MgjmjXS2h8A4DSmYrqjWcy,2025-07-21T15:52:23.393651,task1a2e2828,"[""Input grids are of size 10 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 4, 6, 6, 6, 9, 9, 6, 6, 6], [4, 4, 4, 6, 6, 6, 9, 9, 6, 6, 6], [4, 4, 4, 0, 0, 0, 9, 9, 0, 0, 0], [4, 4, 4, 0, 0, 0, 9, 9, 0, 0, 0], [4, 4, 4, 7, 7, 7, 9, 9, 7, 7, 7], [4, 4, 4, 7, 7, 7, 9, 9, 7, 7, 7], [4, 4, 4, 7, 7, 7, 9, 9, 7, 7, 7], [4, 4, 4, 0, 0, 0, 9, 9, 0, 0, 0], [4, 4, 4, 5, 5, 5, 9, 9, 5, 5, 5], [4, 4, 4, 0, 0, 0, 9, 9, 0, 0, 0]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [1, 1, 1, 7, 7, 1, 1, 1, 1, 6, 6], [1, 1, 1, 7, 7, 1, 1, 1, 1, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6], [5, 5, 5, 7, 7, 5, 5, 5, 5, 6, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 6, 6]], ""output"": [[6]]}, {""input"": [[0, 0, 4, 4, 0, 0, 0, 0, 0, 9, 9], [2, 2, 4, 4, 2, 2, 2, 2, 2, 9, 9], [2, 2, 4, 4, 2, 2, 2, 2, 2, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 0, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 0, 9, 9], [8, 8, 4, 4, 8, 8, 8, 8, 8, 9, 9], [8, 8, 4, 4, 8, 8, 8, 8, 8, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 0, 9, 9], [7, 7, 4, 4, 7, 7, 7, 7, 7, 9, 9], [0, 0, 4, 4, 0, 0, 0, 0, 0, 9, 9]], ""output"": [[4]]}, {""input"": [[7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 2, 6, 6, 2, 2, 2, 5, 5, 2], [7, 7, 2, 6, 6, 2, 2, 2, 5, 5, 2], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 0, 6, 6, 0, 0, 0, 5, 5, 0], [7, 7, 8, 6, 6, 8, 8, 8, 5, 5, 8]], ""output"": [[5]]}, {""input"": [[0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 2, 4, 4, 4, 4, 6, 6, 4, 4], [4, 4, 2, 4, 4, 4, 4, 6, 6, 4, 4], [0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 6, 6, 0, 0], [8, 8, 2, 8, 8, 8, 8, 6, 6, 8, 8], [8, 8, 2, 8, 8, 8, 8, 6, 6, 8, 8]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [7, 8, 7, 7, 7, 1, 1, 7, 7, 2, 2], [7, 8, 7, 7, 7, 1, 1, 7, 7, 2, 2], [0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [0, 8, 0, 0, 0, 1, 1, 0, 0, 2, 2], [9, 8, 9, 9, 9, 1, 1, 9, 9, 2, 2], [9, 8, 9, 9, 9, 1, 1, 9, 9, 2, 2]], ""output"": [[8]]}]}"
3GMar8WJ95gT7vYwHNSv2T,2025-07-21T15:52:23.396936,task1a2e2828,"[""Input grids are of size 10 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 2], [2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 2], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0]], ""output"": [[9]]}, {""input"": [[5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [5, 5, 5, 6, 6, 9, 9, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8], [5, 5, 5, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8], [5, 5, 5, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 1, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1]], ""output"": [[4]]}, {""input"": [[4, 4, 4, 2, 2, 2, 6, 6, 6, 2, 2, 2, 8, 8, 2, 2, 2], [4, 4, 4, 2, 2, 2, 6, 6, 6, 2, 2, 2, 8, 8, 2, 2, 2], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 7, 7, 7, 6, 6, 6, 7, 7, 7, 8, 8, 7, 7, 7], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0], [4, 4, 4, 0, 0, 0, 6, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0]], ""output"": [[8]]}], ""test"": [{""input"": [[5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 6, 6, 3, 3, 3], [5, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 6, 6, 3, 3, 3], [5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 6, 6, 0, 0, 0], [5, 9, 9, 9, 9, 9, 4, 4, 4, 9, 9, 9, 6, 6, 9, 9, 9], [5, 9, 9, 9, 9, 9, 4, 4, 4, 9, 9, 9, 6, 6, 9, 9, 9]], ""output"": [[5]]}]}"
eMAnPkJyupCWFMxCZtrLzv,2025-07-21T15:52:23.400254,task1a2e2828,"[""Input grids are of size 14 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 9, 7, 7, 7, 9, 9, 9, 9, 9, 2, 2], [8, 8, 8, 9, 7, 7, 7, 9, 9, 9, 9, 9, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 4, 7, 7, 7, 4, 4, 4, 4, 4, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2], [8, 8, 8, 0, 7, 7, 7, 0, 0, 0, 0, 0, 2, 2]], ""output"": [[2]]}, {""input"": [[0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [2, 2, 4, 4, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2], [2, 2, 4, 4, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [6, 6, 4, 4, 6, 6, 6, 6, 6, 3, 3, 3, 6, 6], [6, 6, 4, 4, 6, 6, 6, 6, 6, 3, 3, 3, 6, 6], [6, 6, 4, 4, 6, 6, 6, 6, 6, 3, 3, 3, 6, 6], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [5, 5, 4, 4, 5, 5, 5, 5, 5, 3, 3, 3, 5, 5], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0]], ""output"": [[4]]}, {""input"": [[7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 9, 9, 6, 6], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[7]]}, {""input"": [[8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 9, 9, 8, 8], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 9, 9, 8, 8], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 9, 9, 8, 8], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 9, 9, 5, 5], [5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 9, 9, 5, 5], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 9, 9, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[2, 9, 9, 2, 2, 2, 2, 2, 5, 5, 5, 2, 2, 2], [2, 9, 9, 2, 2, 2, 2, 2, 5, 5, 5, 2, 2, 2], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [1, 9, 9, 1, 1, 1, 1, 1, 5, 5, 5, 1, 1, 1], [1, 9, 9, 1, 1, 1, 1, 1, 5, 5, 5, 1, 1, 1], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [3, 9, 9, 3, 3, 3, 3, 3, 5, 5, 5, 3, 3, 3]], ""output"": [[9]]}]}"
Ybaj2kKamb4QwzJ4azBKSA,2025-07-21T15:52:23.403177,task1a2e2828,"[""Input grids are of size 10 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2], [4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2]], ""output"": [[2]]}, {""input"": [[4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 9, 9, 1, 1, 9, 9, 9, 9, 9, 8, 8, 8], [4, 4, 4, 9, 9, 1, 1, 9, 9, 9, 9, 9, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8], [4, 4, 4, 2, 2, 1, 1, 2, 2, 2, 2, 2, 8, 8, 8]], ""output"": [[1]]}, {""input"": [[4, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4], [4, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4], [4, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [9, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 6, 9, 9, 9], [9, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 6, 9, 9, 9], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0]], ""output"": [[6]]}, {""input"": [[9, 9, 9, 3, 3, 3, 3, 2, 2, 3, 3, 3, 5, 5, 5], [9, 9, 9, 3, 3, 3, 3, 2, 2, 3, 3, 3, 5, 5, 5], [9, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 5, 5, 5], [9, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 5, 5, 5], [9, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 5, 5, 5], [9, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 5, 5, 5], [9, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 5, 5, 5], [9, 9, 9, 4, 4, 4, 4, 2, 2, 4, 4, 4, 5, 5, 5], [9, 9, 9, 4, 4, 4, 4, 2, 2, 4, 4, 4, 5, 5, 5], [9, 9, 9, 4, 4, 4, 4, 2, 2, 4, 4, 4, 5, 5, 5]], ""output"": [[2]]}], ""test"": [{""input"": [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 6, 6], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 6, 6], [3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 6, 6]], ""output"": [[4]]}]}"
YMdS4Ah3iMBYnpcL3mx3TJ,2025-07-21T15:52:23.406533,task1a2e2828,"[""Input grids are of size 12 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [6, 6, 2, 2, 2, 6, 6, 6, 6, 6, 6, 5, 5], [6, 6, 2, 2, 2, 6, 6, 6, 6, 6, 6, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 5, 5], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}, {""input"": [[9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 3, 3, 9], [9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 3, 3, 9], [9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 3, 3, 9], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 3, 3, 5], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 3, 3, 0], [8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 3, 3, 8], [8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 3, 3, 8]], ""output"": [[1]]}, {""input"": [[7, 7, 9, 9, 7, 7, 7, 7, 5, 5, 7, 2, 2], [7, 7, 9, 9, 7, 7, 7, 7, 5, 5, 7, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [6, 6, 9, 9, 6, 6, 6, 6, 5, 5, 6, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 5, 5, 0, 2, 2], [1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 1, 2, 2], [1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 1, 2, 2], [1, 1, 9, 9, 1, 1, 1, 1, 5, 5, 1, 2, 2]], ""output"": [[2]]}, {""input"": [[5, 5, 5, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3], [5, 5, 5, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3], [5, 5, 5, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1], [5, 5, 5, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [5, 5, 5, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7]], ""output"": [[6]]}, {""input"": [[5, 5, 1, 1, 1, 1, 8, 8, 1, 1, 1, 9, 9], [5, 5, 1, 1, 1, 1, 8, 8, 1, 1, 1, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 3, 3, 3, 3, 8, 8, 3, 3, 3, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9], [5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9]], ""output"": [[5]]}], ""test"": [{""input"": [[4, 4, 3, 3, 3, 4, 4, 4, 7, 7, 4, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [6, 6, 3, 3, 3, 6, 6, 6, 7, 7, 6, 8, 8], [6, 6, 3, 3, 3, 6, 6, 6, 7, 7, 6, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8], [0, 0, 3, 3, 3, 0, 0, 0, 7, 7, 0, 8, 8]], ""output"": [[7]]}]}"
5DayVMdcx8cbYKse3UV6t4,2025-07-21T15:52:23.410161,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 1, 1, 1, 5, 5, 1, 1, 1, 8, 8, 1], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 2, 2, 2, 5, 5, 2, 2, 2, 8, 8, 2], [4, 4, 4, 2, 2, 2, 5, 5, 2, 2, 2, 8, 8, 2], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 8, 8, 0], [4, 4, 4, 7, 7, 7, 5, 5, 7, 7, 7, 8, 8, 7], [4, 4, 4, 7, 7, 7, 5, 5, 7, 7, 7, 8, 8, 7]], ""output"": [[5]]}, {""input"": [[1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 5, 5, 5], [1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5], [3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 5, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 5, 5, 5]], ""output"": [[8]]}, {""input"": [[2, 2, 5, 5, 2, 2, 8, 8, 8, 2, 4, 2, 2, 2], [2, 2, 5, 5, 2, 2, 8, 8, 8, 2, 4, 2, 2, 2], [2, 2, 5, 5, 2, 2, 8, 8, 8, 2, 4, 2, 2, 2], [0, 0, 5, 5, 0, 0, 8, 8, 8, 0, 4, 0, 0, 0], [0, 0, 5, 5, 0, 0, 8, 8, 8, 0, 4, 0, 0, 0], [3, 3, 5, 5, 3, 3, 8, 8, 8, 3, 4, 3, 3, 3], [3, 3, 5, 5, 3, 3, 8, 8, 8, 3, 4, 3, 3, 3], [0, 0, 5, 5, 0, 0, 8, 8, 8, 0, 4, 0, 0, 0], [0, 0, 5, 5, 0, 0, 8, 8, 8, 0, 4, 0, 0, 0], [0, 0, 5, 5, 0, 0, 8, 8, 8, 0, 4, 0, 0, 0], [7, 7, 5, 5, 7, 7, 8, 8, 8, 7, 4, 7, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 8, 7, 4, 7, 7, 7]], ""output"": [[4]]}, {""input"": [[0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 1, 1, 9], [9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 1, 1, 9], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [2, 2, 8, 8, 8, 2, 2, 2, 2, 2, 2, 1, 1, 2], [2, 2, 8, 8, 8, 2, 2, 2, 2, 2, 2, 1, 1, 2], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 1, 1, 3]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [1, 1, 1, 5, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1], [1, 1, 1, 5, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [9, 9, 9, 5, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9], [9, 9, 9, 5, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9], [9, 9, 9, 5, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9], [0, 0, 0, 5, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0]], ""output"": [[5]]}], ""test"": [{""input"": [[3, 3, 3, 9, 9, 3, 3, 3, 3, 1, 1, 3, 3, 7], [3, 3, 3, 9, 9, 3, 3, 3, 3, 1, 1, 3, 3, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [6, 6, 6, 9, 9, 6, 6, 6, 6, 1, 1, 6, 6, 7], [6, 6, 6, 9, 9, 6, 6, 6, 6, 1, 1, 6, 6, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 7]], ""output"": [[7]]}]}"
dMqbN9DFicFKF6M8G9CAUS,2025-07-21T15:52:23.413306,task1a2e2828,"[""Input grids are of size 15 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [7, 7, 5, 5, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 6, 5, 5, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6], [6, 6, 5, 5, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [3, 3, 5, 5, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3], [3, 3, 5, 5, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3]], ""output"": [[5]]}, {""input"": [[0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 4, 5, 5, 5, 4, 4, 4, 4, 2, 2, 4, 4, 4], [4, 4, 5, 5, 5, 4, 4, 4, 4, 2, 2, 4, 4, 4], [4, 4, 5, 5, 5, 4, 4, 4, 4, 2, 2, 4, 4, 4], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [6, 6, 5, 5, 5, 6, 6, 6, 6, 2, 2, 6, 6, 6], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0], [3, 3, 5, 5, 5, 3, 3, 3, 3, 2, 2, 3, 3, 3], [3, 3, 5, 5, 5, 3, 3, 3, 3, 2, 2, 3, 3, 3], [0, 0, 5, 5, 5, 0, 0, 0, 0, 2, 2, 0, 0, 0]], ""output"": [[2]]}, {""input"": [[1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1, 1, 5, 5], [1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1, 1, 5, 5], [1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1, 1, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [3, 3, 4, 4, 3, 3, 3, 7, 7, 3, 3, 3, 5, 5], [3, 3, 4, 4, 3, 3, 3, 7, 7, 3, 3, 3, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 5, 5], [6, 6, 4, 4, 6, 6, 6, 7, 7, 6, 6, 6, 5, 5]], ""output"": [[4]]}], ""test"": [{""input"": [[3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 9, 9], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2], [3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0]], ""output"": [[3]]}]}"
FYqC2T5dG24M5u3kfMiuUM,2025-07-21T15:52:23.416517,task1a2e2828,"[""Input grids are of size 10 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 10, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 1, 1, 6, 6, 6, 6, 6, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7], [8, 8, 1, 1, 8, 8, 8, 8, 8, 7, 7], [8, 8, 1, 1, 8, 8, 8, 8, 8, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7]], ""output"": [[1]]}, {""input"": [[7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 9, 8, 8, 9, 9, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 3, 8, 8, 3, 3, 5, 5, 5], [7, 7, 7, 3, 8, 8, 3, 3, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5], [7, 7, 7, 0, 8, 8, 0, 0, 5, 5, 5]], ""output"": [[8]]}, {""input"": [[3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 5, 5, 5, 5, 5, 9, 9, 5, 5], [3, 3, 5, 5, 5, 5, 5, 9, 9, 5, 5], [3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 1, 1, 1, 1, 1, 9, 9, 1, 1], [3, 3, 1, 1, 1, 1, 1, 9, 9, 1, 1]], ""output"": [[3]]}], ""test"": [{""input"": [[6, 6, 6, 5, 5, 6, 6, 6, 6, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [8, 8, 8, 5, 5, 8, 8, 8, 8, 9, 9], [8, 8, 8, 5, 5, 8, 8, 8, 8, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 9, 9]], ""output"": [[5]]}]}"
SaFeC8m9xnAgVNvtJLTsLP,2025-07-21T15:52:23.419237,task1a2e2828,"[""Input grids are of size 14 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8], [1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8], [1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8], [1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8]], ""output"": [[1]]}, {""input"": [[8, 8, 8, 9, 9, 9, 8, 8, 8, 8, 8, 8, 6, 6], [8, 8, 8, 9, 9, 9, 8, 8, 8, 8, 8, 8, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 6, 6], [1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[6]]}, {""input"": [[9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4], [9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4], [9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4], [9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4]], ""output"": [[9]]}], ""test"": [{""input"": [[7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 2, 2, 2, 5, 5, 2, 2, 2, 2, 1, 1, 2, 2], [7, 2, 2, 2, 5, 5, 2, 2, 2, 2, 1, 1, 2, 2], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0], [7, 9, 9, 9, 5, 5, 9, 9, 9, 9, 1, 1, 9, 9], [7, 9, 9, 9, 5, 5, 9, 9, 9, 9, 1, 1, 9, 9], [7, 9, 9, 9, 5, 5, 9, 9, 9, 9, 1, 1, 9, 9], [7, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 1, 0, 0]], ""output"": [[7]]}]}"
ZGg7oRAZCWHndCdbbaNxAy,2025-07-21T15:52:23.422316,task1a2e2828,"[""Input grids are of size 15 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 3, 5, 5, 3, 3, 9, 9, 3], [1, 1, 1, 3, 5, 5, 3, 3, 9, 9, 3], [1, 1, 1, 3, 5, 5, 3, 3, 9, 9, 3], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 2, 5, 5, 2, 2, 9, 9, 2], [1, 1, 1, 2, 5, 5, 2, 2, 9, 9, 2], [1, 1, 1, 0, 5, 5, 0, 0, 9, 9, 0], [1, 1, 1, 7, 5, 5, 7, 7, 9, 9, 7]], ""output"": [[5]]}, {""input"": [[7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 8, 8, 8, 9, 9, 8, 8, 8, 8], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 2, 2, 2, 9, 9, 2, 2, 2, 2], [7, 7, 2, 2, 2, 9, 9, 2, 2, 2, 2], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 6, 6, 6, 9, 9, 6, 6, 6, 6], [7, 7, 6, 6, 6, 9, 9, 6, 6, 6, 6]], ""output"": [[7]]}, {""input"": [[0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 7], [1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 7], [3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 7]], ""output"": [[7]]}, {""input"": [[8, 8, 7, 7, 7, 1, 1, 7, 7, 7, 7], [8, 8, 7, 7, 7, 1, 1, 7, 7, 7, 7], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0], [8, 8, 9, 9, 9, 1, 1, 9, 9, 9, 9], [8, 8, 0, 0, 0, 1, 1, 0, 0, 0, 0]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [1, 1, 8, 8, 1, 1, 1, 1, 7, 7, 7], [1, 1, 8, 8, 1, 1, 1, 1, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [6, 6, 8, 8, 6, 6, 6, 6, 7, 7, 7], [6, 6, 8, 8, 6, 6, 6, 6, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7], [5, 5, 8, 8, 5, 5, 5, 5, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 7, 7, 7]], ""output"": [[8]]}]}"
BPPsNrfre652Bky7h34YXL,2025-07-21T15:52:23.426603,task1a2e2828,"[""Input grids are of size 16 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 16, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 6, 6, 1, 1, 1, 1, 7, 7, 7], [1, 6, 6, 1, 1, 1, 1, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [9, 6, 6, 9, 9, 9, 9, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7], [0, 6, 6, 0, 0, 0, 0, 7, 7, 7]], ""output"": [[6]]}, {""input"": [[6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 1, 4, 4, 1, 1, 2, 2], [6, 6, 6, 1, 4, 4, 1, 1, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 5, 4, 4, 5, 5, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 0, 4, 4, 0, 0, 2, 2], [6, 6, 6, 9, 4, 4, 9, 9, 2, 2], [6, 6, 6, 9, 4, 4, 9, 9, 2, 2]], ""output"": [[2]]}, {""input"": [[3, 3, 4, 4, 4, 6, 6, 4, 8, 8], [3, 3, 4, 4, 4, 6, 6, 4, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 2, 2, 2, 6, 6, 2, 8, 8], [3, 3, 2, 2, 2, 6, 6, 2, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 1, 1, 1, 6, 6, 1, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8], [3, 3, 0, 0, 0, 6, 6, 0, 8, 8]], ""output"": [[3]]}], ""test"": [{""input"": [[3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 1, 1, 8, 8, 1, 1, 5, 5], [3, 3, 1, 1, 8, 8, 1, 1, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 9, 9, 8, 8, 9, 9, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5], [3, 3, 0, 0, 8, 8, 0, 0, 5, 5]], ""output"": [[3]]}]}"
BnCqzpmtWuyeisHdwhgos8,2025-07-21T15:52:23.432110,task1a2e2828,"[""Input grids are of size 14 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [2, 3, 3, 2, 2, 2, 2, 2, 8, 8, 2, 2, 2, 2, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [5, 3, 3, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5, 7, 7], [5, 3, 3, 5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 7, 7], [4, 3, 3, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 7, 7], [4, 3, 3, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 7, 7], [4, 3, 3, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 7, 7]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [8, 8, 8, 8, 8, 1, 1, 1, 8, 8, 8, 8, 8, 9, 9, 8], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [7, 7, 7, 7, 7, 1, 1, 1, 7, 7, 7, 7, 7, 9, 9, 7], [7, 7, 7, 7, 7, 1, 1, 1, 7, 7, 7, 7, 7, 9, 9, 7], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 9, 9, 0], [4, 4, 4, 4, 4, 1, 1, 1, 4, 4, 4, 4, 4, 9, 9, 4], [4, 4, 4, 4, 4, 1, 1, 1, 4, 4, 4, 4, 4, 9, 9, 4]], ""output"": [[9]]}, {""input"": [[4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 3, 3, 3], [4, 4, 5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 6, 6, 6, 6, 6, 9, 9, 6, 6, 6, 6, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 8], [7, 7, 7, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 8], [2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 8], [2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 8], [2, 2, 2, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 8]], ""output"": [[8]]}, {""input"": [[0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [2, 2, 5, 5, 2, 2, 2, 3, 3, 2, 2, 2, 6, 2, 2, 2], [2, 2, 5, 5, 2, 2, 2, 3, 3, 2, 2, 2, 6, 2, 2, 2], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [1, 1, 5, 5, 1, 1, 1, 3, 3, 1, 1, 1, 6, 1, 1, 1], [1, 1, 5, 5, 1, 1, 1, 3, 3, 1, 1, 1, 6, 1, 1, 1], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0], [7, 7, 5, 5, 7, 7, 7, 3, 3, 7, 7, 7, 6, 7, 7, 7], [7, 7, 5, 5, 7, 7, 7, 3, 3, 7, 7, 7, 6, 7, 7, 7], [0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 0, 0, 6, 0, 0, 0]], ""output"": [[6]]}], ""test"": [{""input"": [[9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 7, 7], [9, 9, 9, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 7, 7]], ""output"": [[3]]}]}"
foBqTTdEdN2ymCoFFgZNzM,2025-07-21T15:52:23.436668,task1a2e2828,"[""Input grids are of size 18 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 9, 2, 2, 2, 5, 5, 2, 2, 2], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 3, 3, 3, 5, 5, 3, 3, 3], [9, 9, 9, 3, 3, 3, 5, 5, 3, 3, 3], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0], [9, 9, 9, 0, 0, 0, 5, 5, 0, 0, 0]], ""output"": [[5]]}, {""input"": [[8, 8, 6, 6, 6, 6, 6, 5, 5, 6, 9], [8, 8, 6, 6, 6, 6, 6, 5, 5, 6, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 2, 2, 2, 2, 2, 5, 5, 2, 9], [8, 8, 2, 2, 2, 2, 2, 5, 5, 2, 9], [8, 8, 2, 2, 2, 2, 2, 5, 5, 2, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 3, 3, 3, 3, 3, 5, 5, 3, 9], [8, 8, 3, 3, 3, 3, 3, 5, 5, 3, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9], [8, 8, 0, 0, 0, 0, 0, 5, 5, 0, 9]], ""output"": [[9]]}, {""input"": [[9, 4, 4, 9, 9, 9, 6, 6, 9, 9, 7], [9, 4, 4, 9, 9, 9, 6, 6, 9, 9, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [1, 4, 4, 1, 1, 1, 6, 6, 1, 1, 7], [1, 4, 4, 1, 1, 1, 6, 6, 1, 1, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [5, 4, 4, 5, 5, 5, 6, 6, 5, 5, 7], [5, 4, 4, 5, 5, 5, 6, 6, 5, 5, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7], [0, 4, 4, 0, 0, 0, 6, 6, 0, 0, 7]], ""output"": [[7]]}], ""test"": [{""input"": [[5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 9, 9, 9, 8, 8, 9, 9, 9, 9], [5, 5, 9, 9, 9, 8, 8, 9, 9, 9, 9], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 6, 6, 6, 8, 8, 6, 6, 6, 6], [5, 5, 6, 6, 6, 8, 8, 6, 6, 6, 6], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 0, 0, 0, 8, 8, 0, 0, 0, 0], [5, 5, 4, 4, 4, 8, 8, 4, 4, 4, 4]], ""output"": [[5]]}]}"
FgxsK3PRGtcn8eJjnW5FJd,2025-07-21T15:52:23.440550,task1a2e2828,"[""Input grids are of size 16 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 16, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [1, 1, 1, 7, 7, 1, 1, 1, 2, 2, 1, 1, 4, 4], [1, 1, 1, 7, 7, 1, 1, 1, 2, 2, 1, 1, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [3, 3, 3, 7, 7, 3, 3, 3, 2, 2, 3, 3, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 0, 7, 7, 0, 0, 0, 2, 2, 0, 0, 4, 4]], ""output"": [[2]]}, {""input"": [[5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 6, 6, 6], [5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 8, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6, 6]], ""output"": [[1]]}, {""input"": [[1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 5, 5, 7, 7, 5, 5, 8, 8, 5, 5, 5, 5], [1, 1, 5, 5, 7, 7, 5, 5, 8, 8, 5, 5, 5, 5], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 3, 3, 7, 7, 3, 3, 8, 8, 3, 3, 3, 3], [1, 1, 3, 3, 7, 7, 3, 3, 8, 8, 3, 3, 3, 3], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0], [1, 1, 4, 4, 7, 7, 4, 4, 8, 8, 4, 4, 4, 4], [1, 1, 0, 0, 7, 7, 0, 0, 8, 8, 0, 0, 0, 0]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [1, 1, 4, 4, 4, 1, 1, 1, 5, 5, 1, 1, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [2, 2, 4, 4, 4, 2, 2, 2, 5, 5, 2, 2, 9, 9], [2, 2, 4, 4, 4, 2, 2, 2, 5, 5, 2, 2, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9], [0, 0, 4, 4, 4, 0, 0, 0, 5, 5, 0, 0, 9, 9]], ""output"": [[5]]}]}"
NeQCVSHRagKSj3s657JhJJ,2025-07-21T15:52:23.444052,task1a2e2828,"[""Input grids are of size 15 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8], [4, 4, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 6, 6, 6, 6, 6, 6, 6, 1, 1, 6, 6, 6], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [4, 4, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3], [4, 4, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 7, 7, 4], [4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 7, 7, 4], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0], [3, 3, 3, 3, 9, 9, 9, 3, 3, 3, 3, 7, 7, 3], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 7, 7, 0]], ""output"": [[7]]}, {""input"": [[0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [7, 7, 8, 8, 7, 7, 7, 1, 1, 1, 7, 5, 5, 5], [7, 7, 8, 8, 7, 7, 7, 1, 1, 1, 7, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5], [2, 2, 8, 8, 2, 2, 2, 1, 1, 1, 2, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 1, 1, 1, 0, 5, 5, 5]], ""output"": [[8]]}, {""input"": [[0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [2, 2, 2, 2, 2, 8, 8, 2, 2, 2, 2, 3, 3, 3], [2, 2, 2, 2, 2, 8, 8, 2, 2, 2, 2, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [5, 5, 5, 5, 5, 8, 8, 5, 5, 5, 5, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 3, 3, 3]], ""output"": [[8]]}, {""input"": [[3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6], [3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6], [3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2], [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 5, 5, 5, 5, 6, 6, 6, 5, 5, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 1, 1, 1, 1, 6, 6, 6, 1, 1, 3, 3, 3], [8, 8, 1, 1, 1, 1, 6, 6, 6, 1, 1, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 6, 6, 6, 0, 0, 3, 3, 3]], ""output"": [[8]]}]}"
QNQyoVxEPjLfaDsW9GVFjg,2025-07-21T15:52:23.447872,task1a2e2828,"[""Input grids are of size 17 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 7, 7, 7, 7, 2, 2, 7, 7, 7], [4, 7, 7, 7, 7, 2, 2, 7, 7, 7], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 0, 0, 0, 0, 2, 2, 0, 0, 0], [4, 3, 3, 3, 3, 2, 2, 3, 3, 3], [4, 3, 3, 3, 3, 2, 2, 3, 3, 3]], ""output"": [[4]]}, {""input"": [[5, 5, 2, 4, 4, 2, 1, 1, 2, 2], [5, 5, 2, 4, 4, 2, 1, 1, 2, 2], [5, 5, 2, 4, 4, 2, 1, 1, 2, 2], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 7, 4, 4, 7, 1, 1, 7, 7], [5, 5, 7, 4, 4, 7, 1, 1, 7, 7], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 6, 4, 4, 6, 1, 1, 6, 6], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0], [5, 5, 0, 4, 4, 0, 1, 1, 0, 0]], ""output"": [[1]]}, {""input"": [[0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [6, 1, 1, 6, 6, 6, 6, 3, 3, 6], [6, 1, 1, 6, 6, 6, 6, 3, 3, 6], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [9, 1, 1, 9, 9, 9, 9, 3, 3, 9], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [4, 1, 1, 4, 4, 4, 4, 3, 3, 4], [4, 1, 1, 4, 4, 4, 4, 3, 3, 4], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0], [0, 1, 1, 0, 0, 0, 0, 3, 3, 0]], ""output"": [[1]]}], ""test"": [{""input"": [[2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 4, 4, 6, 6, 4, 4, 8, 8], [2, 2, 4, 4, 6, 6, 4, 4, 8, 8], [2, 2, 4, 4, 6, 6, 4, 4, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 3, 3, 6, 6, 3, 3, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 1, 1, 6, 6, 1, 1, 8, 8], [2, 2, 1, 1, 6, 6, 1, 1, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8], [2, 2, 0, 0, 6, 6, 0, 0, 8, 8]], ""output"": [[2]]}]}"
YvSvDE9aXE3zWqHrDYQWmW,2025-07-21T15:52:23.451027,task1a2e2828,"[""Input grids are of size 18 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [9, 9, 9, 3, 3, 9, 9, 9, 2, 2], [9, 9, 9, 3, 3, 9, 9, 9, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [8, 8, 8, 3, 3, 8, 8, 8, 2, 2], [8, 8, 8, 3, 3, 8, 8, 8, 2, 2], [8, 8, 8, 3, 3, 8, 8, 8, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [4, 4, 4, 3, 3, 4, 4, 4, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2], [0, 0, 0, 3, 3, 0, 0, 0, 2, 2]], ""output"": [[2]]}, {""input"": [[8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 2, 2, 2, 2, 6, 6, 2, 2, 2], [8, 2, 2, 2, 2, 6, 6, 2, 2, 2], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 1, 1, 1, 1, 6, 6, 1, 1, 1], [8, 1, 1, 1, 1, 6, 6, 1, 1, 1], [8, 0, 0, 0, 0, 6, 6, 0, 0, 0]], ""output"": [[8]]}, {""input"": [[8, 8, 9, 9, 8, 8, 8, 8, 6, 6], [8, 8, 9, 9, 8, 8, 8, 8, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [5, 5, 9, 9, 5, 5, 5, 5, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6], [1, 1, 9, 9, 1, 1, 1, 1, 6, 6], [1, 1, 9, 9, 1, 1, 1, 1, 6, 6], [0, 0, 9, 9, 0, 0, 0, 0, 6, 6]], ""output"": [[6]]}], ""test"": [{""input"": [[7, 7, 1, 7, 7, 7, 7, 5, 5, 7], [7, 7, 1, 7, 7, 7, 7, 5, 5, 7], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [2, 2, 1, 2, 2, 2, 2, 5, 5, 2], [2, 2, 1, 2, 2, 2, 2, 5, 5, 2], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0], [0, 0, 1, 0, 0, 0, 0, 5, 5, 0]], ""output"": [[1]]}]}"
GjX3zHrAoVQTKWrdUWjq4u,2025-07-21T15:52:23.454465,task1a2e2828,"[""Input grids are of size 13 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 7, 7, 7, 7, 7, 7, 7, 5, 5, 7], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3], [4, 4, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0]], ""output"": [[4]]}, {""input"": [[9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8], [9, 9, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [9, 9, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8]], ""output"": [[9]]}, {""input"": [[7, 7, 1, 1, 1, 7, 7, 7, 3, 3, 7, 7], [7, 7, 1, 1, 1, 7, 7, 7, 3, 3, 7, 7], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [8, 8, 1, 1, 1, 8, 8, 8, 3, 3, 8, 8], [8, 8, 1, 1, 1, 8, 8, 8, 3, 3, 8, 8], [8, 8, 1, 1, 1, 8, 8, 8, 3, 3, 8, 8], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [5, 5, 1, 1, 1, 5, 5, 5, 3, 3, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 3, 3, 0, 0]], ""output"": [[3]]}, {""input"": [[7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 4, 4, 6, 6, 4, 4, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 0, 0, 6, 6, 0, 0, 8, 8, 8], [7, 7, 7, 3, 3, 6, 6, 3, 3, 8, 8, 8], [7, 7, 7, 3, 3, 6, 6, 3, 3, 8, 8, 8]], ""output"": [[6]]}], ""test"": [{""input"": [[0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [3, 3, 2, 2, 3, 3, 3, 3, 3, 8, 8, 3], [3, 3, 2, 2, 3, 3, 3, 3, 3, 8, 8, 3], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [7, 7, 2, 2, 7, 7, 7, 7, 7, 8, 8, 7], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0]], ""output"": [[2]]}]}"
XvzQWViaSdTbyVZPQNLfdj,2025-07-21T15:52:23.459507,task1a2e2828,"[""Input grids are of size 12 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6], [4, 4, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[1, 1, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 9], [1, 1, 9, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 9], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [1, 1, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6], [1, 1, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6]], ""output"": [[1]]}, {""input"": [[7, 7, 7, 9, 9, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 9], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1], [7, 7, 7, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3], [7, 7, 7, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[1, 1, 1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 4, 4, 1], [1, 1, 1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 4, 4, 1], [1, 1, 1, 1, 1, 9, 9, 9, 1, 1, 1, 1, 1, 1, 4, 4, 1], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7, 7, 4, 4, 7], [7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7, 7, 4, 4, 7], [0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0], [5, 5, 5, 5, 5, 9, 9, 9, 5, 5, 5, 5, 5, 5, 4, 4, 5]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8], [8, 8, 8, 8, 2, 2, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7], [4, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 1, 1, 7], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8], [4, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [4, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]], ""output"": [[4]]}]}"
QyrcNxDGuKybR6rXxJHkiH,2025-07-21T15:52:23.463056,task1a2e2828,"[""Input grids are of size 14 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 3, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6], [3, 3, 3, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4], [3, 3, 3, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [3, 3, 3, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7], [3, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0]], ""output"": [[8]]}, {""input"": [[7, 3, 3, 3, 7, 7, 7, 7, 7, 8, 8, 7, 4], [7, 3, 3, 3, 7, 7, 7, 7, 7, 8, 8, 7, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [6, 3, 3, 3, 6, 6, 6, 6, 6, 8, 8, 6, 4], [6, 3, 3, 3, 6, 6, 6, 6, 6, 8, 8, 6, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4], [0, 3, 3, 3, 0, 0, 0, 0, 0, 8, 8, 0, 4]], ""output"": [[4]]}, {""input"": [[5, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7], [5, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7], [6, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7]], ""output"": [[3]]}, {""input"": [[7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1], [7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1], [7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1], [7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1]], ""output"": [[1]]}, {""input"": [[4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 5, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8], [4, 4, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0]], ""output"": [[4]]}], ""test"": [{""input"": [[9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 6, 5, 5, 6, 6, 6, 6, 1, 1, 1], [9, 9, 9, 6, 5, 5, 6, 6, 6, 6, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1], [9, 9, 9, 8, 5, 5, 8, 8, 8, 8, 1, 1, 1], [9, 9, 9, 0, 5, 5, 0, 0, 0, 0, 1, 1, 1]], ""output"": [[5]]}]}"
hiidKcjtGeZLgZ22FmX9FM,2025-07-21T15:52:23.466333,task1a2e2828,"[""Input grids are of size 14 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 2, 2, 2, 2, 9, 9, 2, 2, 1, 1, 1], [8, 2, 2, 2, 2, 9, 9, 2, 2, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1], [8, 5, 5, 5, 5, 9, 9, 5, 5, 1, 1, 1], [8, 5, 5, 5, 5, 9, 9, 5, 5, 1, 1, 1], [8, 0, 0, 0, 0, 9, 9, 0, 0, 1, 1, 1]], ""output"": [[8]]}, {""input"": [[0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [1, 3, 3, 1, 1, 1, 1, 1, 2, 2, 1, 8], [1, 3, 3, 1, 1, 1, 1, 1, 2, 2, 1, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [0, 3, 3, 0, 0, 0, 0, 0, 2, 2, 0, 8], [5, 3, 3, 5, 5, 5, 5, 5, 2, 2, 5, 8], [5, 3, 3, 5, 5, 5, 5, 5, 2, 2, 5, 8], [5, 3, 3, 5, 5, 5, 5, 5, 2, 2, 5, 8]], ""output"": [[8]]}, {""input"": [[1, 1, 1, 5, 5, 8, 8, 5, 5, 5, 5, 5], [1, 1, 1, 5, 5, 8, 8, 5, 5, 5, 5, 5], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 4, 4, 8, 8, 4, 4, 4, 4, 4], [1, 1, 1, 4, 4, 8, 8, 4, 4, 4, 4, 4], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 2, 2, 8, 8, 2, 2, 2, 2, 2], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 8, 8, 0, 0, 0, 0, 0]], ""output"": [[8]]}, {""input"": [[2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 9, 9, 9, 9, 4, 4, 9, 9, 9, 9], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3], [2, 2, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [2, 2, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5], [2, 2, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5], [2, 2, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[2, 2, 2, 3, 3, 2, 2, 2, 2, 8, 8, 2], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [9, 9, 9, 3, 3, 9, 9, 9, 9, 8, 8, 9], [9, 9, 9, 3, 3, 9, 9, 9, 9, 8, 8, 9], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 8, 8, 0]], ""output"": [[3]]}]}"
oBpjyutjsQMTf6b9MBktua,2025-07-21T15:52:23.469646,task1a2e2828,"[""Input grids are of size 11 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1], [1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1]], ""output"": [[6]]}, {""input"": [[0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 5, 5], [6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 5, 5], [6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 5, 5], [6, 6, 6, 6, 6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 5, 5], [9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 5, 5], [1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 5, 5], [1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 5, 5], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}, {""input"": [[3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 7, 3], [3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 7, 3], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0], [5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 7, 5], [5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 7, 5], [5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 7, 5], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 7, 0]], ""output"": [[7]]}, {""input"": [[0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [3, 9, 9, 9, 3, 3, 3, 1, 1, 1, 3, 3, 3, 7, 7, 3], [3, 9, 9, 9, 3, 3, 3, 1, 1, 1, 3, 3, 3, 7, 7, 3], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [0, 9, 9, 9, 0, 0, 0, 1, 1, 1, 0, 0, 0, 7, 7, 0], [8, 9, 9, 9, 8, 8, 8, 1, 1, 1, 8, 8, 8, 7, 7, 8]], ""output"": [[7]]}, {""input"": [[7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 5], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 4], [7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 4], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3], [7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3]], ""output"": [[7]]}], ""test"": [{""input"": [[3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 2, 2, 2, 2, 7, 7, 7, 2, 2, 2, 2, 8, 8, 2], [3, 3, 2, 2, 2, 2, 7, 7, 7, 2, 2, 2, 2, 8, 8, 2], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 5, 5, 5, 5, 7, 7, 7, 5, 5, 5, 5, 8, 8, 5], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 8, 8, 0]], ""output"": [[3]]}]}"
5N6sYABUvCr8xarKRrcjPg,2025-07-21T15:52:23.474272,task1a2e2828,"[""Input grids are of size 13 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [7, 7, 1, 1, 1, 7, 7, 7, 7, 5, 5], [7, 7, 1, 1, 1, 7, 7, 7, 7, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [3, 3, 1, 1, 1, 3, 3, 3, 3, 5, 5], [3, 3, 1, 1, 1, 3, 3, 3, 3, 5, 5], [3, 3, 1, 1, 1, 3, 3, 3, 3, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [2, 2, 1, 1, 1, 2, 2, 2, 2, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5], [0, 0, 1, 1, 1, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}, {""input"": [[7, 7, 1, 1, 1, 1, 3, 3, 1, 1, 1], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 4, 4, 4, 4, 3, 3, 4, 4, 4], [7, 7, 4, 4, 4, 4, 3, 3, 4, 4, 4], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 0, 0, 0], [7, 7, 2, 2, 2, 2, 3, 3, 2, 2, 2], [7, 7, 2, 2, 2, 2, 3, 3, 2, 2, 2], [7, 7, 2, 2, 2, 2, 3, 3, 2, 2, 2]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [8, 8, 8, 5, 5, 8, 8, 8, 9, 9, 9], [8, 8, 8, 5, 5, 8, 8, 8, 9, 9, 9], [8, 8, 8, 5, 5, 8, 8, 8, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [4, 4, 4, 5, 5, 4, 4, 4, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [7, 7, 7, 5, 5, 7, 7, 7, 9, 9, 9], [7, 7, 7, 5, 5, 7, 7, 7, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 9, 9, 9]], ""output"": [[5]]}], ""test"": [{""input"": [[5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 8, 8, 8, 8, 8, 8, 8, 3, 3], [5, 5, 8, 8, 8, 8, 8, 8, 8, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 6, 6, 6, 6, 6, 6, 6, 3, 3], [5, 5, 6, 6, 6, 6, 6, 6, 6, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3], [5, 5, 1, 1, 1, 1, 1, 1, 1, 3, 3]], ""output"": [[3]]}]}"
BDSXhNuyzAKnp6qMDAN4A9,2025-07-21T15:52:23.479813,task1a2e2828,"[""Input grids are of size 15 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[7, 7, 2, 2, 7, 7, 7, 9, 9, 7, 7], [7, 7, 2, 2, 7, 7, 7, 9, 9, 7, 7], [7, 7, 2, 2, 7, 7, 7, 9, 9, 7, 7], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [1, 1, 2, 2, 1, 1, 1, 9, 9, 1, 1], [1, 1, 2, 2, 1, 1, 1, 9, 9, 1, 1], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [0, 0, 2, 2, 0, 0, 0, 9, 9, 0, 0], [3, 3, 2, 2, 3, 3, 3, 9, 9, 3, 3]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [3, 3, 3, 6, 6, 3, 3, 3, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [0, 0, 0, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 7, 6, 6, 7, 7, 7, 5, 5, 5], [7, 7, 7, 6, 6, 7, 7, 7, 5, 5, 5]], ""output"": [[6]]}, {""input"": [[0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [9, 9, 3, 3, 9, 4, 9, 9, 1, 1, 9], [9, 9, 3, 3, 9, 4, 9, 9, 1, 1, 9], [9, 9, 3, 3, 9, 4, 9, 9, 1, 1, 9], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [0, 0, 3, 3, 0, 4, 0, 0, 1, 1, 0], [7, 7, 3, 3, 7, 4, 7, 7, 1, 1, 7], [7, 7, 3, 3, 7, 4, 7, 7, 1, 1, 7]], ""output"": [[4]]}], ""test"": [{""input"": [[5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 7, 7, 7, 7, 7, 4, 4, 7, 1, 1], [5, 7, 7, 7, 7, 7, 4, 4, 7, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 8, 8, 8, 8, 8, 4, 4, 8, 1, 1], [5, 8, 8, 8, 8, 8, 4, 4, 8, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1], [5, 0, 0, 0, 0, 0, 4, 4, 0, 1, 1]], ""output"": [[5]]}]}"
HQDBGz2ykUDntAf8dRnMC5,2025-07-21T15:52:23.484111,task1a2e2828,"[""Input grids are of size 15 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 9], [1, 1, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 9], [1, 1, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 9], [1, 1, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 9], [1, 1, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 9]], ""output"": [[9]]}, {""input"": [[9, 9, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 5, 5, 5], [9, 9, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 5, 5, 5], [9, 9, 6, 6, 6, 6, 6, 3, 3, 6, 6, 6, 6, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 5, 5, 5], [9, 9, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 5, 5, 5], [9, 9, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 5, 5, 5], [9, 9, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 5, 5, 5]], ""output"": [[3]]}, {""input"": [[8, 8, 2, 2, 2, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [6, 6, 2, 2, 2, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6], [6, 6, 2, 2, 2, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 9, 9, 2, 2], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 9, 9, 1, 1], [4, 4, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 9, 9, 1, 1], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0], [4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[4]]}, {""input"": [[5, 5, 8, 8, 5, 5, 5, 5, 5, 5, 3, 3, 3, 5, 5, 5], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 8, 8, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [7, 7, 8, 8, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 3, 3, 3, 9, 9, 9], [9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 3, 3, 3, 9, 9, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0]], ""output"": [[8]]}], ""test"": [{""input"": [[4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4], [4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 9], [9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 9]], ""output"": [[3]]}]}"
A3vfcEcHrWLbNkFCrH8WrT,2025-07-21T15:52:23.488343,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 3, 3, 3, 9, 9, 5, 5, 5, 9, 9, 7, 7, 9], [9, 3, 3, 3, 9, 9, 5, 5, 5, 9, 9, 7, 7, 9], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [6, 3, 3, 3, 6, 6, 5, 5, 5, 6, 6, 7, 7, 6], [6, 3, 3, 3, 6, 6, 5, 5, 5, 6, 6, 7, 7, 6], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [8, 3, 3, 3, 8, 8, 5, 5, 5, 8, 8, 7, 7, 8], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0], [0, 3, 3, 3, 0, 0, 5, 5, 5, 0, 0, 7, 7, 0]], ""output"": [[7]]}, {""input"": [[8, 8, 9, 9, 8, 8, 8, 3, 3, 3, 8, 8, 7, 8], [8, 8, 9, 9, 8, 8, 8, 3, 3, 3, 8, 8, 7, 8], [8, 8, 9, 9, 8, 8, 8, 3, 3, 3, 8, 8, 7, 8], [0, 0, 9, 9, 0, 0, 0, 3, 3, 3, 0, 0, 7, 0], [0, 0, 9, 9, 0, 0, 0, 3, 3, 3, 0, 0, 7, 0], [1, 1, 9, 9, 1, 1, 1, 3, 3, 3, 1, 1, 7, 1], [1, 1, 9, 9, 1, 1, 1, 3, 3, 3, 1, 1, 7, 1], [0, 0, 9, 9, 0, 0, 0, 3, 3, 3, 0, 0, 7, 0], [2, 2, 9, 9, 2, 2, 2, 3, 3, 3, 2, 2, 7, 2], [2, 2, 9, 9, 2, 2, 2, 3, 3, 3, 2, 2, 7, 2], [0, 0, 9, 9, 0, 0, 0, 3, 3, 3, 0, 0, 7, 0], [0, 0, 9, 9, 0, 0, 0, 3, 3, 3, 0, 0, 7, 0]], ""output"": [[7]]}, {""input"": [[7, 7, 2, 2, 2, 6, 6, 6, 2, 2, 2, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 9, 9, 9, 6, 6, 6, 9, 9, 9, 5, 5, 5], [7, 7, 9, 9, 9, 6, 6, 6, 9, 9, 9, 5, 5, 5], [7, 7, 9, 9, 9, 6, 6, 6, 9, 9, 9, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 8, 8, 8, 6, 6, 6, 8, 8, 8, 5, 5, 5], [7, 7, 8, 8, 8, 6, 6, 6, 8, 8, 8, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5], [7, 7, 0, 0, 0, 6, 6, 6, 0, 0, 0, 5, 5, 5]], ""output"": [[7]]}, {""input"": [[0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [5, 5, 5, 3, 3, 5, 5, 5, 5, 5, 1, 1, 1, 5], [5, 5, 5, 3, 3, 5, 5, 5, 5, 5, 1, 1, 1, 5], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 2], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0]], ""output"": [[3]]}, {""input"": [[0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [4, 9, 9, 9, 4, 4, 3, 4, 4, 4, 1, 1, 4, 4], [4, 9, 9, 9, 4, 4, 3, 4, 4, 4, 1, 1, 4, 4], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [7, 9, 9, 9, 7, 7, 3, 7, 7, 7, 1, 1, 7, 7], [7, 9, 9, 9, 7, 7, 3, 7, 7, 7, 1, 1, 7, 7], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0], [0, 9, 9, 9, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[6, 3, 3, 6, 6, 6, 8, 8, 6, 6, 6, 1, 1, 6], [6, 3, 3, 6, 6, 6, 8, 8, 6, 6, 6, 1, 1, 6], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [7, 3, 3, 7, 7, 7, 8, 8, 7, 7, 7, 1, 1, 7], [7, 3, 3, 7, 7, 7, 8, 8, 7, 7, 7, 1, 1, 7], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0], [5, 3, 3, 5, 5, 5, 8, 8, 5, 5, 5, 1, 1, 5], [0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 1, 1, 0]], ""output"": [[1]]}]}"
Qr9tVmLJqxxyfPeKrFeoMN,2025-07-21T15:52:23.491657,task1a2e2828,"[""Input grids are of size 14 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 5, 5, 5, 9, 9, 5, 5, 5, 5], [1, 1, 5, 5, 5, 9, 9, 5, 5, 5, 5], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 3, 3, 3, 9, 9, 3, 3, 3, 3], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0], [1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[2, 2, 2, 9, 9, 1, 1, 9, 9, 9, 9], [2, 2, 2, 9, 9, 1, 1, 9, 9, 9, 9], [2, 2, 2, 9, 9, 1, 1, 9, 9, 9, 9], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 6, 6, 1, 1, 6, 6, 6, 6], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 5, 5, 1, 1, 5, 5, 5, 5], [2, 2, 2, 5, 5, 1, 1, 5, 5, 5, 5], [2, 2, 2, 0, 0, 1, 1, 0, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 3, 3, 3, 3, 3, 3, 9, 9, 9], [5, 5, 3, 3, 3, 3, 3, 3, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 7, 7, 7, 7, 7, 7, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 0, 0, 0, 0, 0, 0, 9, 9, 9]], ""output"": [[5]]}], ""test"": [{""input"": [[0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [6, 6, 7, 7, 6, 6, 6, 6, 6, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [5, 5, 7, 7, 5, 5, 5, 5, 5, 4, 4], [5, 5, 7, 7, 5, 5, 5, 5, 5, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4], [0, 0, 7, 7, 0, 0, 0, 0, 0, 4, 4]], ""output"": [[4]]}]}"
SjEGaSE44qvpbz8pW49jGi,2025-07-21T15:52:23.495046,task1a2e2828,"[""Input grids are of size 13 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 8, 8, 8, 6, 6, 5, 5, 6, 6, 6, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [3, 3, 8, 8, 8, 3, 3, 5, 5, 3, 3, 3, 4, 4], [3, 3, 8, 8, 8, 3, 3, 5, 5, 3, 3, 3, 4, 4], [3, 3, 8, 8, 8, 3, 3, 5, 5, 3, 3, 3, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4], [9, 9, 8, 8, 8, 9, 9, 5, 5, 9, 9, 9, 4, 4], [9, 9, 8, 8, 8, 9, 9, 5, 5, 9, 9, 9, 4, 4], [0, 0, 8, 8, 8, 0, 0, 5, 5, 0, 0, 0, 4, 4]], ""output"": [[4]]}, {""input"": [[7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8], [7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4], [7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 9, 9, 4, 4], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 9, 9, 2, 2]], ""output"": [[9]]}, {""input"": [[2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 5, 5, 3, 3, 5, 5, 5, 9, 9, 5, 5], [2, 2, 2, 5, 5, 3, 3, 5, 5, 5, 9, 9, 5, 5], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 1, 1, 3, 3, 1, 1, 1, 9, 9, 1, 1], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0], [2, 2, 2, 6, 6, 3, 3, 6, 6, 6, 9, 9, 6, 6], [2, 2, 2, 6, 6, 3, 3, 6, 6, 6, 9, 9, 6, 6], [2, 2, 2, 0, 0, 3, 3, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[3]]}, {""input"": [[2, 2, 1, 1, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2], [2, 2, 1, 1, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [4, 4, 1, 1, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [7, 7, 1, 1, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7], [7, 7, 1, 1, 7, 7, 7, 7, 5, 5, 7, 7, 7, 7], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0]], ""output"": [[1]]}], ""test"": [{""input"": [[6, 6, 6, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8], [6, 6, 6, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 1, 1, 1, 1, 7, 7, 1, 1, 1, 1, 1], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5], [6, 6, 6, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0]], ""output"": [[7]]}]}"
NwWP2gPxSksLN9jow98CnB,2025-07-21T15:52:23.498219,task1a2e2828,"[""Input grids are of size 17 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [2, 2, 2, 8, 8, 2, 2, 4, 4, 2, 2, 2, 1, 1, 2, 2, 2, 2], [2, 2, 2, 8, 8, 2, 2, 4, 4, 2, 2, 2, 1, 1, 2, 2, 2, 2], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0], [5, 5, 5, 8, 8, 5, 5, 4, 4, 5, 5, 5, 1, 1, 5, 5, 5, 5], [0, 0, 0, 8, 8, 0, 0, 4, 4, 0, 0, 0, 1, 1, 0, 0, 0, 0]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [6, 6, 6, 7, 7, 6, 6, 6, 6, 8, 8, 8, 6, 6, 6, 6, 2, 6], [6, 6, 6, 7, 7, 6, 6, 6, 6, 8, 8, 8, 6, 6, 6, 6, 2, 6], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [3, 3, 3, 7, 7, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 2, 3], [3, 3, 3, 7, 7, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 2, 3], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 2, 0]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2], [2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2], [2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 2], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7], [7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[3, 3, 3, 2, 2, 2, 7, 7, 7, 2, 2, 2, 2, 2, 5, 5, 2, 2], [3, 3, 3, 2, 2, 2, 7, 7, 7, 2, 2, 2, 2, 2, 5, 5, 2, 2], [3, 3, 3, 2, 2, 2, 7, 7, 7, 2, 2, 2, 2, 2, 5, 5, 2, 2], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 3, 3, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 5, 5, 1, 1], [3, 3, 3, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 5, 5, 1, 1]], ""output"": [[5]]}]}"
Wn9VRKGrA7UWVDMZyhWeL3,2025-07-21T15:52:23.501627,task1a2e2828,"[""Input grids are of size 18 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [6, 6, 2, 2, 6, 6, 6, 6, 5, 5, 5, 6, 6], [6, 6, 2, 2, 6, 6, 6, 6, 5, 5, 5, 6, 6], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0], [4, 4, 2, 2, 4, 4, 4, 4, 5, 5, 5, 4, 4], [0, 0, 2, 2, 0, 0, 0, 0, 5, 5, 5, 0, 0]], ""output"": [[2]]}, {""input"": [[4, 4, 1, 1, 4, 4, 5, 5, 4, 4, 6, 6, 4], [4, 4, 1, 1, 4, 4, 5, 5, 4, 4, 6, 6, 4], [4, 4, 1, 1, 4, 4, 5, 5, 4, 4, 6, 6, 4], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [3, 3, 1, 1, 3, 3, 5, 5, 3, 3, 6, 6, 3], [3, 3, 1, 1, 3, 3, 5, 5, 3, 3, 6, 6, 3], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [8, 8, 1, 1, 8, 8, 5, 5, 8, 8, 6, 6, 8], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0], [0, 0, 1, 1, 0, 0, 5, 5, 0, 0, 6, 6, 0]], ""output"": [[1]]}, {""input"": [[3, 8, 8, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3], [3, 8, 8, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3], [3, 8, 8, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [6, 8, 8, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6], [6, 8, 8, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [7, 8, 8, 7, 7, 7, 7, 2, 2, 7, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0]], ""output"": [[2]]}, {""input"": [[8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 5, 5, 9, 9, 5, 5, 5, 5, 2, 2, 2], [8, 8, 5, 5, 9, 9, 5, 5, 5, 5, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 4, 4, 9, 9, 4, 4, 4, 4, 2, 2, 2], [8, 8, 4, 4, 9, 9, 4, 4, 4, 4, 2, 2, 2], [8, 8, 4, 4, 9, 9, 4, 4, 4, 4, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 6, 6, 9, 9, 6, 6, 6, 6, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2], [8, 8, 0, 0, 9, 9, 0, 0, 0, 0, 2, 2, 2]], ""output"": [[8]]}], ""test"": [{""input"": [[0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [7, 7, 3, 3, 7, 7, 7, 6, 6, 7, 7, 7, 1], [7, 7, 3, 3, 7, 7, 7, 6, 6, 7, 7, 7, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [4, 4, 3, 3, 4, 4, 4, 6, 6, 4, 4, 4, 1], [4, 4, 3, 3, 4, 4, 4, 6, 6, 4, 4, 4, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1], [0, 0, 3, 3, 0, 0, 0, 6, 6, 0, 0, 0, 1]], ""output"": [[1]]}]}"
aJeJGFsgEJ7cACxk2weEgV,2025-07-21T15:52:23.505180,task1a2e2828,"[""Input grids are of size 11 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 6, 6, 6, 6, 6, 7, 7, 6, 6, 6], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2], [4, 4, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[9, 2, 2, 9, 9, 9, 9, 3, 3, 9, 9, 9], [9, 2, 2, 9, 9, 9, 9, 3, 3, 9, 9, 9], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [4, 2, 2, 4, 4, 4, 4, 3, 3, 4, 4, 4], [4, 2, 2, 4, 4, 4, 4, 3, 3, 4, 4, 4], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 3, 3, 0, 0, 0], [8, 2, 2, 8, 8, 8, 8, 3, 3, 8, 8, 8]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [3, 3, 3, 1, 1, 3, 3, 3, 3, 4, 4, 3], [3, 3, 3, 1, 1, 3, 3, 3, 3, 4, 4, 3], [0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 0], [7, 7, 7, 1, 1, 7, 7, 7, 7, 4, 4, 7], [7, 7, 7, 1, 1, 7, 7, 7, 7, 4, 4, 7], [7, 7, 7, 1, 1, 7, 7, 7, 7, 4, 4, 7]], ""output"": [[1]]}, {""input"": [[7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 6, 6, 6, 3, 3, 6, 6, 6, 4, 4, 4], [7, 6, 6, 6, 3, 3, 6, 6, 6, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 0, 0, 0, 3, 3, 0, 0, 0, 4, 4, 4], [7, 5, 5, 5, 3, 3, 5, 5, 5, 4, 4, 4], [7, 5, 5, 5, 3, 3, 5, 5, 5, 4, 4, 4]], ""output"": [[7]]}], ""test"": [{""input"": [[8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 5, 5, 5, 5, 6, 6, 5, 5, 5], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 0, 0, 0], [8, 8, 8, 7, 7, 7, 7, 6, 6, 7, 7, 7], [8, 8, 8, 7, 7, 7, 7, 6, 6, 7, 7, 7]], ""output"": [[6]]}]}"
n5e2eScNwUC5Bbma3HZwZQ,2025-07-21T15:52:23.508456,task1a2e2828,"[""Input grids are of size 12 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 8, 8], [1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 4, 4, 7, 7, 7, 7, 7, 7, 8, 8], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 8, 8]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [6, 6, 6, 9, 9, 6, 6, 6, 6, 1, 1, 6, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [5, 5, 5, 9, 9, 5, 5, 5, 5, 1, 1, 5, 8, 8], [5, 5, 5, 9, 9, 5, 5, 5, 5, 1, 1, 5, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [0, 0, 0, 9, 9, 0, 0, 0, 0, 1, 1, 0, 8, 8], [4, 4, 4, 9, 9, 4, 4, 4, 4, 1, 1, 4, 8, 8], [4, 4, 4, 9, 9, 4, 4, 4, 4, 1, 1, 4, 8, 8]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 8, 8, 8], [1, 1, 1, 1, 1, 9, 9, 1, 1, 1, 1, 8, 8, 8], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 8, 8, 8], [5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 8, 8, 8], [5, 5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 8, 8, 8], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 8, 8, 8], [7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 8, 8, 8]], ""output"": [[9]]}, {""input"": [[8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 7, 7, 7, 9, 9, 7, 7, 7, 4, 4, 7], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 3, 3, 3, 9, 9, 3, 3, 3, 4, 4, 3], [8, 8, 8, 3, 3, 3, 9, 9, 3, 3, 3, 4, 4, 3], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 4, 4, 0], [8, 8, 8, 1, 1, 1, 9, 9, 1, 1, 1, 4, 4, 1], [8, 8, 8, 1, 1, 1, 9, 9, 1, 1, 1, 4, 4, 1]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [6, 6, 6, 6, 1, 1, 6, 6, 9, 9, 6, 6, 3, 3], [6, 6, 6, 6, 1, 1, 6, 6, 9, 9, 6, 6, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [4, 4, 4, 4, 1, 1, 4, 4, 9, 9, 4, 4, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 9, 9, 0, 0, 3, 3]], ""output"": [[1]]}]}"
DWwwRUTGXSrvCqdeNcHrT8,2025-07-21T15:52:23.511367,task1a2e2828,"[""Input grids are of size 14 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2], [2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 3, 3, 3, 8, 8, 8], [8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 3, 3, 3, 8, 8, 8], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7]], ""output"": [[5]]}, {""input"": [[0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [6, 6, 9, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6], [6, 6, 9, 6, 6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [1, 1, 9, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1], [1, 1, 9, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [4, 4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4], [4, 4, 4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3], [3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [2, 2, 2, 3, 3, 2, 2, 2, 8, 8, 2, 2, 2, 5, 5, 2], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [4, 4, 4, 3, 3, 4, 4, 4, 8, 8, 4, 4, 4, 5, 5, 4], [4, 4, 4, 3, 3, 4, 4, 4, 8, 8, 4, 4, 4, 5, 5, 4], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0], [0, 0, 0, 3, 3, 0, 0, 0, 8, 8, 0, 0, 0, 5, 5, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[4, 4, 4, 2, 2, 2, 2, 5, 5, 2, 2, 2, 2, 7, 7, 2], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 8, 8, 8, 8, 5, 5, 8, 8, 8, 8, 7, 7, 8], [4, 4, 4, 8, 8, 8, 8, 5, 5, 8, 8, 8, 8, 7, 7, 8], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0], [4, 4, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 7, 7, 0]], ""output"": [[5]]}]}"
QE4rns88YpNeq9CvjLa9Z5,2025-07-21T15:52:23.514307,task1a2e2828,"[""Input grids are of size 15 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 4, 4, 4], [6, 6, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4], [6, 6, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 4, 4, 4], [6, 6, 9, 9, 9, 9, 3, 3, 9, 9, 9, 9, 9, 4, 4, 4], [6, 6, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 9], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 9], [2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 2, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 9, 9], [6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 6, 9, 9], [6, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 6, 9, 9]], ""output"": [[4]]}, {""input"": [[0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [7, 7, 4, 4, 7, 7, 7, 7, 7, 2, 7, 7, 7, 7, 7, 7], [7, 7, 4, 4, 7, 7, 7, 7, 7, 2, 7, 7, 7, 7, 7, 7], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [1, 1, 4, 4, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1], [1, 1, 4, 4, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0]], ""output"": [[2]]}], ""test"": [{""input"": [[9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6], [9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6], [9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6], [7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6], [7, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6], [1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[5]]}]}"
229NNktmyShWdB8douuVft,2025-07-21T15:52:23.517809,task1a2e2828,"[""Input grids are of size 12 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 3, 2, 6, 6, 2, 4, 4, 2, 2, 2], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 8, 6, 6, 8, 4, 4, 8, 8, 8], [3, 3, 3, 8, 6, 6, 8, 4, 4, 8, 8, 8], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0], [3, 3, 3, 0, 6, 6, 0, 4, 4, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[1, 1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1], [1, 1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1], [1, 1, 1, 4, 4, 1, 1, 1, 7, 7, 1, 1], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [6, 6, 6, 4, 4, 6, 6, 6, 7, 7, 6, 6], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 7, 7, 0, 0], [3, 3, 3, 4, 4, 3, 3, 3, 7, 7, 3, 3], [3, 3, 3, 4, 4, 3, 3, 3, 7, 7, 3, 3]], ""output"": [[4]]}, {""input"": [[2, 2, 3, 3, 5, 5, 3, 9, 3, 3, 3, 3], [2, 2, 3, 3, 5, 5, 3, 9, 3, 3, 3, 3], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 0, 0, 5, 5, 0, 9, 0, 0, 0, 0], [2, 2, 4, 4, 5, 5, 4, 9, 4, 4, 4, 4], [2, 2, 4, 4, 5, 5, 4, 9, 4, 4, 4, 4]], ""output"": [[9]]}, {""input"": [[0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [6, 6, 6, 6, 1, 1, 6, 6, 6, 3, 3, 3], [6, 6, 6, 6, 1, 1, 6, 6, 6, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [9, 9, 9, 9, 1, 1, 9, 9, 9, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 1, 1, 0, 0, 0, 3, 3, 3], [7, 7, 7, 7, 1, 1, 7, 7, 7, 3, 3, 3], [7, 7, 7, 7, 1, 1, 7, 7, 7, 3, 3, 3]], ""output"": [[1]]}], ""test"": [{""input"": [[9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 2, 2, 3, 3, 2, 2, 2, 8, 8], [9, 9, 9, 2, 2, 3, 3, 2, 2, 2, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 7, 7, 3, 3, 7, 7, 7, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8], [9, 9, 9, 0, 0, 3, 3, 0, 0, 0, 8, 8]], ""output"": [[3]]}]}"
Y2omoZzCGhDMs6SDCEtMEa,2025-07-21T15:52:23.520812,task1a2e2828,"[""Input grids are of size 13 x 14."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 14}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [3, 3, 3, 1, 1, 3, 3, 3, 3, 3, 8, 8, 8, 3], [3, 3, 3, 1, 1, 3, 3, 3, 3, 3, 8, 8, 8, 3], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0], [5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 8, 8, 8, 5], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 8, 8, 8, 0]], ""output"": [[1]]}, {""input"": [[2, 2, 9, 9, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [3, 3, 9, 9, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3], [3, 3, 9, 9, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [7, 7, 9, 9, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7], [7, 7, 9, 9, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7], [7, 7, 9, 9, 7, 7, 7, 7, 7, 1, 1, 7, 7, 7]], ""output"": [[1]]}, {""input"": [[0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [1, 1, 1, 1, 9, 9, 1, 1, 4, 4, 1, 1, 5, 5], [1, 1, 1, 1, 9, 9, 1, 1, 4, 4, 1, 1, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [3, 3, 3, 3, 9, 9, 3, 3, 4, 4, 3, 3, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5], [0, 0, 0, 0, 9, 9, 0, 0, 4, 4, 0, 0, 5, 5]], ""output"": [[4]]}], ""test"": [{""input"": [[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2], [6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [7, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2], [7, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2], [7, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 2, 2]], ""output"": [[1]]}]}"
Es4K2HkjX2XFP7nfrHEaUB,2025-07-21T15:52:23.523834,task1a2e2828,"[""Input grids are of size 13 x 17."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 17}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 3, 3, 9, 9, 9, 3, 3, 3, 7, 7, 3, 3, 4, 4, 3], [3, 3, 3, 3, 9, 9, 9, 3, 3, 3, 7, 7, 3, 3, 4, 4, 3], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [8, 8, 8, 8, 9, 9, 9, 8, 8, 8, 7, 7, 8, 8, 4, 4, 8], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0], [5, 5, 5, 5, 9, 9, 9, 5, 5, 5, 7, 7, 5, 5, 4, 4, 5], [5, 5, 5, 5, 9, 9, 9, 5, 5, 5, 7, 7, 5, 5, 4, 4, 5], [0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 7, 7, 0, 0, 4, 4, 0]], ""output"": [[4]]}, {""input"": [[8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 4], [8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 4], [8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6, 4], [8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 6, 6, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 4]], ""output"": [[4]]}, {""input"": [[1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3], [4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3]], ""output"": [[3]]}], ""test"": [{""input"": [[7, 7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7, 7, 7, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 9, 9], [4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 9, 9], [8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 9, 9], [8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 9, 9]], ""output"": [[3]]}]}"
HtkYLqJAYwHzwnCHkUMW8r,2025-07-21T15:52:23.527409,task1a2e2828,"[""Input grids are of size 12 x 10."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 10}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[1, 1, 1, 8, 2, 2, 8, 8, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 7, 2, 2, 7, 7, 3, 3], [1, 1, 1, 7, 2, 2, 7, 7, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3], [1, 1, 1, 0, 2, 2, 0, 0, 3, 3]], ""output"": [[2]]}, {""input"": [[6, 6, 6, 8, 1, 1, 8, 8, 8, 8], [6, 6, 6, 8, 1, 1, 8, 8, 8, 8], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 9, 1, 1, 9, 9, 9, 9], [6, 6, 6, 9, 1, 1, 9, 9, 9, 9], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 0, 1, 1, 0, 0, 0, 0], [6, 6, 6, 7, 1, 1, 7, 7, 7, 7]], ""output"": [[1]]}, {""input"": [[9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 2, 1, 1, 1, 2, 6, 6], [9, 9, 9, 2, 1, 1, 1, 2, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 8, 1, 1, 1, 8, 6, 6], [9, 9, 9, 8, 1, 1, 1, 8, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 4, 1, 1, 1, 4, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6], [9, 9, 9, 0, 1, 1, 1, 0, 6, 6]], ""output"": [[6]]}, {""input"": [[9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 5, 5, 5, 5, 1, 1, 5], [9, 9, 9, 5, 5, 5, 5, 1, 1, 5], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 2, 2, 2, 2, 1, 1, 2], [9, 9, 9, 2, 2, 2, 2, 1, 1, 2], [9, 9, 9, 2, 2, 2, 2, 1, 1, 2], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0], [9, 9, 9, 3, 3, 3, 3, 1, 1, 3]], ""output"": [[1]]}], ""test"": [{""input"": [[8, 8, 8, 4, 4, 4, 1, 1, 4, 4], [8, 8, 8, 4, 4, 4, 1, 1, 4, 4], [8, 8, 8, 4, 4, 4, 1, 1, 4, 4], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 2, 2, 2, 1, 1, 2, 2], [8, 8, 8, 2, 2, 2, 1, 1, 2, 2], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 0, 0, 0, 1, 1, 0, 0], [8, 8, 8, 7, 7, 7, 1, 1, 7, 7]], ""output"": [[1]]}]}"
LrbRkxvgThcW5YY3gySsuR,2025-07-21T15:52:23.530557,task1a2e2828,"[""Input grids are of size 15 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 15, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[9, 9, 9, 8, 8, 6, 6, 8, 8, 7, 7], [9, 9, 9, 8, 8, 6, 6, 8, 8, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 4, 4, 6, 6, 4, 4, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 2, 2, 6, 6, 2, 2, 7, 7], [9, 9, 9, 2, 2, 6, 6, 2, 2, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7], [9, 9, 9, 0, 0, 6, 6, 0, 0, 7, 7]], ""output"": [[6]]}, {""input"": [[6, 5, 5, 6, 6, 6, 6, 6, 1, 1, 1], [6, 5, 5, 6, 6, 6, 6, 6, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [8, 5, 5, 8, 8, 8, 8, 8, 1, 1, 1], [8, 5, 5, 8, 8, 8, 8, 8, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1], [9, 5, 5, 9, 9, 9, 9, 9, 1, 1, 1], [9, 5, 5, 9, 9, 9, 9, 9, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1]], ""output"": [[5]]}, {""input"": [[8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 3, 3, 3, 3, 3, 9, 9, 3, 3], [8, 8, 3, 3, 3, 3, 3, 9, 9, 3, 3], [8, 8, 3, 3, 3, 3, 3, 9, 9, 3, 3], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 6, 6, 6, 6, 6, 9, 9, 6, 6], [8, 8, 6, 6, 6, 6, 6, 9, 9, 6, 6], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 1, 1, 1, 1, 1, 9, 9, 1, 1], [8, 8, 1, 1, 1, 1, 1, 9, 9, 1, 1]], ""output"": [[8]]}, {""input"": [[7, 7, 2, 2, 2, 2, 3, 3, 3, 2, 2], [7, 7, 2, 2, 2, 2, 3, 3, 3, 2, 2], [7, 7, 2, 2, 2, 2, 3, 3, 3, 2, 2], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 9, 9, 9, 9, 3, 3, 3, 9, 9], [7, 7, 9, 9, 9, 9, 3, 3, 3, 9, 9], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0], [7, 7, 0, 0, 0, 0, 3, 3, 3, 0, 0]], ""output"": [[7]]}], ""test"": [{""input"": [[3, 3, 9, 9, 9, 9, 9, 4, 4, 4, 9], [3, 3, 9, 9, 9, 9, 9, 4, 4, 4, 9], [3, 3, 9, 9, 9, 9, 9, 4, 4, 4, 9], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 6, 6, 6, 6, 6, 4, 4, 4, 6], [3, 3, 6, 6, 6, 6, 6, 4, 4, 4, 6], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0], [3, 3, 5, 5, 5, 5, 5, 4, 4, 4, 5], [3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 0]], ""output"": [[3]]}]}"
MLeEaJx9LbkmJfpXRxgGcn,2025-07-21T15:52:23.533713,task1a2e2828,"[""Input grids are of size 14 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 14, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 6, 6, 6, 6, 6, 6, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 9, 9, 9, 9, 9, 9, 8, 8], [5, 5, 5, 9, 9, 9, 9, 9, 9, 8, 8]], ""output"": [[8]]}, {""input"": [[0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [9, 6, 6, 9, 9, 9, 9, 2, 2, 2, 9], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [0, 6, 6, 0, 0, 0, 0, 2, 2, 2, 0], [8, 6, 6, 8, 8, 8, 8, 2, 2, 2, 8], [8, 6, 6, 8, 8, 8, 8, 2, 2, 2, 8]], ""output"": [[6]]}, {""input"": [[0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [4, 7, 7, 4, 4, 4, 3, 4, 4, 4, 4], [4, 7, 7, 4, 4, 4, 3, 4, 4, 4, 4], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [1, 7, 7, 1, 1, 1, 3, 1, 1, 1, 1], [1, 7, 7, 1, 1, 1, 3, 1, 1, 1, 1], [1, 7, 7, 1, 1, 1, 3, 1, 1, 1, 1], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 3, 0, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[5, 5, 5, 5, 7, 7, 5, 5, 5, 9, 9], [5, 5, 5, 5, 7, 7, 5, 5, 5, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [1, 1, 1, 1, 7, 7, 1, 1, 1, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9]], ""output"": [[7]]}, {""input"": [[8, 8, 8, 7, 7, 7, 7, 7, 7, 5, 5], [8, 8, 8, 7, 7, 7, 7, 7, 7, 5, 5], [8, 8, 8, 7, 7, 7, 7, 7, 7, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 6, 6, 6, 6, 6, 6, 5, 5], [8, 8, 8, 6, 6, 6, 6, 6, 6, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 1, 1, 1, 1, 1, 1, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5], [8, 8, 8, 0, 0, 0, 0, 0, 0, 5, 5]], ""output"": [[5]]}], ""test"": [{""input"": [[9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4], [9, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4], [9, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [9, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1], [9, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1]], ""output"": [[9]]}]}"
7pQxtA6n4AACWZQJB5e4La,2025-07-21T15:52:23.536861,task1a2e2828,"[""Input grids are of size 18 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 9, 9, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 4, 3], [3, 9, 9, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 4, 3], [3, 9, 9, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 4, 3], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [2, 9, 9, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 4, 2], [2, 9, 9, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 2, 4, 2], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0], [0, 9, 9, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 4, 0]], ""output"": [[4]]}, {""input"": [[4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 5, 5], [4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 5, 5], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7], [4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7], [4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 8, 8]], ""output"": [[6]]}, {""input"": [[3, 3, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 6, 1], [3, 3, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 6, 1], [3, 3, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 6, 1], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 6, 5], [3, 3, 3, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 6, 5], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 6, 0]], ""output"": [[6]]}], ""test"": [{""input"": [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 9], [5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 9], [5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [7, 7, 7, 7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9], [7, 7, 7, 7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9]], ""output"": [[4]]}]}"
gD2QNF6dERXnBmjy2sbe96,2025-07-21T15:52:23.539839,task1a2e2828,"[""Input grids are of size 12 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[3, 3, 3, 9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 1], [3, 3, 3, 9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1], [3, 3, 3, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 1], [3, 3, 3, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 1]], ""output"": [[1]]}, {""input"": [[6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 8, 8, 8, 8, 8, 5, 5, 8, 8, 8, 8, 8], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1], [6, 6, 6, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0]], ""output"": [[5]]}, {""input"": [[8, 8, 5, 5, 1, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [8, 8, 5, 5, 1, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [8, 8, 5, 5, 1, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 3, 3, 1, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3], [8, 8, 3, 3, 1, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0]], ""output"": [[1]]}, {""input"": [[3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7], [6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7]], ""output"": [[5]]}], ""test"": [{""input"": [[4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 5, 5, 7, 7, 7], [4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 5, 5, 7, 7, 7], [4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 5, 5, 7, 7, 7], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 5, 5, 9, 9, 9], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 5, 5, 9, 9, 9], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 5, 5, 0, 0, 0], [4, 4, 4, 2, 2, 6, 6, 2, 2, 2, 5, 5, 2, 2, 2]], ""output"": [[5]]}]}"
THPugpMPFowe9jgJYTawkM,2025-07-21T15:52:23.542921,task1a2e2828,"[""Input grids are of size 13 x 13."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 13}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[8, 6, 6, 8, 8, 8, 8, 5, 5, 8, 8, 8, 4], [8, 6, 6, 8, 8, 8, 8, 5, 5, 8, 8, 8, 4], [8, 6, 6, 8, 8, 8, 8, 5, 5, 8, 8, 8, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [7, 6, 6, 7, 7, 7, 7, 5, 5, 7, 7, 7, 4], [7, 6, 6, 7, 7, 7, 7, 5, 5, 7, 7, 7, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4], [0, 6, 6, 0, 0, 0, 0, 5, 5, 0, 0, 0, 4]], ""output"": [[4]]}, {""input"": [[1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 5, 5, 5, 9, 9, 5, 5, 5, 5, 5], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 2, 2, 2, 9, 9, 2, 2, 2, 2, 2], [1, 1, 1, 2, 2, 2, 9, 9, 2, 2, 2, 2, 2], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0]], ""output"": [[9]]}, {""input"": [[9, 9, 8, 8, 1, 1, 8, 8, 8, 8, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 3, 3, 1, 1, 3, 3, 3, 3, 4, 4, 4], [9, 9, 3, 3, 1, 1, 3, 3, 3, 3, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 0, 0, 1, 1, 0, 0, 0, 0, 4, 4, 4], [9, 9, 5, 5, 1, 1, 5, 5, 5, 5, 4, 4, 4], [9, 9, 5, 5, 1, 1, 5, 5, 5, 5, 4, 4, 4]], ""output"": [[1]]}], ""test"": [{""input"": [[0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 2, 2, 2], [6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [9, 9, 4, 4, 9, 9, 9, 9, 9, 9, 2, 2, 2], [9, 9, 4, 4, 9, 9, 9, 9, 9, 9, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2]], ""output"": [[4]]}]}"
D52KqAkDDWrZeuUphLb3xj,2025-07-21T15:52:23.546263,task1a2e2828,"[""Input grids are of size 11 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 11, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 4], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 4], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 3], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0]], ""output"": [[2]]}, {""input"": [[3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 9, 2, 2, 2, 2], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7], [3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0]], ""output"": [[3]]}, {""input"": [[6, 6, 6, 6, 7, 7, 6, 6, 6, 8, 8, 6, 6, 6, 4, 4, 6, 6], [6, 6, 6, 6, 7, 7, 6, 6, 6, 8, 8, 6, 6, 6, 4, 4, 6, 6], [0, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 4, 4, 0, 0], [9, 9, 9, 9, 7, 7, 9, 9, 9, 8, 8, 9, 9, 9, 4, 4, 9, 9], [9, 9, 9, 9, 7, 7, 9, 9, 9, 8, 8, 9, 9, 9, 4, 4, 9, 9], [0, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 4, 4, 0, 0], [2, 2, 2, 2, 7, 7, 2, 2, 2, 8, 8, 2, 2, 2, 4, 4, 2, 2], [2, 2, 2, 2, 7, 7, 2, 2, 2, 8, 8, 2, 2, 2, 4, 4, 2, 2]], ""output"": [[4]]}, {""input"": [[0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1], [1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1], [1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [8, 8, 8, 8, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 8], [8, 8, 8, 8, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 8], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0]], ""output"": [[6]]}, {""input"": [[3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 7, 7, 5, 5], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 7, 7, 1, 1], [3, 3, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 7, 7, 1, 1], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0], [3, 3, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 7, 7, 0, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[3, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 7, 2, 2, 7], [3, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 7, 2, 2, 7], [3, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [3, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [3, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [3, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 2, 2, 9], [3, 9, 9, 9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 2, 2, 9], [3, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [3, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [3, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4], [3, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4]], ""output"": [[3]]}]}"
ADfVGff6GK6QKRoUu9HC8f,2025-07-21T15:52:23.549444,task1a2e2828,"[""Input grids are of size 17 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1], [4, 4, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1], [4, 4, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0], [4, 4, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8], [4, 4, 8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 8], [4, 4, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0]], ""output"": [[4]]}, {""input"": [[0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [9, 9, 3, 3, 3, 9, 9, 9, 9, 2, 2, 9, 9, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [5, 5, 3, 3, 3, 5, 5, 5, 5, 2, 2, 5, 5, 4, 4], [5, 5, 3, 3, 3, 5, 5, 5, 5, 2, 2, 5, 5, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 2, 2, 0, 0, 4, 4]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [7, 7, 7, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 8, 8], [7, 7, 7, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 8, 8]], ""output"": [[8]]}, {""input"": [[4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2], [4, 4, 4, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 7, 7, 7, 7, 7, 3, 3, 7, 7, 7, 7, 7], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [4, 4, 4, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5, 5], [4, 4, 4, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5, 5, 5], [4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0]], ""output"": [[3]]}], ""test"": [{""input"": [[6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 7, 7, 4], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 8, 8, 2, 2, 2, 8, 8, 8, 8, 8, 7, 7, 8], [6, 6, 8, 8, 2, 2, 2, 8, 8, 8, 8, 8, 7, 7, 8], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0], [6, 6, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 7, 7, 1], [6, 6, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 7, 7, 1], [6, 6, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 7, 7, 0]], ""output"": [[6]]}]}"
oHDgdRYjSyTvg7MEX9JPvr,2025-07-21T15:52:23.553334,task1a2e2828,"[""Input grids are of size 13 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [5, 5, 2, 2, 5, 5, 5, 8, 8, 5, 5, 5, 3, 3, 5, 5], [5, 5, 2, 2, 5, 5, 5, 8, 8, 5, 5, 5, 3, 3, 5, 5], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0], [7, 7, 2, 2, 7, 7, 7, 8, 8, 7, 7, 7, 3, 3, 7, 7], [0, 0, 2, 2, 0, 0, 0, 8, 8, 0, 0, 0, 3, 3, 0, 0]], ""output"": [[2]]}, {""input"": [[6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 2, 2, 2, 9], [6, 6, 9, 9, 9, 4, 4, 9, 9, 9, 9, 9, 2, 2, 2, 9], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 2, 2, 2, 5], [6, 6, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 2, 2, 2, 5], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 0], [6, 6, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 2, 2, 2, 8]], ""output"": [[4]]}, {""input"": [[4, 3, 3, 4, 4, 4, 4, 4, 7, 7, 7, 4, 4, 4, 6, 6], [4, 3, 3, 4, 4, 4, 4, 4, 7, 7, 7, 4, 4, 4, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [8, 3, 3, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [5, 3, 3, 5, 5, 5, 5, 5, 7, 7, 7, 5, 5, 5, 6, 6], [5, 3, 3, 5, 5, 5, 5, 5, 7, 7, 7, 5, 5, 5, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 6, 6]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8], [5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8], [9, 9, 9, 6, 6, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8], [0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8]], ""output"": [[6]]}], ""test"": [{""input"": [[9, 9, 5, 5, 9, 9, 9, 9, 9, 2, 2, 9, 9, 6, 9, 9], [9, 9, 5, 5, 9, 9, 9, 9, 9, 2, 2, 9, 9, 6, 9, 9], [9, 9, 5, 5, 9, 9, 9, 9, 9, 2, 2, 9, 9, 6, 9, 9], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [1, 1, 5, 5, 1, 1, 1, 1, 1, 2, 2, 1, 1, 6, 1, 1], [1, 1, 5, 5, 1, 1, 1, 1, 1, 2, 2, 1, 1, 6, 1, 1], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0]], ""output"": [[6]]}]}"
cRkjgjh9BhLD9ErffNX2vC,2025-07-21T15:52:23.556367,task1a2e2828,"[""Input grids are of size 12 x 18."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 18}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2], [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2], [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8]], ""output"": [[5]]}, {""input"": [[2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 7, 7, 8, 8, 5], [2, 2, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 7, 7, 8, 8, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5], [2, 2, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 4, 7, 7, 4, 4, 5], [2, 2, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 4, 7, 7, 4, 4, 5], [2, 2, 4, 4, 4, 4, 1, 1, 4, 4, 4, 4, 4, 7, 7, 4, 4, 5]], ""output"": [[5]]}, {""input"": [[0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [3, 3, 3, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3], [3, 3, 3, 3, 3, 3, 7, 7, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [5, 5, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [5, 5, 5, 5, 5, 5, 7, 7, 5, 5, 5, 5, 5, 5, 9, 9, 5, 5], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [8, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8]], ""output"": [[7]]}, {""input"": [[6, 3, 3, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 9, 6, 6], [6, 3, 3, 6, 6, 6, 6, 6, 7, 7, 7, 6, 6, 6, 6, 9, 6, 6], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [4, 3, 3, 4, 4, 4, 4, 4, 7, 7, 7, 4, 4, 4, 4, 9, 4, 4], [4, 3, 3, 4, 4, 4, 4, 4, 7, 7, 7, 4, 4, 4, 4, 9, 4, 4], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 9, 0, 0]], ""output"": [[9]]}], ""test"": [{""input"": [[5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6], [1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6]], ""output"": [[4]]}]}"
XmHyHmwU8sj2Tu6hFzamsi,2025-07-21T15:52:23.559927,task1a2e2828,"[""Input grids are of size 12 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [4, 4, 4, 4, 6, 6, 4, 4, 4, 8, 8], [4, 4, 4, 4, 6, 6, 4, 4, 4, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [7, 7, 7, 7, 6, 6, 7, 7, 7, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 6, 0, 0, 0, 8, 8]], ""output"": [[6]]}, {""input"": [[4, 4, 6, 6, 6, 4, 4, 4, 4, 9, 9], [4, 4, 6, 6, 6, 4, 4, 4, 4, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [1, 1, 6, 6, 6, 1, 1, 1, 1, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9], [7, 7, 6, 6, 6, 7, 7, 7, 7, 9, 9], [7, 7, 6, 6, 6, 7, 7, 7, 7, 9, 9], [0, 0, 6, 6, 6, 0, 0, 0, 0, 9, 9]], ""output"": [[9]]}, {""input"": [[8, 3, 3, 8, 7, 7, 8, 6, 6, 8, 8], [8, 3, 3, 8, 7, 7, 8, 6, 6, 8, 8], [8, 3, 3, 8, 7, 7, 8, 6, 6, 8, 8], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0], [9, 3, 3, 9, 7, 7, 9, 6, 6, 9, 9], [9, 3, 3, 9, 7, 7, 9, 6, 6, 9, 9], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0], [4, 3, 3, 4, 7, 7, 4, 6, 6, 4, 4], [0, 3, 3, 0, 7, 7, 0, 6, 6, 0, 0]], ""output"": [[3]]}, {""input"": [[4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 7], [4, 4, 4, 7, 7, 6, 6, 7, 7, 7, 7], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 3, 3, 6, 6, 3, 3, 3, 3], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 0, 0, 6, 6, 0, 0, 0, 0], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9], [4, 4, 4, 9, 9, 6, 6, 9, 9, 9, 9]], ""output"": [[6]]}], ""test"": [{""input"": [[1, 1, 7, 7, 7, 7, 7, 5, 5, 5, 7], [1, 1, 7, 7, 7, 7, 7, 5, 5, 5, 7], [1, 1, 0, 0, 0, 0, 0, 5, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 5, 5, 5, 0], [1, 1, 4, 4, 4, 4, 4, 5, 5, 5, 4], [1, 1, 4, 4, 4, 4, 4, 5, 5, 5, 4], [1, 1, 0, 0, 0, 0, 0, 5, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 5, 5, 5, 0], [1, 1, 0, 0, 0, 0, 0, 5, 5, 5, 0], [1, 1, 2, 2, 2, 2, 2, 5, 5, 5, 2], [1, 1, 2, 2, 2, 2, 2, 5, 5, 5, 2], [1, 1, 2, 2, 2, 2, 2, 5, 5, 5, 2]], ""output"": [[1]]}]}"
WtoacM4FqxhJJAHG2AR5wM,2025-07-21T15:52:23.563099,task1a2e2828,"[""Input grids are of size 13 x 11."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 13, ""cols"": 11}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 7, 2, 2, 7, 7, 7, 1, 1], [6, 6, 6, 7, 2, 2, 7, 7, 7, 1, 1], [6, 6, 6, 7, 2, 2, 7, 7, 7, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 3, 2, 2, 3, 3, 3, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1], [6, 6, 6, 9, 2, 2, 9, 9, 9, 1, 1], [6, 6, 6, 9, 2, 2, 9, 9, 9, 1, 1], [6, 6, 6, 0, 2, 2, 0, 0, 0, 1, 1]], ""output"": [[1]]}, {""input"": [[0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [4, 2, 2, 4, 4, 4, 3, 3, 4, 4, 4], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [9, 2, 2, 9, 9, 9, 3, 3, 9, 9, 9], [9, 2, 2, 9, 9, 9, 3, 3, 9, 9, 9], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [0, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0]], ""output"": [[2]]}, {""input"": [[2, 2, 2, 9, 9, 9, 3, 3, 9, 9, 9], [2, 2, 2, 9, 9, 9, 3, 3, 9, 9, 9], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 5, 5, 5, 3, 3, 5, 5, 5], [2, 2, 2, 5, 5, 5, 3, 3, 5, 5, 5], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 0, 0, 0, 3, 3, 0, 0, 0], [2, 2, 2, 6, 6, 6, 3, 3, 6, 6, 6]], ""output"": [[3]]}, {""input"": [[0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [8, 8, 8, 8, 2, 2, 8, 8, 8, 3, 3], [8, 8, 8, 8, 2, 2, 8, 8, 8, 3, 3], [8, 8, 8, 8, 2, 2, 8, 8, 8, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [4, 4, 4, 4, 2, 2, 4, 4, 4, 3, 3], [4, 4, 4, 4, 2, 2, 4, 4, 4, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [0, 0, 0, 0, 2, 2, 0, 0, 0, 3, 3], [1, 1, 1, 1, 2, 2, 1, 1, 1, 3, 3]], ""output"": [[2]]}, {""input"": [[0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [1, 1, 1, 1, 6, 1, 1, 1, 1, 8, 8], [1, 1, 1, 1, 6, 1, 1, 1, 1, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0, 0, 8, 8], [3, 3, 3, 3, 6, 3, 3, 3, 3, 8, 8], [3, 3, 3, 3, 6, 3, 3, 3, 3, 8, 8]], ""output"": [[6]]}], ""test"": [{""input"": [[5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 3, 3, 1, 1, 3, 3, 6, 6, 6], [5, 5, 3, 3, 1, 1, 3, 3, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 4, 4, 1, 1, 4, 4, 6, 6, 6], [5, 5, 4, 4, 1, 1, 4, 4, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6], [5, 5, 2, 2, 1, 1, 2, 2, 6, 6, 6], [5, 5, 0, 0, 1, 1, 0, 0, 6, 6, 6]], ""output"": [[1]]}]}"
YB7kEgFUK7sSWFzyFwsqNf,2025-07-21T15:52:23.566119,task1a2e2828,"[""Input grids are of size 18 x 15."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 18, ""cols"": 15}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [5, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7], [5, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7], [6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7], [6, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7]], ""output"": [[8]]}, {""input"": [[0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [9, 9, 7, 7, 7, 9, 9, 3, 3, 3, 9, 9, 5, 5, 9], [9, 9, 7, 7, 7, 9, 9, 3, 3, 3, 9, 9, 5, 5, 9], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [1, 1, 7, 7, 7, 1, 1, 3, 3, 3, 1, 1, 5, 5, 1], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 0, 0, 3, 3, 3, 0, 0, 5, 5, 0]], ""output"": [[5]]}, {""input"": [[4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 1, 1, 4, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [5, 5, 5, 8, 8, 8, 5, 5, 5, 5, 1, 1, 5, 6, 6], [5, 5, 5, 8, 8, 8, 5, 5, 5, 5, 1, 1, 5, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 1, 1, 0, 6, 6]], ""output"": [[1]]}, {""input"": [[9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 2, 2, 2, 2, 6, 6, 2, 2, 2, 7, 7, 2], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 3, 3, 3, 3, 6, 6, 3, 3, 3, 7, 7, 3], [9, 9, 9, 3, 3, 3, 3, 6, 6, 3, 3, 3, 7, 7, 3], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0], [9, 9, 9, 0, 0, 0, 0, 6, 6, 0, 0, 0, 7, 7, 0]], ""output"": [[6]]}], ""test"": [{""input"": [[0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [5, 9, 9, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 7, 7], [5, 9, 9, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [1, 9, 9, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7], [0, 9, 9, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 7, 7]], ""output"": [[2]]}]}"
geXuDpUcvhi9a59xcHu5kS,2025-07-21T15:52:23.569298,task1a2e2828,"[""Input grids are of size 12 x 16."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 12, ""cols"": 16}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 5, 5, 5, 5, 5, 2, 5, 5, 5, 5, 5, 5, 5, 5], [4, 4, 5, 5, 5, 5, 5, 2, 5, 5, 5, 5, 5, 5, 5, 5], [4, 4, 5, 5, 5, 5, 5, 2, 5, 5, 5, 5, 5, 5, 5, 5], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 6, 6, 6, 6, 6, 2, 6, 6, 6, 6, 6, 6, 6, 6], [4, 4, 6, 6, 6, 6, 6, 2, 6, 6, 6, 6, 6, 6, 6, 6], [4, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], ""output"": [[2]]}, {""input"": [[5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 4, 4, 2, 2, 4, 4, 4, 4, 4, 8, 8, 4, 4], [5, 5, 5, 4, 4, 2, 2, 4, 4, 4, 4, 4, 8, 8, 4, 4], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 0, 0, 2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0], [5, 5, 5, 9, 9, 2, 2, 9, 9, 9, 9, 9, 8, 8, 9, 9]], ""output"": [[2]]}, {""input"": [[8, 8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 3, 3, 8, 8], [8, 8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 3, 3, 8, 8], [8, 8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 3, 3, 8, 8], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9], [9, 9, 9, 5, 5, 9, 9, 9, 9, 9, 9, 9, 3, 3, 9, 9], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2]], ""output"": [[3]]}], ""test"": [{""input"": [[8, 8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8], [8, 8, 8, 5, 5, 8, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 1, 1, 6, 6], [6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 1, 1, 6, 6], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3]], ""output"": [[1]]}]}"
HADU8gw6WcNhReJ5wpkG4S,2025-07-21T15:52:23.572461,task1a2e2828,"[""Input grids are of size 17 x 12."", ""There are up to three horizontal bars (height = 1\u20133 cells) and up to three vertical bars (width = 1\u20133 cells)."", ""Among these, you will always find at least one 2-cell-tall horizontal bar and one 2-cell-wide vertical bar, plus exactly one 1-cell-thick stripe (either horizontal or vertical)."", ""All bars are spaced evenly so that wherever a horizontal and a vertical bar cross, you get a neat rectangular intersection.""]","[""The output grid is a single cell (a 1\u00d71 grid)."", ""Identify every cell in the input where a horizontal bar and a vertical bar overlap."", ""Among those intersection areas, pick the one with the smallest overlap region (i.e. the narrowest crossing)."", ""Color the output cell with that intersectioning color.""]","{""rows"": 17, ""cols"": 12}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to 1x1 output with color of smallest intersection.""""""
    
    # Find all intersections by checking where horizontal and vertical bars cross
    intersections = []
    
    # For each horizontal bar, check intersections with vertical bars
    for h_start_row, h_thickness, h_color in self.horizontal_bars:
        h_end_row = h_start_row + h_thickness
        
        for v_start_col, v_thickness, v_color in self.vertical_bars:
            v_end_col = v_start_col + v_thickness
            
            # Check if they actually intersect
            intersection_exists = False
            for r in range(h_start_row, min(h_end_row, grid.shape[0])):
                for c in range(v_start_col, min(v_end_col, grid.shape[1])):
                    if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                        intersection_exists = True
                        break
                if intersection_exists:
                    break
            
            if intersection_exists:
                # Calculate intersection area
                intersection_area = h_thickness * v_thickness
                
                # Get the actual color that appears in the intersection
                # Sample from the middle of the intersection
                sample_r = h_start_row + h_thickness // 2
                sample_c = v_start_col + v_thickness // 2
                
                if (0 <= sample_r < grid.shape[0] and 0 <= sample_c < grid.shape[1]):
                    actual_color = grid[sample_r, sample_c]
                    intersections.append((intersection_area, actual_color, sample_r, sample_c))
    
    if intersections:
        # Remove duplicates and sort by area (smallest first)
        unique_intersections = {}
        for area, color, r, c in intersections:
            key = (area, color)
            if key not in unique_intersections:
                unique_intersections[key] = (area, color, r, c)
        
        intersections = list(unique_intersections.values())
        intersections.sort(key=lambda x: (x[0], x[1]))  # Sort by area, then color
        
        return np.array([[intersections[0][1]]], dtype=int)
    
    # Enhanced fallback: Look for intersections by analyzing the grid directly
    intersection_candidates = []
    
    # Find cells that could be intersections (non-zero cells that have neighbors in both directions)
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] != 0:
                cell_color = grid[r, c]
                
                # Check if this cell has horizontal extent (left or right neighbors of same color)
                has_horizontal = (grid[r, c-1] == cell_color or grid[r, c+1] == cell_color or
                                any(grid[r, cc] == cell_color for cc in range(grid.shape[1]) if cc != c))
                
                # Check if this cell has vertical extent (up or down neighbors of same color)  
                has_vertical = (grid[r-1, c] == cell_color or grid[r+1, c] == cell_color or
                              any(grid[rr, c] == cell_color for rr in range(grid.shape[0]) if rr != r))
                
                # If it has both horizontal and vertical extent, it's likely an intersection
                if has_horizontal and has_vertical:
                    # Calculate approximate area by counting connected cells in both directions
                    h_extent = sum(1 for cc in range(grid.shape[1]) if grid[r, cc] == cell_color)
                    v_extent = sum(1 for rr in range(grid.shape[0]) if grid[rr, c] == cell_color)
                    
                    if h_extent >= 2 and v_extent >= 2:
                        approx_area = min(h_extent, v_extent)  # Use minimum for ""smallest"" intersection
                        intersection_candidates.append((approx_area, cell_color, r, c))
    
    if intersection_candidates:
        # Remove duplicates and sort
        unique_candidates = {}
        for area, color, r, c in intersection_candidates:
            key = (area, color)
            if key not in unique_candidates:
                unique_candidates[key] = (area, color, r, c)
        
        candidates = list(unique_candidates.values())
        candidates.sort(key=lambda x: (x[0], x[1]))
        return np.array([[candidates[0][1]]], dtype=int)
    
    # Final fallback
    colors = np.unique(grid)
    colors = colors[colors != 0]
    if len(colors) > 0:
        return np.array([[colors[0]]], dtype=int)
    
    return np.array([[0]], dtype=int)","{""train"": [{""input"": [[6, 5, 5, 6, 6, 6, 6, 6, 6, 1, 1, 1], [6, 5, 5, 6, 6, 6, 6, 6, 6, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [3, 5, 5, 3, 3, 3, 3, 3, 3, 1, 1, 1], [3, 5, 5, 3, 3, 3, 3, 3, 3, 1, 1, 1], [3, 5, 5, 3, 3, 3, 3, 3, 3, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 5, 5, 0, 0, 0, 0, 0, 0, 1, 1, 1], [7, 5, 5, 7, 7, 7, 7, 7, 7, 1, 1, 1], [7, 5, 5, 7, 7, 7, 7, 7, 7, 1, 1, 1]], ""output"": [[5]]}, {""input"": [[0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [1, 1, 8, 8, 1, 1, 1, 1, 1, 2, 2, 1], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [9, 9, 8, 8, 9, 9, 9, 9, 9, 2, 2, 9], [9, 9, 8, 8, 9, 9, 9, 9, 9, 2, 2, 9], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 2, 2, 0]], ""output"": [[2]]}, {""input"": [[6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 4, 4, 5, 5, 4, 4, 4, 7, 4], [6, 6, 6, 4, 4, 5, 5, 4, 4, 4, 7, 4], [6, 6, 6, 4, 4, 5, 5, 4, 4, 4, 7, 4], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 3, 3, 5, 5, 3, 3, 3, 7, 3], [6, 6, 6, 3, 3, 5, 5, 3, 3, 3, 7, 3], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0], [6, 6, 6, 0, 0, 5, 5, 0, 0, 0, 7, 0]], ""output"": [[7]]}], ""test"": [{""input"": [[9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 8, 8, 8, 8, 1, 1, 8, 8, 8], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 4, 4, 4, 4, 1, 1, 4, 4, 4], [9, 9, 9, 4, 4, 4, 4, 1, 1, 4, 4, 4], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 1, 1, 0, 0, 0]], ""output"": [[1]]}]}"
J7VbVVSZy7f74ciQLbsKge,2025-07-21T15:52:23.576130,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 3, ""color1"": 4, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 8
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 3, 3, 3, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4]]}, {""input"": [[3, 3, 3, 3, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 3, 3, 3, 3]], ""output"": [[4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4], [4, 8, 0, 0, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 0, 0, 8, 4], [4, 8, 0, 0, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 0, 0, 8, 4], [4, 8, 0, 0, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 0, 0, 8, 4], [4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4]]}, {""input"": [[0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0]]}, {""input"": [[3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0]]}, {""input"": [[3, 0, 0, 0, 3], [0, 3, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 3, 0], [3, 0, 0, 0, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 0, 0, 8, 4], [0, 0, 4, 8, 0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0, 8, 4, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 4, 8, 0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0, 8, 4, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 0, 0, 8, 4]]}], ""test"": [{""input"": [[3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[4, 8, 4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4, 8, 4], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0, 0, 0]]}]}"
5ZDhoAA5ZAGsLXdj7mhTjs,2025-07-21T15:52:23.578517,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and yellow color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 5, ""color1"": 9, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 9
    color2 = 4
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0]]}, {""input"": [[0, 0, 0, 0, 5], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9]]}, {""input"": [[0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0]]}, {""input"": [[5, 5, 5, 5, 5], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5]], ""output"": [[9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 9]]}, {""input"": [[5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0]]}], ""test"": [{""input"": [[5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 5, 5, 5, 5]], ""output"": [[9, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 4, 9, 4, 9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9, 4, 9, 4, 9]]}]}"
PZ4dAhHrUkJKf73Lwa35oN,2025-07-21T15:52:23.580718,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 7, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 8
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4]], ""output"": [[7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 7]]}, {""input"": [[4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4]], ""output"": [[7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7]]}, {""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[7, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7]]}], ""test"": [{""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0]]}]}"
ihXVpAiBgPmqDEteBxnKrY,2025-07-21T15:52:23.585297,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and red color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 9, ""color1"": 5, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 5
    color2 = 2
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9, 9], [9, 0, 0, 9], [9, 0, 0, 9], [9, 9, 9, 9]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[0, 0, 0, 9], [0, 0, 0, 9], [0, 0, 0, 9], [9, 9, 9, 9]], ""output"": [[0, 0, 0, 0, 0, 0, 5, 2], [0, 0, 0, 0, 0, 0, 2, 5], [0, 0, 0, 0, 0, 0, 5, 2], [0, 0, 0, 0, 0, 0, 2, 5], [0, 0, 0, 0, 0, 0, 5, 2], [0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 9, 0, 0], [9, 9, 9, 9]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0], [0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 2, 5, 0, 0, 0, 0], [5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[9, 0, 0, 9], [0, 9, 9, 0], [0, 9, 9, 0], [9, 0, 0, 9]], ""output"": [[5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5], [0, 0, 5, 2, 5, 2, 0, 0], [0, 0, 2, 5, 2, 5, 0, 0], [0, 0, 5, 2, 5, 2, 0, 0], [0, 0, 2, 5, 2, 5, 0, 0], [5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5]]}, {""input"": [[9, 9, 9, 9], [9, 0, 0, 9], [9, 0, 0, 9], [9, 9, 9, 9]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5]]}], ""test"": [{""input"": [[0, 0, 9, 0], [0, 0, 9, 0], [9, 9, 9, 9], [0, 0, 9, 0]], ""output"": [[0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0], [5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0]]}]}"
ZTihrjESsxNmGRAiosMkPF,2025-07-21T15:52:23.588203,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and pink color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 9, ""color1"": 8, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 8
    color2 = 6
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 0, 9, 0], [0, 0, 9, 0]], ""output"": [[8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8], [0, 0, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0]]}, {""input"": [[9, 0, 0, 0], [9, 0, 0, 0], [9, 0, 0, 0], [9, 9, 9, 9]], ""output"": [[8, 6, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0], [8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8]]}, {""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 9, 0, 0], [9, 9, 9, 9]], ""output"": [[8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8], [0, 0, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0], [0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 6, 8, 0, 0, 0, 0], [8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8]]}], ""test"": [{""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 9, 0, 0], [9, 9, 9, 9]], ""output"": [[8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8], [0, 0, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0], [0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 6, 8, 0, 0, 0, 0], [8, 6, 8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8, 6, 8]]}]}"
F3d8EZN82ES2eLGdt4BGS4,2025-07-21T15:52:23.590319,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 1, ""color1"": 3, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 5
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}, {""input"": [[1, 1, 1, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 5, 3, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}, {""input"": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}, {""input"": [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0]]}, {""input"": [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}], ""test"": [{""input"": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}]}"
HCmR2ewNStWHSswQ8D8EKV,2025-07-21T15:52:23.592543,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and green color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 9, ""color1"": 5, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 5
    color2 = 3
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5]]}, {""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5]]}, {""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5]]}], ""test"": [{""input"": [[0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0]]}]}"
AmhJLeQPscXC8xGqgNyS7X,2025-07-21T15:52:23.594754,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and orange color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 5, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 5
    color2 = 7
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1], [0, 1, 0], [0, 1, 0]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0]]}, {""input"": [[1, 0, 0], [1, 0, 0], [1, 1, 1]], ""output"": [[5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}, {""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}], ""test"": [{""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[5, 7, 0, 0, 5, 7], [7, 5, 0, 0, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [5, 7, 0, 0, 5, 7], [7, 5, 0, 0, 7, 5]]}]}"
HP9A9DDb5WduBRvgSPyFov,2025-07-21T15:52:23.597081,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 9, ""color1"": 3, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 3
    color2 = 8
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9]], ""output"": [[3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[9, 0, 0, 0, 9], [0, 9, 0, 9, 0], [0, 0, 9, 0, 0], [0, 9, 0, 9, 0], [9, 0, 0, 0, 9]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [0, 0, 3, 8, 0, 0, 3, 8, 0, 0], [0, 0, 8, 3, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 3, 8, 0, 0, 3, 8, 0, 0], [0, 0, 8, 3, 0, 0, 8, 3, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3]]}], ""test"": [{""input"": [[0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0]]}]}"
UWTXVK8VbbMrVQL4ttNf7a,2025-07-21T15:52:23.599506,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and yellow color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 8, ""color1"": 9, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 9
    color2 = 4
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 0, 8], [0, 8, 0], [8, 0, 8]], ""output"": [[9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9]]}, {""input"": [[8, 8, 8], [8, 0, 8], [8, 8, 8]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}, {""input"": [[8, 8, 8], [0, 8, 0], [0, 8, 0]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0]]}], ""test"": [{""input"": [[8, 8, 8], [0, 8, 0], [8, 8, 8]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}]}"
mXyRycj9Uupkd7Hyh7nmXa,2025-07-21T15:52:23.600940,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and blue color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 2, ""color1"": 4, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 1
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 0, 0, 0, 2], [0, 2, 0, 2, 0], [0, 0, 2, 0, 0], [0, 2, 0, 2, 0], [2, 0, 0, 0, 2]], ""output"": [[4, 1, 0, 0, 0, 0, 0, 0, 4, 1], [1, 4, 0, 0, 0, 0, 0, 0, 1, 4], [0, 0, 4, 1, 0, 0, 4, 1, 0, 0], [0, 0, 1, 4, 0, 0, 1, 4, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 4, 1, 0, 0, 4, 1, 0, 0], [0, 0, 1, 4, 0, 0, 1, 4, 0, 0], [4, 1, 0, 0, 0, 0, 0, 0, 4, 1], [1, 4, 0, 0, 0, 0, 0, 0, 1, 4]]}, {""input"": [[0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [2, 2, 2, 2, 2], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0]], ""output"": [[0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0]]}, {""input"": [[2, 2, 2, 2, 2], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0]], ""output"": [[4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0]]}, {""input"": [[2, 2, 2, 2, 2], [0, 0, 0, 2, 0], [0, 0, 2, 0, 0], [0, 2, 0, 0, 0], [2, 2, 2, 2, 2]], ""output"": [[4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4], [0, 0, 0, 0, 0, 0, 4, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 4, 0, 0], [0, 0, 0, 0, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 0, 0, 0, 0], [0, 0, 4, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 4, 0, 0, 0, 0, 0, 0], [4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4]]}], ""test"": [{""input"": [[2, 2, 2, 2, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 2, 2, 2, 2]], ""output"": [[4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4], [4, 1, 0, 0, 0, 0, 0, 0, 4, 1], [1, 4, 0, 0, 0, 0, 0, 0, 1, 4], [4, 1, 0, 0, 0, 0, 0, 0, 4, 1], [1, 4, 0, 0, 0, 0, 0, 0, 1, 4], [4, 1, 0, 0, 0, 0, 0, 0, 4, 1], [1, 4, 0, 0, 0, 0, 0, 0, 1, 4], [4, 1, 4, 1, 4, 1, 4, 1, 4, 1], [1, 4, 1, 4, 1, 4, 1, 4, 1, 4]]}]}"
B5XaYwrCFF28eEJDRAFoTd,2025-07-21T15:52:23.602541,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and pink color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 2, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 2
    color2 = 6
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 7, 7], [0, 0, 7], [0, 0, 7]], ""output"": [[2, 6, 2, 6, 2, 6], [6, 2, 6, 2, 6, 2], [0, 0, 0, 0, 2, 6], [0, 0, 0, 0, 6, 2], [0, 0, 0, 0, 2, 6], [0, 0, 0, 0, 6, 2]]}, {""input"": [[7, 0, 7], [0, 7, 0], [7, 0, 7]], ""output"": [[2, 6, 0, 0, 2, 6], [6, 2, 0, 0, 6, 2], [0, 0, 2, 6, 0, 0], [0, 0, 6, 2, 0, 0], [2, 6, 0, 0, 2, 6], [6, 2, 0, 0, 6, 2]]}, {""input"": [[0, 0, 7], [0, 0, 7], [7, 7, 7]], ""output"": [[0, 0, 0, 0, 2, 6], [0, 0, 0, 0, 6, 2], [0, 0, 0, 0, 2, 6], [0, 0, 0, 0, 6, 2], [2, 6, 2, 6, 2, 6], [6, 2, 6, 2, 6, 2]]}, {""input"": [[7, 0, 7], [7, 7, 7], [7, 0, 7]], ""output"": [[2, 6, 0, 0, 2, 6], [6, 2, 0, 0, 6, 2], [2, 6, 2, 6, 2, 6], [6, 2, 6, 2, 6, 2], [2, 6, 0, 0, 2, 6], [6, 2, 0, 0, 6, 2]]}, {""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 2, 6, 0, 0], [0, 0, 6, 2, 0, 0], [2, 6, 2, 6, 2, 6], [6, 2, 6, 2, 6, 2], [0, 0, 2, 6, 0, 0], [0, 0, 6, 2, 0, 0]]}], ""test"": [{""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 2, 6, 0, 0], [0, 0, 6, 2, 0, 0], [2, 6, 2, 6, 2, 6], [6, 2, 6, 2, 6, 2], [0, 0, 2, 6, 0, 0], [0, 0, 6, 2, 0, 0]]}]}"
ZECeTRzQEPAU8RaECqvfU4,2025-07-21T15:52:23.603850,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 6, ""color1"": 3, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 3
    color2 = 8
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6, 6], [0, 0, 0, 0, 6], [0, 0, 0, 0, 6], [0, 0, 0, 0, 6], [0, 0, 0, 0, 6]], ""output"": [[3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 3]]}, {""input"": [[6, 6, 6, 6, 6], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0]], ""output"": [[3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0]]}, {""input"": [[6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3]]}], ""test"": [{""input"": [[6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3]]}]}"
G4EKCTwj45d49pvNhgHaXU,2025-07-21T15:52:23.605455,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and orange color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 1, ""color1"": 3, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 3
    color2 = 7
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3], [3, 7, 0, 0, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 0, 0, 7, 3], [3, 7, 0, 0, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 0, 0, 7, 3], [3, 7, 0, 0, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 0, 0, 7, 3], [3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3]]}, {""input"": [[0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 3], [3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3], [0, 0, 0, 0, 3, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0, 0, 0]]}, {""input"": [[1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 1]], ""output"": [[3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3]]}], ""test"": [{""input"": [[1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 1]], ""output"": [[3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 7, 3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3, 7, 3]]}]}"
GQvb2DFRCpGPJfpMwknMNU,2025-07-21T15:52:23.607810,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 2, ""color1"": 3, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 5
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2, 2], [0, 0, 2, 0], [0, 2, 0, 0], [2, 2, 2, 2]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 5, 3, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}, {""input"": [[0, 0, 2, 0], [0, 0, 2, 0], [2, 2, 2, 2], [0, 0, 2, 0]], ""output"": [[0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0]]}, {""input"": [[2, 0, 0, 2], [0, 2, 2, 0], [0, 2, 2, 0], [2, 0, 0, 2]], ""output"": [[3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3], [0, 0, 3, 5, 3, 5, 0, 0], [0, 0, 5, 3, 5, 3, 0, 0], [0, 0, 3, 5, 3, 5, 0, 0], [0, 0, 5, 3, 5, 3, 0, 0], [3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3]]}, {""input"": [[0, 0, 2, 0], [0, 0, 2, 0], [2, 2, 2, 2], [0, 0, 2, 0]], ""output"": [[0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0]]}], ""test"": [{""input"": [[2, 2, 2, 2], [0, 0, 0, 2], [0, 0, 0, 2], [0, 0, 0, 2]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 5, 3]]}]}"
5ipLs8ySrntVtSCZdUjoYy,2025-07-21T15:52:23.609530,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and maroon color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 2, ""color1"": 6, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 6
    color2 = 9
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2], [0, 2, 0], [0, 2, 0]], ""output"": [[6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6], [0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0], [0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0]]}, {""input"": [[2, 2, 2], [2, 0, 2], [2, 2, 2]], ""output"": [[6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6], [6, 9, 0, 0, 6, 9], [9, 6, 0, 0, 9, 6], [6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6]]}, {""input"": [[0, 2, 0], [2, 2, 2], [0, 2, 0]], ""output"": [[0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0], [6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6], [0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0]]}, {""input"": [[2, 2, 2], [2, 0, 2], [2, 2, 2]], ""output"": [[6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6], [6, 9, 0, 0, 6, 9], [9, 6, 0, 0, 9, 6], [6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6]]}], ""test"": [{""input"": [[2, 0, 0], [2, 0, 0], [2, 2, 2]], ""output"": [[6, 9, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6]]}]}"
D2ZTCvqkwy7g8hQYBR2yUu,2025-07-21T15:52:23.611134,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and red color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 1, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 1
    color2 = 2
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 4, 0, 0], [4, 4, 4, 4]], ""output"": [[1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0, 0, 0], [0, 0, 2, 1, 0, 0, 0, 0], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1]]}, {""input"": [[0, 0, 4, 0], [0, 0, 4, 0], [4, 4, 4, 4], [0, 0, 4, 0]], ""output"": [[0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0]]}, {""input"": [[0, 0, 4, 0], [0, 0, 4, 0], [4, 4, 4, 4], [0, 0, 4, 0]], ""output"": [[0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0]]}, {""input"": [[4, 0, 0, 4], [0, 4, 4, 0], [0, 4, 4, 0], [4, 0, 0, 4]], ""output"": [[1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [0, 0, 1, 2, 1, 2, 0, 0], [0, 0, 2, 1, 2, 1, 0, 0], [0, 0, 1, 2, 1, 2, 0, 0], [0, 0, 2, 1, 2, 1, 0, 0], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1]]}], ""test"": [{""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1]]}]}"
AUEejgubJAyaULYN6WprZR,2025-07-21T15:52:23.612917,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and green color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 6, ""color1"": 8, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 3
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 6, 0], [6, 6, 6], [0, 6, 0]], ""output"": [[0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0]]}, {""input"": [[6, 6, 6], [6, 0, 6], [6, 6, 6]], ""output"": [[8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [8, 3, 0, 0, 8, 3], [3, 8, 0, 0, 3, 8], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8]]}, {""input"": [[6, 6, 6], [0, 6, 0], [0, 6, 0]], ""output"": [[8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0]]}, {""input"": [[0, 6, 0], [6, 6, 6], [0, 6, 0]], ""output"": [[0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0]]}, {""input"": [[0, 0, 6], [0, 0, 6], [6, 6, 6]], ""output"": [[0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 3, 8], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8]]}], ""test"": [{""input"": [[6, 0, 0], [6, 0, 0], [6, 6, 6]], ""output"": [[8, 3, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8]]}]}"
ZYjrrEVPDG6NfK9KTvHEuY,2025-07-21T15:52:23.614343,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and blue color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 5, ""color1"": 7, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 1
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0]]}, {""input"": [[0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0]]}, {""input"": [[5, 5, 5, 5, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7]]}], ""test"": [{""input"": [[5, 5, 5, 5, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7]]}]}"
XhsaHA4rMy4ks6C74mPhTD,2025-07-21T15:52:23.615814,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and pink color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 7, ""color1"": 5, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 5
    color2 = 6
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 7, 7, 7], [7, 0, 0, 7], [7, 0, 0, 7], [7, 7, 7, 7]], ""output"": [[5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5]]}, {""input"": [[7, 0, 0, 0], [7, 0, 0, 0], [7, 0, 0, 0], [7, 7, 7, 7]], ""output"": [[5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5]]}, {""input"": [[7, 0, 0, 0], [7, 0, 0, 0], [7, 0, 0, 0], [7, 7, 7, 7]], ""output"": [[5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5]]}, {""input"": [[7, 7, 7, 7], [0, 0, 7, 0], [0, 7, 0, 0], [7, 7, 7, 7]], ""output"": [[5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 5, 6, 0, 0, 0, 0], [0, 0, 6, 5, 0, 0, 0, 0], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5]]}], ""test"": [{""input"": [[7, 0, 0, 7], [7, 0, 0, 7], [7, 7, 7, 7], [7, 0, 0, 7]], ""output"": [[5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5]]}]}"
ZD3RE8rnNqRHeJkhJeiWnn,2025-07-21T15:52:23.617201,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and cyan color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 3, ""color1"": 4, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 4
    color2 = 8
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 3, 0], [0, 0, 3, 0], [3, 3, 3, 3], [0, 0, 3, 0]], ""output"": [[0, 0, 0, 0, 4, 8, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0], [0, 0, 0, 0, 4, 8, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0], [4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4], [0, 0, 0, 0, 4, 8, 0, 0], [0, 0, 0, 0, 8, 4, 0, 0]]}, {""input"": [[3, 3, 3, 3], [3, 0, 0, 3], [3, 0, 0, 3], [3, 3, 3, 3]], ""output"": [[4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4]]}, {""input"": [[3, 0, 0, 3], [0, 3, 3, 0], [0, 3, 3, 0], [3, 0, 0, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [0, 0, 4, 8, 4, 8, 0, 0], [0, 0, 8, 4, 8, 4, 0, 0], [0, 0, 4, 8, 4, 8, 0, 0], [0, 0, 8, 4, 8, 4, 0, 0], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4]]}, {""input"": [[3, 0, 0, 3], [0, 3, 3, 0], [0, 3, 3, 0], [3, 0, 0, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [0, 0, 4, 8, 4, 8, 0, 0], [0, 0, 8, 4, 8, 4, 0, 0], [0, 0, 4, 8, 4, 8, 0, 0], [0, 0, 8, 4, 8, 4, 0, 0], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4]]}, {""input"": [[3, 0, 0, 3], [3, 0, 0, 3], [3, 3, 3, 3], [3, 0, 0, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4], [4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4], [4, 8, 0, 0, 0, 0, 4, 8], [8, 4, 0, 0, 0, 0, 8, 4]]}], ""test"": [{""input"": [[3, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [3, 3, 3, 3]], ""output"": [[4, 8, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0, 0, 0], [4, 8, 4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4, 8, 4]]}]}"
YXatEfAMgL9RJu4m3rrzHJ,2025-07-21T15:52:23.618612,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and yellow color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 2, ""color1"": 3, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 4
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2, 2], [0, 0, 2, 0], [0, 0, 2, 0], [0, 0, 2, 0]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0]]}, {""input"": [[2, 0, 0, 0], [2, 0, 0, 0], [2, 0, 0, 0], [2, 2, 2, 2]], ""output"": [[3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}, {""input"": [[0, 0, 2, 0], [0, 0, 2, 0], [2, 2, 2, 2], [0, 0, 2, 0]], ""output"": [[0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0]]}, {""input"": [[0, 0, 0, 2], [0, 0, 0, 2], [0, 0, 0, 2], [2, 2, 2, 2]], ""output"": [[0, 0, 0, 0, 0, 0, 3, 4], [0, 0, 0, 0, 0, 0, 4, 3], [0, 0, 0, 0, 0, 0, 3, 4], [0, 0, 0, 0, 0, 0, 4, 3], [0, 0, 0, 0, 0, 0, 3, 4], [0, 0, 0, 0, 0, 0, 4, 3], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}], ""test"": [{""input"": [[2, 2, 2, 2], [0, 0, 2, 0], [0, 0, 2, 0], [0, 0, 2, 0]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0]]}]}"
96ZUghKJMgbuomAtxRwHuR,2025-07-21T15:52:23.620020,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and grey color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 2, ""color1"": 6, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 5
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 2, 2, 2, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2]], ""output"": [[6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6]]}, {""input"": [[0, 0, 2, 0, 0], [0, 0, 2, 0, 0], [2, 2, 2, 2, 2], [0, 0, 2, 0, 0], [0, 0, 2, 0, 0]], ""output"": [[0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0], [6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6], [0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0]]}, {""input"": [[2, 2, 2, 2, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 2, 2, 2, 2]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6]]}, {""input"": [[0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [2, 2, 2, 2, 2]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 6, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6]]}, {""input"": [[2, 2, 2, 2, 2], [0, 0, 0, 2, 0], [0, 0, 2, 0, 0], [0, 2, 0, 0, 0], [2, 2, 2, 2, 2]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6], [0, 0, 0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0], [0, 0, 6, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 6, 0, 0, 0, 0, 0, 0], [6, 5, 6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6, 5, 6]]}], ""test"": [{""input"": [[2, 0, 0, 0, 2], [0, 2, 0, 2, 0], [0, 0, 2, 0, 0], [0, 2, 0, 2, 0], [2, 0, 0, 0, 2]], ""output"": [[6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6], [0, 0, 6, 5, 0, 0, 6, 5, 0, 0], [0, 0, 5, 6, 0, 0, 5, 6, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0, 0], [0, 0, 6, 5, 0, 0, 6, 5, 0, 0], [0, 0, 5, 6, 0, 0, 5, 6, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 0, 0, 5, 6]]}]}"
2MtdsB8qUNqE4n3HVrR8cu,2025-07-21T15:52:23.621530,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and red color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 4, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 4
    color2 = 2
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 2, 4, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4]]}, {""input"": [[6, 6, 6, 6], [0, 0, 0, 6], [0, 0, 0, 6], [0, 0, 0, 6]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2], [0, 0, 0, 0, 0, 0, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2], [0, 0, 0, 0, 0, 0, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2], [0, 0, 0, 0, 0, 0, 2, 4]]}], ""test"": [{""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0]]}]}"
6ZupvvKBpeg7Uvr49KoPMG,2025-07-21T15:52:23.623128,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 6, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 9
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0]]}, {""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0]]}, {""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6]]}], ""test"": [{""input"": [[4, 4, 4, 4, 4], [0, 0, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 0, 0, 6, 9, 0, 0], [0, 0, 0, 0, 0, 0, 9, 6, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 6, 9, 0, 0, 0, 0, 0, 0], [0, 0, 9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6]]}]}"
FwpWavy62TGX5MsE6djoeF,2025-07-21T15:52:23.624587,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and grey color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 9, ""color1"": 1, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 1
    color2 = 5
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9], [9, 0, 0], [9, 0, 0]], ""output"": [[1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0]]}, {""input"": [[9, 0, 9], [9, 9, 9], [9, 0, 9]], ""output"": [[1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1]]}, {""input"": [[9, 0, 9], [0, 9, 0], [9, 0, 9]], ""output"": [[1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1], [0, 0, 1, 5, 0, 0], [0, 0, 5, 1, 0, 0], [1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1]]}, {""input"": [[9, 0, 0], [9, 0, 0], [9, 9, 9]], ""output"": [[1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1]]}], ""test"": [{""input"": [[9, 9, 9], [0, 9, 0], [9, 9, 9]], ""output"": [[1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [0, 0, 1, 5, 0, 0], [0, 0, 5, 1, 0, 0], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1]]}]}"
WLkYrAvpmAjFfF64mEFY6y,2025-07-21T15:52:23.625836,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and orange color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 8, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 7
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 1], [1, 1, 1], [1, 0, 1]], ""output"": [[8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8], [8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8], [8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8]]}, {""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8], [0, 0, 8, 7, 0, 0], [0, 0, 7, 8, 0, 0], [8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8]]}, {""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8], [0, 0, 8, 7, 0, 0], [0, 0, 7, 8, 0, 0], [8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8]]}, {""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8], [0, 0, 8, 7, 0, 0], [0, 0, 7, 8, 0, 0], [8, 7, 0, 0, 8, 7], [7, 8, 0, 0, 7, 8]]}, {""input"": [[1, 0, 0], [1, 0, 0], [1, 1, 1]], ""output"": [[8, 7, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8]]}], ""test"": [{""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8], [0, 0, 8, 7, 0, 0], [0, 0, 7, 8, 0, 0], [8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8]]}]}"
BD33qvmjbUfwZk2VGsKtnA,2025-07-21T15:52:23.627258,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 2, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 2
    color2 = 9
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4]], ""output"": [[2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2]]}, {""input"": [[4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4]], ""output"": [[2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2]]}, {""input"": [[4, 4, 4, 4, 4], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0]], ""output"": [[2, 9, 2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2, 9, 2], [2, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0, 0, 0]]}, {""input"": [[4, 0, 0, 0, 4], [0, 4, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 4, 0], [4, 0, 0, 0, 4]], ""output"": [[2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [0, 0, 2, 9, 0, 0, 2, 9, 0, 0], [0, 0, 9, 2, 0, 0, 9, 2, 0, 0], [0, 0, 0, 0, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0, 0, 0], [0, 0, 2, 9, 0, 0, 2, 9, 0, 0], [0, 0, 9, 2, 0, 0, 9, 2, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2]]}], ""test"": [{""input"": [[4, 0, 0, 0, 4], [0, 4, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 4, 0], [4, 0, 0, 0, 4]], ""output"": [[2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2], [0, 0, 2, 9, 0, 0, 2, 9, 0, 0], [0, 0, 9, 2, 0, 0, 9, 2, 0, 0], [0, 0, 0, 0, 2, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0, 0, 0], [0, 0, 2, 9, 0, 0, 2, 9, 0, 0], [0, 0, 9, 2, 0, 0, 9, 2, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 0, 0, 9, 2]]}]}"
itKyBQT7gC4FXZ24q2Uo5J,2025-07-21T15:52:23.628784,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and blue color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 2, ""color1"": 7, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 7
    color2 = 1
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2], [0, 2, 0], [0, 2, 0]], ""output"": [[7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0]]}, {""input"": [[2, 0, 2], [0, 2, 0], [2, 0, 2]], ""output"": [[7, 1, 0, 0, 7, 1], [1, 7, 0, 0, 1, 7], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0], [7, 1, 0, 0, 7, 1], [1, 7, 0, 0, 1, 7]]}, {""input"": [[2, 2, 2], [0, 2, 0], [0, 2, 0]], ""output"": [[7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0]]}], ""test"": [{""input"": [[2, 2, 2], [0, 2, 0], [2, 2, 2]], ""output"": [[7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7], [0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0], [7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7]]}]}"
7QfxC5PVKbv6idYC7Xw2oi,2025-07-21T15:52:23.630371,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 7, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 7
    color2 = 5
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 5, 7, 0, 0, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[7, 5, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7]]}, {""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7], [0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 5, 7, 0, 0, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7]]}], ""test"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 0, 0, 0, 0, 7, 5], [5, 7, 0, 0, 0, 0, 5, 7], [7, 5, 0, 0, 0, 0, 7, 5], [5, 7, 0, 0, 0, 0, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7]]}]}"
9Ed3n3Yg7NM6njkBcAz7q8,2025-07-21T15:52:23.631883,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and cyan color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 4, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 4
    color2 = 8
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 7, 7], [0, 7, 0], [7, 7, 7]], ""output"": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4], [0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0], [4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4]]}, {""input"": [[7, 7, 7], [7, 0, 0], [7, 0, 0]], ""output"": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4], [4, 8, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0]]}, {""input"": [[7, 0, 7], [0, 7, 0], [7, 0, 7]], ""output"": [[4, 8, 0, 0, 4, 8], [8, 4, 0, 0, 8, 4], [0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0], [4, 8, 0, 0, 4, 8], [8, 4, 0, 0, 8, 4]]}, {""input"": [[7, 7, 7], [0, 7, 0], [0, 7, 0]], ""output"": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4], [0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0], [0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0]]}, {""input"": [[7, 7, 7], [7, 0, 7], [7, 7, 7]], ""output"": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4], [4, 8, 0, 0, 4, 8], [8, 4, 0, 0, 8, 4], [4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4]]}], ""test"": [{""input"": [[7, 7, 7], [0, 7, 0], [7, 7, 7]], ""output"": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4], [0, 0, 4, 8, 0, 0], [0, 0, 8, 4, 0, 0], [4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4]]}]}"
KZHVwX6Niii46WAMNL2CPL,2025-07-21T15:52:23.633170,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and green color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 5, ""color1"": 8, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 3
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 5, 0], [5, 5, 5], [0, 5, 0]], ""output"": [[0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0]]}, {""input"": [[0, 5, 0], [5, 5, 5], [0, 5, 0]], ""output"": [[0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0]]}, {""input"": [[5, 0, 5], [5, 5, 5], [5, 0, 5]], ""output"": [[8, 3, 0, 0, 8, 3], [3, 8, 0, 0, 3, 8], [8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8], [8, 3, 0, 0, 8, 3], [3, 8, 0, 0, 3, 8]]}], ""test"": [{""input"": [[5, 0, 5], [0, 5, 0], [5, 0, 5]], ""output"": [[8, 3, 0, 0, 8, 3], [3, 8, 0, 0, 3, 8], [0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0], [8, 3, 0, 0, 8, 3], [3, 8, 0, 0, 3, 8]]}]}"
TjuqBNDeKPbAaecBjwPiBR,2025-07-21T15:52:23.634492,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and blue color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 5, ""color1"": 2, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 2
    color2 = 1
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 0, 5], [0, 5, 0], [5, 0, 5]], ""output"": [[2, 1, 0, 0, 2, 1], [1, 2, 0, 0, 1, 2], [0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0], [2, 1, 0, 0, 2, 1], [1, 2, 0, 0, 1, 2]]}, {""input"": [[0, 5, 0], [5, 5, 5], [0, 5, 0]], ""output"": [[0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0], [2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2], [0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0]]}, {""input"": [[5, 0, 0], [5, 0, 0], [5, 5, 5]], ""output"": [[2, 1, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0], [2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2]]}], ""test"": [{""input"": [[5, 5, 5], [0, 5, 0], [5, 5, 5]], ""output"": [[2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2], [0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0], [2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2]]}]}"
cKHAzWzJvLrMDGbz2ADBfW,2025-07-21T15:52:23.635996,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and maroon color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 3, ""color1"": 8, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 9
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 3, 3], [3, 0, 3], [3, 3, 3]], ""output"": [[8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8], [8, 9, 0, 0, 8, 9], [9, 8, 0, 0, 9, 8], [8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8]]}, {""input"": [[3, 3, 3], [3, 0, 3], [3, 3, 3]], ""output"": [[8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8], [8, 9, 0, 0, 8, 9], [9, 8, 0, 0, 9, 8], [8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8]]}, {""input"": [[0, 3, 0], [3, 3, 3], [0, 3, 0]], ""output"": [[0, 0, 8, 9, 0, 0], [0, 0, 9, 8, 0, 0], [8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8], [0, 0, 8, 9, 0, 0], [0, 0, 9, 8, 0, 0]]}, {""input"": [[3, 3, 3], [0, 3, 0], [3, 3, 3]], ""output"": [[8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8], [0, 0, 8, 9, 0, 0], [0, 0, 9, 8, 0, 0], [8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8]]}], ""test"": [{""input"": [[3, 3, 3], [0, 3, 0], [3, 3, 3]], ""output"": [[8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8], [0, 0, 8, 9, 0, 0], [0, 0, 9, 8, 0, 0], [8, 9, 8, 9, 8, 9], [9, 8, 9, 8, 9, 8]]}]}"
CvYmak8MAxgqezApRfeUZy,2025-07-21T15:52:23.637266,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and cyan color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 9, ""color1"": 5, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 5
    color2 = 8
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 9, 0, 0], [9, 9, 9, 9]], ""output"": [[5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 5, 8, 0, 0, 0, 0], [0, 0, 8, 5, 0, 0, 0, 0], [5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5]]}, {""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 0, 9, 0], [0, 0, 9, 0]], ""output"": [[5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0]]}, {""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 0, 9, 0], [0, 0, 9, 0]], ""output"": [[5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 0, 5, 8, 0, 0], [0, 0, 0, 0, 8, 5, 0, 0]]}, {""input"": [[9, 0, 0, 0], [9, 0, 0, 0], [9, 0, 0, 0], [9, 9, 9, 9]], ""output"": [[5, 8, 0, 0, 0, 0, 0, 0], [8, 5, 0, 0, 0, 0, 0, 0], [5, 8, 0, 0, 0, 0, 0, 0], [8, 5, 0, 0, 0, 0, 0, 0], [5, 8, 0, 0, 0, 0, 0, 0], [8, 5, 0, 0, 0, 0, 0, 0], [5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5]]}], ""test"": [{""input"": [[0, 0, 0, 9], [0, 0, 0, 9], [0, 0, 0, 9], [9, 9, 9, 9]], ""output"": [[0, 0, 0, 0, 0, 0, 5, 8], [0, 0, 0, 0, 0, 0, 8, 5], [0, 0, 0, 0, 0, 0, 5, 8], [0, 0, 0, 0, 0, 0, 8, 5], [0, 0, 0, 0, 0, 0, 5, 8], [0, 0, 0, 0, 0, 0, 8, 5], [5, 8, 5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5, 8, 5]]}]}"
D6q5dFaWZVmdFeudFfwDwX,2025-07-21T15:52:23.638766,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and grey color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 6, ""color1"": 2, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 2
    color2 = 5
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6, 6], [0, 0, 0, 6, 0], [0, 0, 6, 0, 0], [0, 6, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [0, 0, 0, 0, 0, 0, 2, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 2, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 2, 0, 0, 0, 0, 0, 0], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2]]}, {""input"": [[6, 6, 6, 6, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 6, 6, 6, 6]], ""output"": [[2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2]]}, {""input"": [[6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6]], ""output"": [[2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2]]}, {""input"": [[0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [6, 6, 6, 6, 6], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0]], ""output"": [[0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0]]}, {""input"": [[6, 0, 0, 0, 6], [6, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 0, 0, 0, 6], [6, 0, 0, 0, 6]], ""output"": [[2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2]]}], ""test"": [{""input"": [[6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2]]}]}"
hrbsg3EkzS9GzeTwxq3dt2,2025-07-21T15:52:23.640949,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and green color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 7, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 7
    color2 = 3
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7], [7, 3, 0, 0, 7, 3], [3, 7, 0, 0, 3, 7], [7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7]]}, {""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7], [0, 0, 7, 3, 0, 0], [0, 0, 3, 7, 0, 0], [7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7]]}, {""input"": [[0, 0, 1], [0, 0, 1], [1, 1, 1]], ""output"": [[0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7]]}, {""input"": [[0, 0, 1], [0, 0, 1], [1, 1, 1]], ""output"": [[0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7]]}], ""test"": [{""input"": [[0, 0, 1], [0, 0, 1], [1, 1, 1]], ""output"": [[0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [0, 0, 0, 0, 7, 3], [0, 0, 0, 0, 3, 7], [7, 3, 7, 3, 7, 3], [3, 7, 3, 7, 3, 7]]}]}"
Pm6MKjhUDVAKHQLZb7jSrv,2025-07-21T15:52:23.642825,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 1, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 1
    color2 = 5
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0]], ""output"": [[1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1], [0, 0, 0, 0, 1, 5, 0, 0], [0, 0, 0, 0, 5, 1, 0, 0], [0, 0, 1, 5, 0, 0, 0, 0], [0, 0, 5, 1, 0, 0, 0, 0], [1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1]]}, {""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 0, 0, 1, 5], [5, 1, 0, 0, 0, 0, 5, 1], [1, 5, 0, 0, 0, 0, 1, 5], [5, 1, 0, 0, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1]]}], ""test"": [{""input"": [[6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6], [6, 0, 0, 6]], ""output"": [[1, 5, 0, 0, 0, 0, 1, 5], [5, 1, 0, 0, 0, 0, 5, 1], [1, 5, 0, 0, 0, 0, 1, 5], [5, 1, 0, 0, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 0, 0, 1, 5], [5, 1, 0, 0, 0, 0, 5, 1]]}]}"
Dx4TJgq3DwHoicrGvUV49W,2025-07-21T15:52:23.645372,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and pink color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 1, ""color1"": 9, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 9
    color2 = 6
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]], ""output"": [[9, 6, 0, 0, 0, 0, 9, 6], [6, 9, 0, 0, 0, 0, 6, 9], [0, 0, 9, 6, 9, 6, 0, 0], [0, 0, 6, 9, 6, 9, 0, 0], [0, 0, 9, 6, 9, 6, 0, 0], [0, 0, 6, 9, 6, 9, 0, 0], [9, 6, 0, 0, 0, 0, 9, 6], [6, 9, 0, 0, 0, 0, 6, 9]]}, {""input"": [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]], ""output"": [[9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0]]}, {""input"": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]], ""output"": [[9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 6, 9, 6, 9, 6, 9]]}], ""test"": [{""input"": [[1, 1, 1, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]], ""output"": [[9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 6, 9, 6, 9, 6, 9], [0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 6, 9]]}]}"
BQjiGQTia68dRhuFqzqhqH,2025-07-21T15:52:23.646901,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 2, ""color1"": 1, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 1
    color2 = 9
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [2, 2, 2, 2, 2]], ""output"": [[1, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 9, 1, 9, 1, 9, 1, 9, 1, 9], [9, 1, 9, 1, 9, 1, 9, 1, 9, 1]]}, {""input"": [[2, 2, 2, 2, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 2, 2, 2, 2]], ""output"": [[1, 9, 1, 9, 1, 9, 1, 9, 1, 9], [9, 1, 9, 1, 9, 1, 9, 1, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 1, 9, 1, 9, 1, 9, 1, 9], [9, 1, 9, 1, 9, 1, 9, 1, 9, 1]]}, {""input"": [[2, 0, 0, 0, 2], [0, 2, 0, 2, 0], [0, 0, 2, 0, 0], [0, 2, 0, 2, 0], [2, 0, 0, 0, 2]], ""output"": [[1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [0, 0, 1, 9, 0, 0, 1, 9, 0, 0], [0, 0, 9, 1, 0, 0, 9, 1, 0, 0], [0, 0, 0, 0, 1, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 1, 0, 0, 0, 0], [0, 0, 1, 9, 0, 0, 1, 9, 0, 0], [0, 0, 9, 1, 0, 0, 9, 1, 0, 0], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1]]}], ""test"": [{""input"": [[2, 2, 2, 2, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 0, 0, 0, 2], [2, 2, 2, 2, 2]], ""output"": [[1, 9, 1, 9, 1, 9, 1, 9, 1, 9], [9, 1, 9, 1, 9, 1, 9, 1, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 0, 0, 0, 0, 0, 0, 1, 9], [9, 1, 0, 0, 0, 0, 0, 0, 9, 1], [1, 9, 1, 9, 1, 9, 1, 9, 1, 9], [9, 1, 9, 1, 9, 1, 9, 1, 9, 1]]}]}"
Z6LBXmJ6H57FXg8dtPxj8B,2025-07-21T15:52:23.648477,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and pink color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 5, ""color1"": 8, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 6
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5], [5, 0, 5], [5, 5, 5]], ""output"": [[8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8], [8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8], [8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8]]}, {""input"": [[5, 0, 5], [5, 5, 5], [5, 0, 5]], ""output"": [[8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8], [8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8], [8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8]]}, {""input"": [[5, 5, 5], [5, 0, 5], [5, 5, 5]], ""output"": [[8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8], [8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8], [8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8]]}, {""input"": [[5, 0, 0], [5, 0, 0], [5, 5, 5]], ""output"": [[8, 6, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0], [8, 6, 8, 6, 8, 6], [6, 8, 6, 8, 6, 8]]}], ""test"": [{""input"": [[5, 0, 5], [0, 5, 0], [5, 0, 5]], ""output"": [[8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8], [0, 0, 8, 6, 0, 0], [0, 0, 6, 8, 0, 0], [8, 6, 0, 0, 8, 6], [6, 8, 0, 0, 6, 8]]}]}"
7f2BjW6hxgNRKZgQgZ959U,2025-07-21T15:52:23.649886,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and blue color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 3, ""color1"": 6, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 1
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 0, 0, 0, 3], [0, 3, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 3, 0], [3, 0, 0, 0, 3]], ""output"": [[6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6]]}, {""input"": [[3, 0, 0, 0, 3], [0, 3, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 3, 0], [3, 0, 0, 0, 3]], ""output"": [[6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6]]}, {""input"": [[3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 3, 3, 3, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3]], ""output"": [[6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1], [1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6]]}], ""test"": [{""input"": [[3, 0, 0, 0, 3], [0, 3, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 3, 0], [3, 0, 0, 0, 3]], ""output"": [[6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6]]}]}"
PUBp6M88GffvHf92aaiYo5,2025-07-21T15:52:23.651420,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 1, ""color1"": 5, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 5
    color2 = 9
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [1, 1, 1, 1, 1]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [0, 0, 0, 0, 0, 0, 5, 9, 0, 0], [0, 0, 0, 0, 0, 0, 9, 5, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 5, 9, 0, 0, 0, 0, 0, 0], [0, 0, 9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0]]}, {""input"": [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0, 0, 0]]}], ""test"": [{""input"": [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 0, 0, 9, 5], [5, 9, 5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5, 9, 5]]}]}"
JSGxTS5FiFuxQAwJACQJnK,2025-07-21T15:52:23.652995,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 5, ""color1"": 4, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 2
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5, 5], [0, 0, 0, 5, 0], [0, 0, 5, 0, 0], [0, 5, 0, 0, 0], [5, 5, 5, 5, 5]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4]]}, {""input"": [[5, 0, 0, 0, 5], [0, 5, 0, 5, 0], [0, 0, 5, 0, 0], [0, 5, 0, 5, 0], [5, 0, 0, 0, 5]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4]]}, {""input"": [[5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 5, 5, 5, 5]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4]]}], ""test"": [{""input"": [[5, 0, 0, 0, 5], [0, 5, 0, 5, 0], [0, 0, 5, 0, 0], [0, 5, 0, 5, 0], [5, 0, 0, 0, 5]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4]]}]}"
RWwYtESD7F3NZjYSdrMPpA,2025-07-21T15:52:23.654501,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and orange color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 3, ""color1"": 5, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 5
    color2 = 7
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 3, 3], [0, 3, 0], [3, 3, 3]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}, {""input"": [[3, 0, 0], [3, 0, 0], [3, 3, 3]], ""output"": [[5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}, {""input"": [[3, 0, 0], [3, 0, 0], [3, 3, 3]], ""output"": [[5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}], ""test"": [{""input"": [[3, 3, 3], [0, 3, 0], [0, 3, 0]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0]]}]}"
7ii4Nxk8vVTiUZ58pwC9gV,2025-07-21T15:52:23.655772,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and orange color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 4, ""color1"": 2, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 2
    color2 = 7
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 0, 0], [4, 0, 0], [4, 4, 4]], ""output"": [[2, 7, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0], [2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2]]}, {""input"": [[4, 0, 4], [4, 4, 4], [4, 0, 4]], ""output"": [[2, 7, 0, 0, 2, 7], [7, 2, 0, 0, 7, 2], [2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2], [2, 7, 0, 0, 2, 7], [7, 2, 0, 0, 7, 2]]}, {""input"": [[4, 4, 4], [0, 4, 0], [4, 4, 4]], ""output"": [[2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2], [0, 0, 2, 7, 0, 0], [0, 0, 7, 2, 0, 0], [2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2]]}, {""input"": [[4, 4, 4], [0, 4, 0], [4, 4, 4]], ""output"": [[2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2], [0, 0, 2, 7, 0, 0], [0, 0, 7, 2, 0, 0], [2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2]]}], ""test"": [{""input"": [[0, 4, 0], [4, 4, 4], [0, 4, 0]], ""output"": [[0, 0, 2, 7, 0, 0], [0, 0, 7, 2, 0, 0], [2, 7, 2, 7, 2, 7], [7, 2, 7, 2, 7, 2], [0, 0, 2, 7, 0, 0], [0, 0, 7, 2, 0, 0]]}]}"
mqfHuBpmq6zph8VRiABm5J,2025-07-21T15:52:23.657205,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and yellow color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 3, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 4
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}, {""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [3, 4, 0, 0, 0, 0, 3, 4], [4, 3, 0, 0, 0, 0, 4, 3], [3, 4, 0, 0, 0, 0, 3, 4], [4, 3, 0, 0, 0, 0, 4, 3], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}, {""input"": [[6, 6, 6, 6], [6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0], [3, 4, 0, 0, 0, 0, 0, 0], [4, 3, 0, 0, 0, 0, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [0, 0, 0, 0, 3, 4, 0, 0], [0, 0, 0, 0, 4, 3, 0, 0], [0, 0, 3, 4, 0, 0, 0, 0], [0, 0, 4, 3, 0, 0, 0, 0], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}], ""test"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3], [3, 4, 0, 0, 0, 0, 3, 4], [4, 3, 0, 0, 0, 0, 4, 3], [3, 4, 0, 0, 0, 0, 3, 4], [4, 3, 0, 0, 0, 0, 4, 3], [3, 4, 3, 4, 3, 4, 3, 4], [4, 3, 4, 3, 4, 3, 4, 3]]}]}"
Cze82Yaqofgv55ghJ4WGYZ,2025-07-21T15:52:23.658847,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and green color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 9, ""color1"": 2, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 2
    color2 = 3
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9], [0, 9, 0], [9, 9, 9]], ""output"": [[2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2], [0, 0, 2, 3, 0, 0], [0, 0, 3, 2, 0, 0], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2]]}, {""input"": [[9, 9, 9], [9, 0, 9], [9, 9, 9]], ""output"": [[2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2], [2, 3, 0, 0, 2, 3], [3, 2, 0, 0, 3, 2], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2]]}, {""input"": [[9, 0, 9], [9, 9, 9], [9, 0, 9]], ""output"": [[2, 3, 0, 0, 2, 3], [3, 2, 0, 0, 3, 2], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2], [2, 3, 0, 0, 2, 3], [3, 2, 0, 0, 3, 2]]}, {""input"": [[0, 9, 0], [9, 9, 9], [0, 9, 0]], ""output"": [[0, 0, 2, 3, 0, 0], [0, 0, 3, 2, 0, 0], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2], [0, 0, 2, 3, 0, 0], [0, 0, 3, 2, 0, 0]]}, {""input"": [[9, 9, 9], [0, 9, 0], [9, 9, 9]], ""output"": [[2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2], [0, 0, 2, 3, 0, 0], [0, 0, 3, 2, 0, 0], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2]]}], ""test"": [{""input"": [[9, 0, 0], [9, 0, 0], [9, 9, 9]], ""output"": [[2, 3, 0, 0, 0, 0], [3, 2, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0], [3, 2, 0, 0, 0, 0], [2, 3, 2, 3, 2, 3], [3, 2, 3, 2, 3, 2]]}]}"
fo9AK6PBMxDbnhHWrynxqf,2025-07-21T15:52:23.660255,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and maroon color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 2, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 2
    color2 = 9
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2], [2, 9, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 9, 2], [2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2]]}, {""input"": [[6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6], [6, 0, 0, 6]], ""output"": [[2, 9, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 9, 2], [2, 9, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 9, 2], [2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2], [2, 9, 0, 0, 0, 0, 2, 9], [9, 2, 0, 0, 0, 0, 9, 2]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[2, 9, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0], [2, 9, 0, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 0, 0], [2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2]]}, {""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 2, 9, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0], [0, 0, 0, 0, 2, 9, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0], [2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2], [0, 0, 0, 0, 2, 9, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0]]}], ""test"": [{""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2], [0, 0, 0, 0, 2, 9, 0, 0], [0, 0, 0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0, 0, 0], [0, 0, 9, 2, 0, 0, 0, 0], [2, 9, 2, 9, 2, 9, 2, 9], [9, 2, 9, 2, 9, 2, 9, 2]]}]}"
Bckkz5nGRiFJQMMYwaSGwn,2025-07-21T15:52:23.661595,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and yellow color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 2, ""color1"": 1, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 1
    color2 = 4
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2], [0, 2, 0], [0, 2, 0]], ""output"": [[1, 4, 1, 4, 1, 4], [4, 1, 4, 1, 4, 1], [0, 0, 1, 4, 0, 0], [0, 0, 4, 1, 0, 0], [0, 0, 1, 4, 0, 0], [0, 0, 4, 1, 0, 0]]}, {""input"": [[2, 0, 0], [2, 0, 0], [2, 2, 2]], ""output"": [[1, 4, 0, 0, 0, 0], [4, 1, 0, 0, 0, 0], [1, 4, 0, 0, 0, 0], [4, 1, 0, 0, 0, 0], [1, 4, 1, 4, 1, 4], [4, 1, 4, 1, 4, 1]]}, {""input"": [[2, 0, 0], [2, 0, 0], [2, 2, 2]], ""output"": [[1, 4, 0, 0, 0, 0], [4, 1, 0, 0, 0, 0], [1, 4, 0, 0, 0, 0], [4, 1, 0, 0, 0, 0], [1, 4, 1, 4, 1, 4], [4, 1, 4, 1, 4, 1]]}], ""test"": [{""input"": [[2, 0, 2], [2, 2, 2], [2, 0, 2]], ""output"": [[1, 4, 0, 0, 1, 4], [4, 1, 0, 0, 4, 1], [1, 4, 1, 4, 1, 4], [4, 1, 4, 1, 4, 1], [1, 4, 0, 0, 1, 4], [4, 1, 0, 0, 4, 1]]}]}"
4oTv7pp3tGURRWm8p7DfBm,2025-07-21T15:52:23.663210,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and grey color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 9, ""color1"": 4, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 5
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4], [0, 0, 0, 0, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 4, 0, 0, 0, 0]]}, {""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4]]}, {""input"": [[0, 0, 0, 0, 9], [0, 0, 0, 0, 9], [0, 0, 0, 0, 9], [0, 0, 0, 0, 9], [9, 9, 9, 9, 9]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4]]}, {""input"": [[9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9]], ""output"": [[4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4]]}, {""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4]]}], ""test"": [{""input"": [[9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9]], ""output"": [[4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 0, 0, 0, 0, 0, 0, 4, 5], [5, 4, 0, 0, 0, 0, 0, 0, 5, 4], [4, 5, 4, 5, 4, 5, 4, 5, 4, 5], [5, 4, 5, 4, 5, 4, 5, 4, 5, 4]]}]}"
iKQYvWof8eSXrmX3CcpcEE,2025-07-21T15:52:23.664948,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and cyan color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 3, ""color1"": 7, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 7
    color2 = 8
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 3, 3], [0, 3, 0], [3, 3, 3]], ""output"": [[7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7], [0, 0, 7, 8, 0, 0], [0, 0, 8, 7, 0, 0], [7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7]]}, {""input"": [[3, 0, 3], [0, 3, 0], [3, 0, 3]], ""output"": [[7, 8, 0, 0, 7, 8], [8, 7, 0, 0, 8, 7], [0, 0, 7, 8, 0, 0], [0, 0, 8, 7, 0, 0], [7, 8, 0, 0, 7, 8], [8, 7, 0, 0, 8, 7]]}, {""input"": [[3, 3, 3], [3, 0, 0], [3, 0, 0]], ""output"": [[7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7], [7, 8, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0], [7, 8, 0, 0, 0, 0], [8, 7, 0, 0, 0, 0]]}], ""test"": [{""input"": [[3, 3, 3], [0, 3, 0], [0, 3, 0]], ""output"": [[7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7], [0, 0, 7, 8, 0, 0], [0, 0, 8, 7, 0, 0], [0, 0, 7, 8, 0, 0], [0, 0, 8, 7, 0, 0]]}]}"
JfKtaSfiU6qEi75s99ZnLC,2025-07-21T15:52:23.666298,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and orange color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 6, ""color1"": 5, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 5
    color2 = 7
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [6, 6, 6, 6, 6], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0]], ""output"": [[0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0]]}, {""input"": [[6, 0, 0, 0, 6], [0, 6, 0, 6, 0], [0, 0, 6, 0, 0], [0, 6, 0, 6, 0], [6, 0, 0, 0, 6]], ""output"": [[5, 7, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 0, 0, 0, 0, 0, 0, 7, 5], [0, 0, 5, 7, 0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 5, 7, 0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0, 7, 5, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 0, 0, 0, 0, 0, 0, 7, 5]]}, {""input"": [[6, 6, 6, 6, 6], [0, 0, 0, 6, 0], [0, 0, 6, 0, 0], [0, 6, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [0, 0, 0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 5, 7, 0, 0, 0, 0, 0, 0], [0, 0, 7, 5, 0, 0, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5]]}, {""input"": [[6, 6, 6, 6, 6], [0, 0, 0, 6, 0], [0, 0, 6, 0, 0], [0, 6, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [0, 0, 0, 0, 0, 0, 5, 7, 0, 0], [0, 0, 0, 0, 0, 0, 7, 5, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 5, 7, 0, 0, 0, 0, 0, 0], [0, 0, 7, 5, 0, 0, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5]]}, {""input"": [[6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 0, 0, 0, 0], [6, 6, 6, 6, 6]], ""output"": [[5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5]]}], ""test"": [{""input"": [[6, 6, 6, 6, 6], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0], [0, 0, 6, 0, 0]], ""output"": [[5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0]]}]}"
ejrAK3afWqo6zqX7CLXFRM,2025-07-21T15:52:23.667829,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely red color and yellow color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 5, ""color1"": 2, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 2
    color2 = 4
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5], [0, 0, 5, 0], [0, 5, 0, 0], [5, 5, 5, 5]], ""output"": [[2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 0, 0], [2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2]]}, {""input"": [[5, 5, 5, 5], [0, 0, 5, 0], [0, 0, 5, 0], [0, 0, 5, 0]], ""output"": [[2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0]]}, {""input"": [[5, 0, 0, 5], [5, 0, 0, 5], [5, 5, 5, 5], [5, 0, 0, 5]], ""output"": [[2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2]]}, {""input"": [[5, 0, 0, 5], [5, 0, 0, 5], [5, 5, 5, 5], [5, 0, 0, 5]], ""output"": [[2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 4, 2]]}, {""input"": [[5, 5, 5, 5], [0, 0, 5, 0], [0, 0, 5, 0], [0, 0, 5, 0]], ""output"": [[2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0]]}], ""test"": [{""input"": [[0, 0, 5, 0], [0, 0, 5, 0], [5, 5, 5, 5], [0, 0, 5, 0]], ""output"": [[0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0], [2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2], [0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0]]}]}"
gY7cQhf2zyScX5iXhdW2DU,2025-07-21T15:52:23.669455,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and grey color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 7, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 5
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [0, 0, 0, 0, 4], [4, 4, 4, 4, 4]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 7, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7]]}, {""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7]]}, {""input"": [[4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4]], ""output"": [[7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [7, 5, 0, 0, 0, 0, 0, 0, 7, 5], [5, 7, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 0, 0, 0, 0, 0, 0, 7, 5], [5, 7, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 0, 0, 0, 0, 0, 0, 7, 5], [5, 7, 0, 0, 0, 0, 0, 0, 5, 7], [7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7]]}], ""test"": [{""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[7, 5, 7, 5, 7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7, 5, 7, 5, 7], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0, 0]]}]}"
hjaMoC5uLEXh5xrznYTNbt,2025-07-21T15:52:23.671024,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 6, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 6
    color2 = 5
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 4, 0, 0], [4, 4, 4, 4]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 5, 6, 0, 0, 0, 0], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6]]}, {""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 4, 0, 0], [4, 4, 4, 4]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [0, 0, 0, 0, 6, 5, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0], [0, 0, 6, 5, 0, 0, 0, 0], [0, 0, 5, 6, 0, 0, 0, 0], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6]]}, {""input"": [[4, 4, 4, 4], [4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6]]}], ""test"": [{""input"": [[4, 4, 4, 4], [4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4]], ""output"": [[6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 0, 0, 0, 0, 6, 5], [5, 6, 0, 0, 0, 0, 5, 6], [6, 5, 6, 5, 6, 5, 6, 5], [5, 6, 5, 6, 5, 6, 5, 6]]}]}"
5nEv4zmsKvmkvd8WCBUV72,2025-07-21T15:52:23.672536,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 8, ""color1"": 6, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 9
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 8, 8, 8, 8], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0]]}, {""input"": [[8, 8, 8, 8, 8], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0]]}, {""input"": [[8, 8, 8, 8, 8], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0]]}], ""test"": [{""input"": [[8, 8, 8, 8, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6]]}]}"
HVguXkF5jJDtVyMLkh3Ame,2025-07-21T15:52:23.674054,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and red color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 1, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 1
    color2 = 2
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 1, 2, 0, 0, 0, 0], [0, 0, 2, 1, 0, 0, 0, 0], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1]]}, {""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1]]}, {""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1]]}, {""input"": [[6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6], [6, 0, 0, 6]], ""output"": [[1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [1, 2, 1, 2, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1, 2, 1], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1]]}], ""test"": [{""input"": [[6, 0, 0, 6], [0, 6, 6, 0], [0, 6, 6, 0], [6, 0, 0, 6]], ""output"": [[1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1], [0, 0, 1, 2, 1, 2, 0, 0], [0, 0, 2, 1, 2, 1, 0, 0], [0, 0, 1, 2, 1, 2, 0, 0], [0, 0, 2, 1, 2, 1, 0, 0], [1, 2, 0, 0, 0, 0, 1, 2], [2, 1, 0, 0, 0, 0, 2, 1]]}]}"
ThVtoFHBkLMFWjuiDZQtzi,2025-07-21T15:52:23.675446,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 6, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 8
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 6, 8, 6, 8, 6, 8, 6, 8], [8, 6, 8, 6, 8, 6, 8, 6, 8, 6]]}, {""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [6, 8, 6, 8, 6, 8, 6, 8, 6, 8], [8, 6, 8, 6, 8, 6, 8, 6, 8, 6], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0]]}, {""input"": [[4, 0, 0, 0, 4], [0, 4, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 4, 0], [4, 0, 0, 0, 4]], ""output"": [[6, 8, 0, 0, 0, 0, 0, 0, 6, 8], [8, 6, 0, 0, 0, 0, 0, 0, 8, 6], [0, 0, 6, 8, 0, 0, 6, 8, 0, 0], [0, 0, 8, 6, 0, 0, 8, 6, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 6, 8, 0, 0, 6, 8, 0, 0], [0, 0, 8, 6, 0, 0, 8, 6, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 6, 8], [8, 6, 0, 0, 0, 0, 0, 0, 8, 6]]}, {""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[6, 8, 6, 8, 6, 8, 6, 8, 6, 8], [8, 6, 8, 6, 8, 6, 8, 6, 8, 6], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 6, 0, 0, 0, 0]]}], ""test"": [{""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 8, 6, 8, 6, 8, 6, 8, 6, 8], [8, 6, 8, 6, 8, 6, 8, 6, 8, 6]]}]}"
UmGFmxb7UgmXLDZJWHgqxr,2025-07-21T15:52:23.676994,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 5, ""color1"": 7, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 2
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}, {""input"": [[5, 5, 5, 5, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}, {""input"": [[5, 5, 5, 5, 5], [0, 0, 0, 5, 0], [0, 0, 5, 0, 0], [0, 5, 0, 0, 0], [5, 5, 5, 5, 5]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [0, 0, 0, 0, 0, 0, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 7, 0, 0], [0, 0, 0, 0, 7, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 7, 0, 0, 0, 0], [0, 0, 7, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}], ""test"": [{""input"": [[5, 5, 5, 5, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 0, 0, 0, 5], [5, 5, 5, 5, 5]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}]}"
3AtDEJB5Y9C6HQWw8T9JUv,2025-07-21T15:52:23.678502,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 8, ""color1"": 3, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 3
    color2 = 2
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 8, 8, 8, 8], [0, 0, 0, 8, 0], [0, 0, 8, 0, 0], [0, 8, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [0, 0, 0, 0, 0, 0, 3, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 3, 0, 0], [0, 0, 0, 0, 3, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 0, 0, 0, 0], [0, 0, 3, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 0, 0, 0, 0, 0, 0], [3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3]]}, {""input"": [[8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 8, 8, 8, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8]], ""output"": [[3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3]]}, {""input"": [[8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[3, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3]]}], ""test"": [{""input"": [[8, 8, 8, 8, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 8, 8, 8, 8]], ""output"": [[3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 0, 0, 0, 0, 0, 0, 3, 2], [2, 3, 0, 0, 0, 0, 0, 0, 2, 3], [3, 2, 3, 2, 3, 2, 3, 2, 3, 2], [2, 3, 2, 3, 2, 3, 2, 3, 2, 3]]}]}"
jJ3mePDTXGgvHNwUAQFuD4,2025-07-21T15:52:23.680123,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and orange color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 1, ""color1"": 3, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 7
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3], [0, 0, 0, 0, 3, 7, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0], [0, 0, 3, 7, 0, 0, 0, 0], [0, 0, 7, 3, 0, 0, 0, 0], [3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3]]}, {""input"": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]], ""output"": [[3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0], [3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3]]}, {""input"": [[0, 0, 1, 0], [0, 0, 1, 0], [1, 1, 1, 1], [0, 0, 1, 0]], ""output"": [[0, 0, 0, 0, 3, 7, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0], [0, 0, 0, 0, 3, 7, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0], [3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3], [0, 0, 0, 0, 3, 7, 0, 0], [0, 0, 0, 0, 7, 3, 0, 0]]}, {""input"": [[1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1], [1, 0, 0, 1]], ""output"": [[3, 7, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 7, 3], [3, 7, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 7, 3], [3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3], [3, 7, 0, 0, 0, 0, 3, 7], [7, 3, 0, 0, 0, 0, 7, 3]]}], ""test"": [{""input"": [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]], ""output"": [[3, 7, 3, 7, 3, 7, 3, 7], [7, 3, 7, 3, 7, 3, 7, 3], [3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0], [3, 7, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 0, 0]]}]}"
7Mb4T7jA2xtfWwJdvy43HS,2025-07-21T15:52:23.682336,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 8, ""color1"": 4, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 2
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 0, 0, 0, 8], [0, 8, 0, 8, 0], [0, 0, 8, 0, 0], [0, 8, 0, 8, 0], [8, 0, 0, 0, 8]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 4, 2, 0, 0], [0, 0, 2, 4, 0, 0, 2, 4, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4]]}, {""input"": [[8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4]]}, {""input"": [[8, 8, 8, 8, 8], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 8, 0, 0]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0]]}, {""input"": [[8, 8, 8, 8, 8], [0, 0, 0, 8, 0], [0, 0, 8, 0, 0], [0, 8, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 4, 0, 0], [0, 0, 0, 0, 4, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 4, 0, 0, 0, 0], [0, 0, 4, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 4, 0, 0, 0, 0, 0, 0], [4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4]]}], ""test"": [{""input"": [[8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 8, 8, 8, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8]], ""output"": [[4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [4, 2, 4, 2, 4, 2, 4, 2, 4, 2], [2, 4, 2, 4, 2, 4, 2, 4, 2, 4], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4], [4, 2, 0, 0, 0, 0, 0, 0, 4, 2], [2, 4, 0, 0, 0, 0, 0, 0, 2, 4]]}]}"
MVXJYtWwiaaCZNQL8LSQcH,2025-07-21T15:52:23.684486,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and green color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 9, ""color1"": 8, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 8
    color2 = 3
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 0, 0, 0, 9], [0, 9, 0, 9, 0], [0, 0, 9, 0, 0], [0, 9, 0, 9, 0], [9, 0, 0, 0, 9]], ""output"": [[8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [0, 0, 8, 3, 0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 8, 3, 0, 0, 8, 3, 0, 0], [0, 0, 3, 8, 0, 0, 3, 8, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8]]}, {""input"": [[9, 0, 0, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 0, 0, 9]], ""output"": [[8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8], [8, 3, 0, 0, 0, 0, 0, 0, 8, 3], [3, 8, 0, 0, 0, 0, 0, 0, 3, 8]]}, {""input"": [[9, 9, 9, 9, 9], [0, 0, 0, 9, 0], [0, 0, 9, 0, 0], [0, 9, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [0, 0, 0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 8, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8]]}, {""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8]]}], ""test"": [{""input"": [[9, 9, 9, 9, 9], [0, 0, 0, 9, 0], [0, 0, 9, 0, 0], [0, 9, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8], [0, 0, 0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 8, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 8, 3, 8, 3, 8, 3, 8, 3], [3, 8, 3, 8, 3, 8, 3, 8, 3, 8]]}]}"
ksJhqSnuVQU7byDuZEfJff,2025-07-21T15:52:23.686100,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and maroon color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 3, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 9
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 4, 0, 0], [4, 4, 4, 4]], ""output"": [[3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3], [0, 0, 0, 0, 3, 9, 0, 0], [0, 0, 0, 0, 9, 3, 0, 0], [0, 0, 3, 9, 0, 0, 0, 0], [0, 0, 9, 3, 0, 0, 0, 0], [3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3], [0, 0, 0, 0, 3, 9, 0, 0], [0, 0, 0, 0, 9, 3, 0, 0], [0, 0, 0, 0, 3, 9, 0, 0], [0, 0, 0, 0, 9, 3, 0, 0], [0, 0, 0, 0, 3, 9, 0, 0], [0, 0, 0, 0, 9, 3, 0, 0]]}, {""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3]]}, {""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3]]}], ""test"": [{""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3, 9, 3], [3, 9, 0, 0, 0, 0, 3, 9], [9, 3, 0, 0, 0, 0, 9, 3]]}]}"
mEsMLcfiqMoQTC8CPJN6Jk,2025-07-21T15:52:23.687574,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 7, ""color1"": 5, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 5
    color2 = 2
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 7, 7, 7, 7], [0, 0, 0, 7, 0], [0, 0, 7, 0, 0], [0, 7, 0, 0, 0], [7, 7, 7, 7, 7]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [0, 0, 0, 0, 0, 0, 5, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 5, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 5, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 5, 0, 0, 0, 0, 0, 0], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[7, 0, 0, 0, 0], [7, 0, 0, 0, 0], [7, 0, 0, 0, 0], [7, 0, 0, 0, 0], [7, 7, 7, 7, 7]], ""output"": [[5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[7, 7, 7, 7, 7], [7, 0, 0, 0, 7], [7, 0, 0, 0, 7], [7, 0, 0, 0, 7], [7, 7, 7, 7, 7]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5]]}, {""input"": [[0, 0, 7, 0, 0], [0, 0, 7, 0, 0], [7, 7, 7, 7, 7], [0, 0, 7, 0, 0], [0, 0, 7, 0, 0]], ""output"": [[0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0]]}, {""input"": [[7, 0, 0, 0, 7], [0, 7, 0, 7, 0], [0, 0, 7, 0, 0], [0, 7, 0, 7, 0], [7, 0, 0, 0, 7]], ""output"": [[5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5], [0, 0, 5, 2, 0, 0, 5, 2, 0, 0], [0, 0, 2, 5, 0, 0, 2, 5, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 5, 2, 0, 0, 5, 2, 0, 0], [0, 0, 2, 5, 0, 0, 2, 5, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 5, 2], [2, 5, 0, 0, 0, 0, 0, 0, 2, 5]]}], ""test"": [{""input"": [[7, 7, 7, 7, 7], [0, 0, 7, 0, 0], [0, 0, 7, 0, 0], [0, 0, 7, 0, 0], [0, 0, 7, 0, 0]], ""output"": [[5, 2, 5, 2, 5, 2, 5, 2, 5, 2], [2, 5, 2, 5, 2, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 5, 0, 0, 0, 0]]}]}"
L3vEsiteHYkdztVq9VtuTu,2025-07-21T15:52:23.689116,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and cyan color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 3, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 8
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 0, 0, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0, 0], [3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 0, 6, 0], [0, 0, 6, 0]], ""output"": [[3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0]]}], ""test"": [{""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 0, 6, 0], [0, 0, 6, 0]], ""output"": [[3, 8, 3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3, 8, 3], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0], [0, 0, 0, 0, 8, 3, 0, 0]]}]}"
dUfEBVYsnfomfEKCJTBkCe,2025-07-21T15:52:23.690522,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and green color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 1, ""color1"": 5, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 5
    color2 = 3
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 1]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0]]}, {""input"": [[0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5]]}, {""input"": [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [0, 0, 5, 3, 0, 0, 5, 3, 0, 0], [0, 0, 3, 5, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 5, 3, 0, 0, 5, 3, 0, 0], [0, 0, 3, 5, 0, 0, 3, 5, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5]]}], ""test"": [{""input"": [[1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]], ""output"": [[5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 0, 0, 3, 5]]}]}"
XHUygBRtqsUK2d7KcVWCSa,2025-07-21T15:52:23.691973,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and grey color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 7, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 7
    color2 = 5
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7], [7, 5, 0, 0, 7, 5], [5, 7, 0, 0, 5, 7], [7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7]]}, {""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[7, 5, 0, 0, 7, 5], [5, 7, 0, 0, 5, 7], [0, 0, 7, 5, 0, 0], [0, 0, 5, 7, 0, 0], [7, 5, 0, 0, 7, 5], [5, 7, 0, 0, 5, 7]]}, {""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7], [7, 5, 0, 0, 7, 5], [5, 7, 0, 0, 5, 7], [7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7]]}], ""test"": [{""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7], [0, 0, 7, 5, 0, 0], [0, 0, 5, 7, 0, 0], [7, 5, 7, 5, 7, 5], [5, 7, 5, 7, 5, 7]]}]}"
f4kPxKxu2iBPE5qUkGCJN7,2025-07-21T15:52:23.693236,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and grey color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 9, ""color1"": 1, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 1
    color2 = 5
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9], [9, 0, 9], [9, 9, 9]], ""output"": [[1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1]]}, {""input"": [[9, 0, 9], [9, 9, 9], [9, 0, 9]], ""output"": [[1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1]]}, {""input"": [[9, 0, 0], [9, 0, 0], [9, 9, 9]], ""output"": [[1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0], [5, 1, 0, 0, 0, 0], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1]]}, {""input"": [[9, 0, 9], [9, 9, 9], [9, 0, 9]], ""output"": [[1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [1, 5, 0, 0, 1, 5], [5, 1, 0, 0, 5, 1]]}], ""test"": [{""input"": [[9, 9, 9], [0, 9, 0], [9, 9, 9]], ""output"": [[1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1], [0, 0, 1, 5, 0, 0], [0, 0, 5, 1, 0, 0], [1, 5, 1, 5, 1, 5], [5, 1, 5, 1, 5, 1]]}]}"
aUQVRZ8pN9WJZrpDQsaxsi,2025-07-21T15:52:23.694736,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and maroon color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 5, ""color1"": 3, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 3
    color2 = 9
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 5], [0, 0, 5], [5, 5, 5]], ""output"": [[0, 0, 0, 0, 3, 9], [0, 0, 0, 0, 9, 3], [0, 0, 0, 0, 3, 9], [0, 0, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3]]}, {""input"": [[5, 5, 5], [0, 0, 5], [0, 0, 5]], ""output"": [[3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3], [0, 0, 0, 0, 3, 9], [0, 0, 0, 0, 9, 3], [0, 0, 0, 0, 3, 9], [0, 0, 0, 0, 9, 3]]}, {""input"": [[5, 0, 5], [0, 5, 0], [5, 0, 5]], ""output"": [[3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3], [0, 0, 3, 9, 0, 0], [0, 0, 9, 3, 0, 0], [3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3]]}, {""input"": [[5, 0, 5], [5, 5, 5], [5, 0, 5]], ""output"": [[3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3], [3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3]]}, {""input"": [[5, 0, 5], [0, 5, 0], [5, 0, 5]], ""output"": [[3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3], [0, 0, 3, 9, 0, 0], [0, 0, 9, 3, 0, 0], [3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3]]}], ""test"": [{""input"": [[5, 5, 5], [5, 0, 5], [5, 5, 5]], ""output"": [[3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3], [3, 9, 0, 0, 3, 9], [9, 3, 0, 0, 9, 3], [3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3]]}]}"
VQ7ohEydncYzpEBuGTVsUB,2025-07-21T15:52:23.696364,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and cyan color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 9, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 9
    color2 = 8
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4], [4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4]], ""output"": [[9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9], [9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9], [9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0]]}, {""input"": [[4, 0, 0, 0], [4, 0, 0, 0], [4, 0, 0, 0], [4, 4, 4, 4]], ""output"": [[9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9]]}], ""test"": [{""input"": [[4, 0, 0, 0], [4, 0, 0, 0], [4, 0, 0, 0], [4, 4, 4, 4]], ""output"": [[9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9]]}]}"
JyDMRfUdk7AbjbqRKPPM6P,2025-07-21T15:52:23.697919,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color red.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and cyan color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 2, ""color1"": 5, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 5
    color2 = 8
    pattern_color = 2
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[2, 2, 2], [2, 0, 2], [2, 2, 2]], ""output"": [[5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5], [5, 8, 0, 0, 5, 8], [8, 5, 0, 0, 8, 5], [5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5]]}, {""input"": [[0, 2, 0], [2, 2, 2], [0, 2, 0]], ""output"": [[0, 0, 5, 8, 0, 0], [0, 0, 8, 5, 0, 0], [5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5], [0, 0, 5, 8, 0, 0], [0, 0, 8, 5, 0, 0]]}, {""input"": [[0, 0, 2], [0, 0, 2], [2, 2, 2]], ""output"": [[0, 0, 0, 0, 5, 8], [0, 0, 0, 0, 8, 5], [0, 0, 0, 0, 5, 8], [0, 0, 0, 0, 8, 5], [5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5]]}], ""test"": [{""input"": [[2, 2, 2], [0, 2, 0], [2, 2, 2]], ""output"": [[5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5], [0, 0, 5, 8, 0, 0], [0, 0, 8, 5, 0, 0], [5, 8, 5, 8, 5, 8], [8, 5, 8, 5, 8, 5]]}]}"
8fCzw7J2HTbDEK4jJWbBEH,2025-07-21T15:52:23.699231,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and yellow color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 8, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 4
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 0, 0], [7, 0, 0], [7, 7, 7]], ""output"": [[8, 4, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0], [8, 4, 8, 4, 8, 4], [4, 8, 4, 8, 4, 8]]}, {""input"": [[7, 7, 7], [7, 0, 7], [7, 7, 7]], ""output"": [[8, 4, 8, 4, 8, 4], [4, 8, 4, 8, 4, 8], [8, 4, 0, 0, 8, 4], [4, 8, 0, 0, 4, 8], [8, 4, 8, 4, 8, 4], [4, 8, 4, 8, 4, 8]]}, {""input"": [[7, 0, 0], [7, 0, 0], [7, 7, 7]], ""output"": [[8, 4, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0], [8, 4, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0], [8, 4, 8, 4, 8, 4], [4, 8, 4, 8, 4, 8]]}], ""test"": [{""input"": [[7, 0, 7], [7, 7, 7], [7, 0, 7]], ""output"": [[8, 4, 0, 0, 8, 4], [4, 8, 0, 0, 4, 8], [8, 4, 8, 4, 8, 4], [4, 8, 4, 8, 4, 8], [8, 4, 0, 0, 8, 4], [4, 8, 0, 0, 4, 8]]}]}"
CjoafzfsoSKWevSGHHJUYv,2025-07-21T15:52:23.700668,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and red color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 3, ""color1"": 7, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 7
    color2 = 2
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 0, 0, 3], [0, 3, 3, 0], [0, 3, 3, 0], [3, 0, 0, 3]], ""output"": [[7, 2, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 2, 7], [0, 0, 7, 2, 7, 2, 0, 0], [0, 0, 2, 7, 2, 7, 0, 0], [0, 0, 7, 2, 7, 2, 0, 0], [0, 0, 2, 7, 2, 7, 0, 0], [7, 2, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 2, 7]]}, {""input"": [[3, 3, 3, 3], [0, 0, 3, 0], [0, 0, 3, 0], [0, 0, 3, 0]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7], [0, 0, 0, 0, 7, 2, 0, 0], [0, 0, 0, 0, 2, 7, 0, 0], [0, 0, 0, 0, 7, 2, 0, 0], [0, 0, 0, 0, 2, 7, 0, 0], [0, 0, 0, 0, 7, 2, 0, 0], [0, 0, 0, 0, 2, 7, 0, 0]]}, {""input"": [[3, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [3, 3, 3, 3]], ""output"": [[7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7]]}, {""input"": [[3, 0, 0, 3], [0, 3, 3, 0], [0, 3, 3, 0], [3, 0, 0, 3]], ""output"": [[7, 2, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 2, 7], [0, 0, 7, 2, 7, 2, 0, 0], [0, 0, 2, 7, 2, 7, 0, 0], [0, 0, 7, 2, 7, 2, 0, 0], [0, 0, 2, 7, 2, 7, 0, 0], [7, 2, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 2, 7]]}], ""test"": [{""input"": [[3, 0, 0, 0], [3, 0, 0, 0], [3, 0, 0, 0], [3, 3, 3, 3]], ""output"": [[7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7]]}]}"
Ae2FRPHa4r2iR25ZUcNPDP,2025-07-21T15:52:23.702153,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and grey color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 9, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 9
    color2 = 5
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9], [0, 0, 9, 5, 0, 0], [0, 0, 5, 9, 0, 0], [9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9]]}, {""input"": [[1, 0, 1], [1, 1, 1], [1, 0, 1]], ""output"": [[9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9], [9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9], [9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9]]}, {""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9], [0, 0, 9, 5, 0, 0], [0, 0, 5, 9, 0, 0], [9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9]]}, {""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9], [0, 0, 9, 5, 0, 0], [0, 0, 5, 9, 0, 0], [9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9]]}, {""input"": [[0, 0, 1], [0, 0, 1], [1, 1, 1]], ""output"": [[0, 0, 0, 0, 9, 5], [0, 0, 0, 0, 5, 9], [0, 0, 0, 0, 9, 5], [0, 0, 0, 0, 5, 9], [9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9]]}], ""test"": [{""input"": [[1, 0, 1], [1, 1, 1], [1, 0, 1]], ""output"": [[9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9], [9, 5, 9, 5, 9, 5], [5, 9, 5, 9, 5, 9], [9, 5, 0, 0, 9, 5], [5, 9, 0, 0, 5, 9]]}]}"
7ghQZkCPCQyeGHTmp3VyVQ,2025-07-21T15:52:23.703471,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and red color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 8, ""color1"": 7, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 2
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 8, 8, 8, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 0, 0, 0, 8], [8, 8, 8, 8, 8]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 0, 0, 0, 0, 0, 0, 7, 2], [2, 7, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}, {""input"": [[8, 8, 8, 8, 8], [0, 0, 0, 8, 0], [0, 0, 8, 0, 0], [0, 8, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7], [0, 0, 0, 0, 0, 0, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 7, 0, 0], [0, 0, 0, 0, 7, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 7, 0, 0, 0, 0], [0, 0, 7, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 7, 0, 0, 0, 0, 0, 0], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}, {""input"": [[8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 0, 0, 0, 0], [8, 8, 8, 8, 8]], ""output"": [[7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}], ""test"": [{""input"": [[0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [8, 8, 8, 8, 8]], ""output"": [[0, 0, 0, 0, 0, 0, 0, 0, 7, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 7], [7, 2, 7, 2, 7, 2, 7, 2, 7, 2], [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]]}]}"
8gybaAExTRZJ9wpcaYoE7X,2025-07-21T15:52:23.704974,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and grey color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 3, ""color2"": 5}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 3
    color2 = 5
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6], [6, 0, 0, 6]], ""output"": [[3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3], [3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [3, 5, 0, 0, 0, 0, 3, 5], [5, 3, 0, 0, 0, 0, 5, 3]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 0, 6, 0], [0, 0, 6, 0]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 6, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 5, 3, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}, {""input"": [[6, 6, 6, 6], [0, 0, 6, 0], [0, 0, 6, 0], [0, 0, 6, 0]], ""output"": [[3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 0, 0, 5, 3, 0, 0]]}], ""test"": [{""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 0, 0], [5, 3, 0, 0, 0, 0, 0, 0], [3, 5, 3, 5, 3, 5, 3, 5], [5, 3, 5, 3, 5, 3, 5, 3]]}]}"
EVhqFzjqdqu2RAgt5bVTjw,2025-07-21T15:52:23.706474,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and red color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 9, ""color2"": 2}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 9
    color2 = 2
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [9, 2, 9, 2, 9, 2], [2, 9, 2, 9, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0]]}, {""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [9, 2, 9, 2, 9, 2], [2, 9, 2, 9, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0]]}, {""input"": [[7, 7, 7], [0, 7, 0], [0, 7, 0]], ""output"": [[9, 2, 9, 2, 9, 2], [2, 9, 2, 9, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0]]}, {""input"": [[7, 0, 7], [0, 7, 0], [7, 0, 7]], ""output"": [[9, 2, 0, 0, 9, 2], [2, 9, 0, 0, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [9, 2, 0, 0, 9, 2], [2, 9, 0, 0, 2, 9]]}, {""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [9, 2, 9, 2, 9, 2], [2, 9, 2, 9, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0]]}], ""test"": [{""input"": [[7, 0, 7], [0, 7, 0], [7, 0, 7]], ""output"": [[9, 2, 0, 0, 9, 2], [2, 9, 0, 0, 2, 9], [0, 0, 9, 2, 0, 0], [0, 0, 2, 9, 0, 0], [9, 2, 0, 0, 9, 2], [2, 9, 0, 0, 2, 9]]}]}"
CGaDxcP72JurUA57SLcnpp,2025-07-21T15:52:23.707867,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and pink color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 9, ""color1"": 7, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 7
    color2 = 6
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9], [9, 0, 0], [9, 0, 0]], ""output"": [[7, 6, 7, 6, 7, 6], [6, 7, 6, 7, 6, 7], [7, 6, 0, 0, 0, 0], [6, 7, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0], [6, 7, 0, 0, 0, 0]]}, {""input"": [[0, 9, 0], [9, 9, 9], [0, 9, 0]], ""output"": [[0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0], [7, 6, 7, 6, 7, 6], [6, 7, 6, 7, 6, 7], [0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0]]}, {""input"": [[9, 9, 9], [0, 9, 0], [0, 9, 0]], ""output"": [[7, 6, 7, 6, 7, 6], [6, 7, 6, 7, 6, 7], [0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0], [0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0]]}, {""input"": [[0, 9, 0], [9, 9, 9], [0, 9, 0]], ""output"": [[0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0], [7, 6, 7, 6, 7, 6], [6, 7, 6, 7, 6, 7], [0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0]]}], ""test"": [{""input"": [[0, 9, 0], [9, 9, 9], [0, 9, 0]], ""output"": [[0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0], [7, 6, 7, 6, 7, 6], [6, 7, 6, 7, 6, 7], [0, 0, 7, 6, 0, 0], [0, 0, 6, 7, 0, 0]]}]}"
6tLyzEXfwvNvQrGABDYFV2,2025-07-21T15:52:23.709160,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and blue color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 8, ""color1"": 3, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 3
    color2 = 1
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 8, 8], [0, 8, 0], [0, 8, 0]], ""output"": [[3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0]]}, {""input"": [[0, 0, 8], [0, 0, 8], [8, 8, 8]], ""output"": [[0, 0, 0, 0, 3, 1], [0, 0, 0, 0, 1, 3], [0, 0, 0, 0, 3, 1], [0, 0, 0, 0, 1, 3], [3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3]]}, {""input"": [[8, 8, 8], [8, 0, 0], [8, 0, 0]], ""output"": [[3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3], [3, 1, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0], [3, 1, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0]]}, {""input"": [[8, 8, 8], [0, 8, 0], [0, 8, 0]], ""output"": [[3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0]]}, {""input"": [[8, 0, 0], [8, 0, 0], [8, 8, 8]], ""output"": [[3, 1, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0], [3, 1, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0], [3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3]]}], ""test"": [{""input"": [[8, 8, 8], [0, 8, 0], [0, 8, 0]], ""output"": [[3, 1, 3, 1, 3, 1], [1, 3, 1, 3, 1, 3], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0], [0, 0, 3, 1, 0, 0], [0, 0, 1, 3, 0, 0]]}]}"
8NdDFSHbzdVVYP6bKGrTX4,2025-07-21T15:52:23.710611,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and blue color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 5, ""color1"": 7, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 1
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0]]}, {""input"": [[5, 0, 0, 0, 5], [0, 5, 0, 5, 0], [0, 0, 5, 0, 0], [0, 5, 0, 5, 0], [5, 0, 0, 0, 5]], ""output"": [[7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [0, 0, 7, 1, 0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0, 1, 7, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 7, 1, 0, 0, 7, 1, 0, 0], [0, 0, 1, 7, 0, 0, 1, 7, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7]]}, {""input"": [[5, 5, 5, 5, 5], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0]], ""output"": [[7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0]]}], ""test"": [{""input"": [[5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 5, 5, 5, 5]], ""output"": [[7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7]]}]}"
cVaXXFPxH2vJ6NpxbMs9zz,2025-07-21T15:52:23.712065,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely yellow color and pink color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 9, ""color1"": 4, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 4
    color2 = 6
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 0, 0, 0, 0], [9, 9, 9, 9, 9]], ""output"": [[4, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 6, 4, 6, 4, 6, 4, 6, 4, 6], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4]]}, {""input"": [[0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [4, 6, 4, 6, 4, 6, 4, 6, 4, 6], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0]]}, {""input"": [[9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[4, 6, 4, 6, 4, 6, 4, 6, 4, 6], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0]]}], ""test"": [{""input"": [[9, 9, 9, 9, 9], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0], [0, 0, 9, 0, 0]], ""output"": [[4, 6, 4, 6, 4, 6, 4, 6, 4, 6], [6, 4, 6, 4, 6, 4, 6, 4, 6, 4], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 4, 0, 0, 0, 0]]}]}"
jwQTnBNNDAYAVmc9UC3vZ3,2025-07-21T15:52:23.713804,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and orange color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 8, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 8
    color2 = 7
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8]]}, {""input"": [[0, 0, 4, 0], [0, 0, 4, 0], [4, 4, 4, 4], [0, 0, 4, 0]], ""output"": [[0, 0, 0, 0, 8, 7, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0], [8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8], [0, 0, 0, 0, 8, 7, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0]]}, {""input"": [[4, 0, 0, 4], [0, 4, 4, 0], [0, 4, 4, 0], [4, 0, 0, 4]], ""output"": [[8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [0, 0, 8, 7, 8, 7, 0, 0], [0, 0, 7, 8, 7, 8, 0, 0], [0, 0, 8, 7, 8, 7, 0, 0], [0, 0, 7, 8, 7, 8, 0, 0], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8]]}, {""input"": [[4, 0, 0, 4], [0, 4, 4, 0], [0, 4, 4, 0], [4, 0, 0, 4]], ""output"": [[8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [0, 0, 8, 7, 8, 7, 0, 0], [0, 0, 7, 8, 7, 8, 0, 0], [0, 0, 8, 7, 8, 7, 0, 0], [0, 0, 7, 8, 7, 8, 0, 0], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8]]}], ""test"": [{""input"": [[4, 4, 4, 4], [4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4]], ""output"": [[8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8]]}]}"
oHGfD2MLDxPf745bTPPnjW,2025-07-21T15:52:23.715277,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely cyan color and blue color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 8, ""color2"": 1}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 8
    color2 = 1
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 7, 0], [7, 7, 7], [0, 7, 0]], ""output"": [[0, 0, 8, 1, 0, 0], [0, 0, 1, 8, 0, 0], [8, 1, 8, 1, 8, 1], [1, 8, 1, 8, 1, 8], [0, 0, 8, 1, 0, 0], [0, 0, 1, 8, 0, 0]]}, {""input"": [[0, 0, 7], [0, 0, 7], [7, 7, 7]], ""output"": [[0, 0, 0, 0, 8, 1], [0, 0, 0, 0, 1, 8], [0, 0, 0, 0, 8, 1], [0, 0, 0, 0, 1, 8], [8, 1, 8, 1, 8, 1], [1, 8, 1, 8, 1, 8]]}, {""input"": [[0, 0, 7], [0, 0, 7], [7, 7, 7]], ""output"": [[0, 0, 0, 0, 8, 1], [0, 0, 0, 0, 1, 8], [0, 0, 0, 0, 8, 1], [0, 0, 0, 0, 1, 8], [8, 1, 8, 1, 8, 1], [1, 8, 1, 8, 1, 8]]}, {""input"": [[7, 7, 7], [0, 7, 0], [7, 7, 7]], ""output"": [[8, 1, 8, 1, 8, 1], [1, 8, 1, 8, 1, 8], [0, 0, 8, 1, 0, 0], [0, 0, 1, 8, 0, 0], [8, 1, 8, 1, 8, 1], [1, 8, 1, 8, 1, 8]]}], ""test"": [{""input"": [[7, 0, 7], [0, 7, 0], [7, 0, 7]], ""output"": [[8, 1, 0, 0, 8, 1], [1, 8, 0, 0, 1, 8], [0, 0, 8, 1, 0, 0], [0, 0, 1, 8, 0, 0], [8, 1, 0, 0, 8, 1], [1, 8, 0, 0, 1, 8]]}]}"
9LoCs2HY6WXtYFWhS3nvH2,2025-07-21T15:52:23.716576,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color maroon.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and green color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 9, ""color1"": 1, ""color2"": 3}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 1
    color2 = 3
    pattern_color = 9
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[9, 9, 9, 9], [0, 0, 9, 0], [0, 0, 9, 0], [0, 0, 9, 0]], ""output"": [[1, 3, 1, 3, 1, 3, 1, 3], [3, 1, 3, 1, 3, 1, 3, 1], [0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0]]}, {""input"": [[9, 0, 0, 0], [9, 0, 0, 0], [9, 0, 0, 0], [9, 9, 9, 9]], ""output"": [[1, 3, 0, 0, 0, 0, 0, 0], [3, 1, 0, 0, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0, 0, 0], [3, 1, 0, 0, 0, 0, 0, 0], [1, 3, 0, 0, 0, 0, 0, 0], [3, 1, 0, 0, 0, 0, 0, 0], [1, 3, 1, 3, 1, 3, 1, 3], [3, 1, 3, 1, 3, 1, 3, 1]]}, {""input"": [[9, 9, 9, 9], [9, 0, 0, 9], [9, 0, 0, 9], [9, 9, 9, 9]], ""output"": [[1, 3, 1, 3, 1, 3, 1, 3], [3, 1, 3, 1, 3, 1, 3, 1], [1, 3, 0, 0, 0, 0, 1, 3], [3, 1, 0, 0, 0, 0, 3, 1], [1, 3, 0, 0, 0, 0, 1, 3], [3, 1, 0, 0, 0, 0, 3, 1], [1, 3, 1, 3, 1, 3, 1, 3], [3, 1, 3, 1, 3, 1, 3, 1]]}], ""test"": [{""input"": [[0, 0, 9, 0], [0, 0, 9, 0], [9, 9, 9, 9], [0, 0, 9, 0]], ""output"": [[0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [1, 3, 1, 3, 1, 3, 1, 3], [3, 1, 3, 1, 3, 1, 3, 1], [0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0]]}]}"
XAzb3nAHweDLP5mA9WnjXi,2025-07-21T15:52:23.717992,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and orange color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 3, ""color1"": 5, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 5
    color2 = 7
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 0, 0], [3, 0, 0], [3, 3, 3]], ""output"": [[5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5]]}, {""input"": [[3, 3, 3], [3, 0, 0], [3, 0, 0]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0], [5, 7, 0, 0, 0, 0], [7, 5, 0, 0, 0, 0]]}, {""input"": [[0, 3, 0], [3, 3, 3], [0, 3, 0]], ""output"": [[0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0]]}, {""input"": [[3, 0, 3], [3, 3, 3], [3, 0, 3]], ""output"": [[5, 7, 0, 0, 5, 7], [7, 5, 0, 0, 7, 5], [5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [5, 7, 0, 0, 5, 7], [7, 5, 0, 0, 7, 5]]}], ""test"": [{""input"": [[3, 3, 3], [0, 3, 0], [0, 3, 0]], ""output"": [[5, 7, 5, 7, 5, 7], [7, 5, 7, 5, 7, 5], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0], [0, 0, 5, 7, 0, 0], [0, 0, 7, 5, 0, 0]]}]}"
ZqfLw8UARgCJogcFaHh8wZ,2025-07-21T15:52:23.719395,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and maroon color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 5, ""color1"": 6, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 6
    color2 = 9
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 0, 0, 5], [5, 0, 0, 5], [5, 5, 5, 5], [5, 0, 0, 5]], ""output"": [[6, 9, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 9, 6], [6, 9, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 9, 6], [6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 9, 6]]}, {""input"": [[5, 0, 0, 0], [5, 0, 0, 0], [5, 0, 0, 0], [5, 5, 5, 5]], ""output"": [[6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6]]}, {""input"": [[5, 0, 0, 5], [0, 5, 5, 0], [0, 5, 5, 0], [5, 0, 0, 5]], ""output"": [[6, 9, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 9, 6], [0, 0, 6, 9, 6, 9, 0, 0], [0, 0, 9, 6, 9, 6, 0, 0], [0, 0, 6, 9, 6, 9, 0, 0], [0, 0, 9, 6, 9, 6, 0, 0], [6, 9, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 9, 6]]}], ""test"": [{""input"": [[5, 5, 5, 5], [0, 0, 5, 0], [0, 5, 0, 0], [5, 5, 5, 5]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 6, 9, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0], [0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 9, 6, 0, 0, 0, 0], [6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6]]}]}"
gKny2RQ3kXPYQfkuHna5af,2025-07-21T15:52:23.721220,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and orange color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 3, ""color1"": 1, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 1
    color2 = 7
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0]]}, {""input"": [[3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 0, 0, 0, 0], [3, 3, 3, 3, 3]], ""output"": [[1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1]]}, {""input"": [[3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0]]}, {""input"": [[3, 3, 3, 3, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 3, 3, 3, 3]], ""output"": [[1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1]]}, {""input"": [[3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 3, 3, 3, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3]], ""output"": [[1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1], [1, 7, 0, 0, 0, 0, 0, 0, 1, 7], [7, 1, 0, 0, 0, 0, 0, 0, 7, 1]]}], ""test"": [{""input"": [[3, 3, 3, 3, 3], [0, 0, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 0, 0], [3, 3, 3, 3, 3]], ""output"": [[1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1], [0, 0, 0, 0, 0, 0, 1, 7, 0, 0], [0, 0, 0, 0, 0, 0, 7, 1, 0, 0], [0, 0, 0, 0, 1, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 1, 7, 0, 0, 0, 0, 0, 0], [0, 0, 7, 1, 0, 0, 0, 0, 0, 0], [1, 7, 1, 7, 1, 7, 1, 7, 1, 7], [7, 1, 7, 1, 7, 1, 7, 1, 7, 1]]}]}"
ksjQzotBA85GkqV6rsLJ5E,2025-07-21T15:52:23.722887,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color pink.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and orange color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 6, ""color1"": 9, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 9
    color2 = 7
    pattern_color = 6
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0]], ""output"": [[9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0]]}, {""input"": [[6, 0, 0, 0], [6, 0, 0, 0], [6, 0, 0, 0], [6, 6, 6, 6]], ""output"": [[9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9]]}, {""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0]]}, {""input"": [[0, 0, 6, 0], [0, 0, 6, 0], [6, 6, 6, 6], [0, 0, 6, 0]], ""output"": [[0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0]]}, {""input"": [[0, 0, 0, 6], [0, 0, 0, 6], [0, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[0, 0, 0, 0, 0, 0, 9, 7], [0, 0, 0, 0, 0, 0, 7, 9], [0, 0, 0, 0, 0, 0, 9, 7], [0, 0, 0, 0, 0, 0, 7, 9], [0, 0, 0, 0, 0, 0, 9, 7], [0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9]]}], ""test"": [{""input"": [[6, 6, 6, 6], [6, 0, 0, 6], [6, 0, 0, 6], [6, 6, 6, 6]], ""output"": [[9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9]]}]}"
WChRB6WxsgkRiHUZDF7pvy,2025-07-21T15:52:23.724362,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and maroon color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 4, ""color1"": 7, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 7
    color2 = 9
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0]]}, {""input"": [[4, 0, 0, 4], [4, 0, 0, 4], [4, 4, 4, 4], [4, 0, 0, 4]], ""output"": [[7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7]]}, {""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0]], ""output"": [[7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0]]}, {""input"": [[4, 0, 0, 4], [0, 4, 4, 0], [0, 4, 4, 0], [4, 0, 0, 4]], ""output"": [[7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [0, 0, 7, 9, 7, 9, 0, 0], [0, 0, 9, 7, 9, 7, 0, 0], [0, 0, 7, 9, 7, 9, 0, 0], [0, 0, 9, 7, 9, 7, 0, 0], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7]]}, {""input"": [[4, 0, 0, 4], [0, 4, 4, 0], [0, 4, 4, 0], [4, 0, 0, 4]], ""output"": [[7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7], [0, 0, 7, 9, 7, 9, 0, 0], [0, 0, 9, 7, 9, 7, 0, 0], [0, 0, 7, 9, 7, 9, 0, 0], [0, 0, 9, 7, 9, 7, 0, 0], [7, 9, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 9, 7]]}], ""test"": [{""input"": [[4, 4, 4, 4], [0, 0, 4, 0], [0, 4, 0, 0], [4, 4, 4, 4]], ""output"": [[7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7], [0, 0, 0, 0, 7, 9, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0], [0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 9, 7, 0, 0, 0, 0], [7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7]]}]}"
e6xD2bGyg8uPV37343wzYE,2025-07-21T15:52:23.725906,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and orange color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 6, ""color2"": 7}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 7
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0]]}, {""input"": [[4, 0, 0, 0, 4], [0, 4, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 4, 0], [4, 0, 0, 0, 4]], ""output"": [[6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [0, 0, 6, 7, 0, 0, 6, 7, 0, 0], [0, 0, 7, 6, 0, 0, 7, 6, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 6, 7, 0, 0, 6, 7, 0, 0], [0, 0, 7, 6, 0, 0, 7, 6, 0, 0], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6]]}, {""input"": [[4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4]], ""output"": [[6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6]]}, {""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[6, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6]]}, {""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0]]}], ""test"": [{""input"": [[4, 4, 4, 4, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 0, 0, 0, 4], [4, 4, 4, 4, 4]], ""output"": [[6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 0, 0, 0, 0, 0, 0, 6, 7], [7, 6, 0, 0, 0, 0, 0, 0, 7, 6], [6, 7, 6, 7, 6, 7, 6, 7, 6, 7], [7, 6, 7, 6, 7, 6, 7, 6, 7, 6]]}]}"
DsCWQvQCYvo24WCUNnyLSF,2025-07-21T15:52:23.727493,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color cyan.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely grey color and maroon color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 8, ""color1"": 5, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 5
    color2 = 9
    pattern_color = 8
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[8, 0, 0, 8], [0, 8, 8, 0], [0, 8, 8, 0], [8, 0, 0, 8]], ""output"": [[5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5], [0, 0, 5, 9, 5, 9, 0, 0], [0, 0, 9, 5, 9, 5, 0, 0], [0, 0, 5, 9, 5, 9, 0, 0], [0, 0, 9, 5, 9, 5, 0, 0], [5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5]]}, {""input"": [[8, 8, 8, 8], [0, 0, 8, 0], [0, 0, 8, 0], [0, 0, 8, 0]], ""output"": [[5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5], [0, 0, 0, 0, 5, 9, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0], [0, 0, 0, 0, 9, 5, 0, 0]]}, {""input"": [[8, 0, 0, 0], [8, 0, 0, 0], [8, 0, 0, 0], [8, 8, 8, 8]], ""output"": [[5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5]]}, {""input"": [[8, 0, 0, 8], [8, 0, 0, 8], [8, 8, 8, 8], [8, 0, 0, 8]], ""output"": [[5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5], [5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5], [5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5]]}, {""input"": [[8, 0, 0, 8], [8, 0, 0, 8], [8, 8, 8, 8], [8, 0, 0, 8]], ""output"": [[5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5], [5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5], [5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5], [5, 9, 0, 0, 0, 0, 5, 9], [9, 5, 0, 0, 0, 0, 9, 5]]}], ""test"": [{""input"": [[8, 0, 0, 0], [8, 0, 0, 0], [8, 0, 0, 0], [8, 8, 8, 8]], ""output"": [[5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 0, 0, 0, 0, 0, 0], [9, 5, 0, 0, 0, 0, 0, 0], [5, 9, 5, 9, 5, 9, 5, 9], [9, 5, 9, 5, 9, 5, 9, 5]]}]}"
T8xtQfqodxPuu7uw6AvvQm,2025-07-21T15:52:23.729383,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color green.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and cyan color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 3, ""color1"": 7, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 8
    pattern_color = 3
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[3, 3, 3, 3, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 0, 0, 0, 3], [3, 3, 3, 3, 3]], ""output"": [[7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 0, 0, 0, 0, 0, 0, 7, 8], [8, 7, 0, 0, 0, 0, 0, 0, 8, 7], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7]]}, {""input"": [[3, 3, 3, 3, 3], [0, 0, 0, 3, 0], [0, 0, 3, 0, 0], [0, 3, 0, 0, 0], [3, 3, 3, 3, 3]], ""output"": [[7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [0, 0, 0, 0, 0, 0, 7, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 7, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 7, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 7, 0, 0, 0, 0, 0, 0], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7]]}, {""input"": [[3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0]]}], ""test"": [{""input"": [[0, 0, 3, 0, 0], [0, 0, 3, 0, 0], [3, 3, 3, 3, 3], [0, 0, 3, 0, 0], [0, 0, 3, 0, 0]], ""output"": [[0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [7, 8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8, 7], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 7, 0, 0, 0, 0]]}]}"
bP6Xg8UqUGurePXYByhPMT,2025-07-21T15:52:23.730912,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color yellow.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely blue color and pink color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 4, ""color1"": 1, ""color2"": 6}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 1
    color2 = 6
    pattern_color = 4
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0]]}, {""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0]]}, {""input"": [[4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0]]}, {""input"": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [4, 4, 4, 4, 4], [0, 0, 4, 0, 0], [0, 0, 4, 0, 0]], ""output"": [[0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0]]}, {""input"": [[4, 0, 0, 0, 4], [0, 4, 0, 4, 0], [0, 0, 4, 0, 0], [0, 4, 0, 4, 0], [4, 0, 0, 0, 4]], ""output"": [[1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 1, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 1, 0, 0, 0, 0], [0, 0, 1, 6, 0, 0, 1, 6, 0, 0], [0, 0, 6, 1, 0, 0, 6, 1, 0, 0], [1, 6, 0, 0, 0, 0, 0, 0, 1, 6], [6, 1, 0, 0, 0, 0, 0, 0, 6, 1]]}], ""test"": [{""input"": [[4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 0, 0, 0, 0], [4, 4, 4, 4, 4]], ""output"": [[1, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 6, 1, 6, 1, 6, 1, 6, 1, 6], [6, 1, 6, 1, 6, 1, 6, 1, 6, 1]]}]}"
BxkurfqqftuJkpQ8QWsTBf,2025-07-21T15:52:23.732575,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely pink color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 1, ""color1"": 6, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 6
    color2 = 9
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 0, 0, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0, 9, 6], [6, 9, 0, 0, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0, 9, 6], [6, 9, 0, 0, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0, 9, 6], [6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6]]}, {""input"": [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]], ""output"": [[6, 9, 0, 0, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 6, 9, 0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0, 9, 6, 0, 0], [0, 0, 0, 0, 6, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 6, 0, 0, 0, 0], [0, 0, 6, 9, 0, 0, 6, 9, 0, 0], [0, 0, 9, 6, 0, 0, 9, 6, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 6, 9], [9, 6, 0, 0, 0, 0, 0, 0, 9, 6]]}, {""input"": [[1, 1, 1, 1, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 0, 0, 0, 0, 0, 0, 0, 0]]}], ""test"": [{""input"": [[1, 1, 1, 1, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1]], ""output"": [[6, 9, 6, 9, 6, 9, 6, 9, 6, 9], [9, 6, 9, 6, 9, 6, 9, 6, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6], [0, 0, 0, 0, 0, 0, 0, 0, 6, 9], [0, 0, 0, 0, 0, 0, 0, 0, 9, 6]]}]}"
KtY6JTdFrTkrXShPHLkDBr,2025-07-21T15:52:23.734119,task2072aba6,"[""Input grids are square of size 5 x 5."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely orange color and maroon color""]","{""rows"": 5, ""columns"": 5, ""pattern_color"": 1, ""color1"": 7, ""color2"": 9}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 5
    columns = 5
    color1 = 7
    color2 = 9
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]], ""output"": [[7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7], [7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7], [7, 9, 7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7, 9, 7], [7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7], [7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7]]}, {""input"": [[1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], ""output"": [[7, 9, 7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7, 9, 7], [0, 0, 0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0, 0, 0]]}, {""input"": [[1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 1]], ""output"": [[7, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0, 0, 0], [9, 7, 0, 0, 0, 0, 0, 0, 0, 0], [7, 9, 7, 9, 7, 9, 7, 9, 7, 9], [9, 7, 9, 7, 9, 7, 9, 7, 9, 7]]}], ""test"": [{""input"": [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]], ""output"": [[7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7], [0, 0, 7, 9, 0, 0, 7, 9, 0, 0], [0, 0, 9, 7, 0, 0, 9, 7, 0, 0], [0, 0, 0, 0, 7, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 7, 0, 0, 0, 0], [0, 0, 7, 9, 0, 0, 7, 9, 0, 0], [0, 0, 9, 7, 0, 0, 9, 7, 0, 0], [7, 9, 0, 0, 0, 0, 0, 0, 7, 9], [9, 7, 0, 0, 0, 0, 0, 0, 9, 7]]}]}"
eEqvgq3crxqrneF8PuXypB,2025-07-21T15:52:23.735586,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color blue.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and yellow color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 1, ""color1"": 9, ""color2"": 4}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 9
    color2 = 4
    pattern_color = 1
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}, {""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}, {""input"": [[1, 1, 1], [0, 1, 0], [1, 1, 1]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}, {""input"": [[1, 0, 1], [0, 1, 0], [1, 0, 1]], ""output"": [[9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [0, 0, 9, 4, 0, 0], [0, 0, 4, 9, 0, 0], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9]]}], ""test"": [{""input"": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], ""output"": [[9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9], [9, 4, 0, 0, 9, 4], [4, 9, 0, 0, 4, 9], [9, 4, 9, 4, 9, 4], [4, 9, 4, 9, 4, 9]]}]}"
3nw4KNEM6dr394jwkDzhoV,2025-07-21T15:52:23.737000,task2072aba6,"[""Input grids are square of size 4 x 4."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color grey.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely maroon color and cyan color""]","{""rows"": 4, ""columns"": 4, ""pattern_color"": 5, ""color1"": 9, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 4
    columns = 4
    color1 = 9
    color2 = 8
    pattern_color = 5
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[5, 0, 0, 5], [0, 5, 5, 0], [0, 5, 5, 0], [5, 0, 0, 5]], ""output"": [[9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9], [0, 0, 9, 8, 9, 8, 0, 0], [0, 0, 8, 9, 8, 9, 0, 0], [0, 0, 9, 8, 9, 8, 0, 0], [0, 0, 8, 9, 8, 9, 0, 0], [9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9]]}, {""input"": [[5, 0, 0, 0], [5, 0, 0, 0], [5, 0, 0, 0], [5, 5, 5, 5]], ""output"": [[9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9]]}, {""input"": [[0, 0, 5, 0], [0, 0, 5, 0], [5, 5, 5, 5], [0, 0, 5, 0]], ""output"": [[0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9], [0, 0, 0, 0, 9, 8, 0, 0], [0, 0, 0, 0, 8, 9, 0, 0]]}, {""input"": [[5, 0, 0, 5], [5, 0, 0, 5], [5, 5, 5, 5], [5, 0, 0, 5]], ""output"": [[9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9], [9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9], [9, 8, 0, 0, 0, 0, 9, 8], [8, 9, 0, 0, 0, 0, 8, 9]]}], ""test"": [{""input"": [[5, 0, 0, 0], [5, 0, 0, 0], [5, 0, 0, 0], [5, 5, 5, 5]], ""output"": [[9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 0, 0, 0, 0, 0, 0], [8, 9, 0, 0, 0, 0, 0, 0], [9, 8, 9, 8, 9, 8, 9, 8], [8, 9, 8, 9, 8, 9, 8, 9]]}]}"
5RxsugZVm6bKJGwcP7vwEB,2025-07-21T15:52:23.738457,task2072aba6,"[""Input grids are square of size 3 x 3."", ""Each input grid consists of a simple pattern which covers most of the grid and is of color orange.""]","[""The output grid is double the size of the input grid."", ""The pattern now gets a checker board color filling in each of its cell namely green color and cyan color""]","{""rows"": 3, ""columns"": 3, ""pattern_color"": 7, ""color1"": 3, ""color2"": 8}","def transform_input(self, grid: np.ndarray):
    """"""Transform input to double size with checkerboard pattern.""""""
    rows = 3
    columns = 3
    color1 = 3
    color2 = 8
    pattern_color = 7
    
    # Create output grid with double size
    output_grid = np.zeros((rows * 2, columns * 2), dtype=int)
    
    # For each cell in the input grid
    for r in range(rows):
        for c in range(columns):
            if grid[r, c] == pattern_color:
                # This cell has the pattern, so we fill the corresponding 2x2 area
                # in the output with checkerboard pattern
                
                # Calculate the 2x2 area in output grid
                out_r_start = r * 2
                out_c_start = c * 2
                
                # Create checkerboard pattern in this 2x2 area
                # Top-left and bottom-right get color1
                # Top-right and bottom-left get color2
                output_grid[out_r_start, out_c_start] = color1           # Top-left
                output_grid[out_r_start, out_c_start + 1] = color2       # Top-right
                output_grid[out_r_start + 1, out_c_start] = color2       # Bottom-left
                output_grid[out_r_start + 1, out_c_start + 1] = color1   # Bottom-right
            # If grid[r, c] == 0, the corresponding 2x2 area remains 0 (background)
    
    return output_grid","{""train"": [{""input"": [[7, 0, 7], [7, 7, 7], [7, 0, 7]], ""output"": [[3, 8, 0, 0, 3, 8], [8, 3, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3], [3, 8, 0, 0, 3, 8], [8, 3, 0, 0, 8, 3]]}, {""input"": [[0, 0, 7], [0, 0, 7], [7, 7, 7]], ""output"": [[0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3]]}, {""input"": [[7, 7, 7], [0, 7, 0], [7, 7, 7]], ""output"": [[3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3], [0, 0, 3, 8, 0, 0], [0, 0, 8, 3, 0, 0], [3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3]]}, {""input"": [[0, 0, 7], [0, 0, 7], [7, 7, 7]], ""output"": [[0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 8, 3], [0, 0, 0, 0, 3, 8], [0, 0, 0, 0, 8, 3], [3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3]]}], ""test"": [{""input"": [[7, 7, 7], [0, 7, 0], [7, 7, 7]], ""output"": [[3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3], [0, 0, 3, 8, 0, 0], [0, 0, 8, 3, 0, 0], [3, 8, 3, 8, 3, 8], [8, 3, 8, 3, 8, 3]]}]}"
