from arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from input_library import random_cell_coloring, retry
from transformation_library import find_connected_objects
import numpy as np
import random
from typing import Dict, Any, Tuple

class Taskfafffa47Generator(ARCTaskGenerator):
    
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['rows']} x {vars['columns']}, where {vars['rows']} is an even integer number.",
            "Each input grid is divided into top and bottom halves.",
            "On the top half a random number of cells are colored with {color('top_color')}.",
            "On the bottom half a random number of cells are colored with {color('bottom_color')}.",
            "The intersection of empty cells from both halves — based on row and relative column position — is guaranteed to be non-empty."
        ]
        
        transformation_reasoning_chain = [
            "Output grids are of size ({vars['rows']}// 2) x {vars['columns']}.",
            "The top and bottom halves are identified in the input grid.",
            "The output grid is generated by taking the intersection of empty cells from both halves, based on row and relative column position.",
            "The cells in this intersection are colored with {color('output_color')} in the output grid."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_input(self, taskvars: Dict[str, Any], gridvars: Dict[str, Any]) -> np.ndarray:
        rows = taskvars['rows']
        columns = taskvars['columns']
        top_color = taskvars['top_color']
        bottom_color = taskvars['bottom_color']
        
        # Create empty grid
        grid = np.zeros((rows, columns), dtype=int)
        
        # Split into halves
        half_rows = rows // 2
        top_half = grid[:half_rows, :]
        bottom_half = grid[half_rows:, :]
        
        def create_valid_grid():
            # Reset grid
            grid_attempt = np.zeros((rows, columns), dtype=int)
            top_half_attempt = grid_attempt[:half_rows, :]
            bottom_half_attempt = grid_attempt[half_rows:, :]
            
            # Random coloring of top half
            top_density = random.uniform(0.2, 0.7)
            random_cell_coloring(top_half_attempt, top_color, density=top_density)
            
            # Random coloring of bottom half
            bottom_density = random.uniform(0.2, 0.7)
            random_cell_coloring(bottom_half_attempt, bottom_color, density=bottom_density)
            
            # Check if intersection of empty cells is non-empty
            top_empty = (top_half_attempt == 0)
            bottom_empty = (bottom_half_attempt == 0)
            intersection = top_empty & bottom_empty
            
            return grid_attempt, np.any(intersection)
        
        # Use retry to ensure valid grid
        def generator():
            grid_attempt, is_valid = create_valid_grid()
            return grid_attempt if is_valid else None
        
        def predicate(result):
            return result is not None
        
        return retry(generator, predicate, max_attempts=100)
    
    def transform_input(self, grid: np.ndarray, taskvars: Dict[str, Any]) -> np.ndarray:
        rows = taskvars['rows']
        columns = taskvars['columns']
        output_color = taskvars['output_color']
        
        # Split into halves
        half_rows = rows // 2
        top_half = grid[:half_rows, :]
        bottom_half = grid[half_rows:, :]
        
        # Find intersection of empty cells
        top_empty = (top_half == 0)
        bottom_empty = (bottom_half == 0)
        intersection = top_empty & bottom_empty
        
        # Create output grid
        output_grid = np.zeros((half_rows, columns), dtype=int)
        output_grid[intersection] = output_color
        
        return output_grid
    
    def create_grids(self) -> Tuple[Dict[str, Any], TrainTestData]:
        # Generate task variables
        rows = random.choice([6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30])  # Even numbers
        columns = random.randint(5, 30)
        
        # Choose colors (ensure all different)
        available_colors = list(range(1, 10))
        colors = random.sample(available_colors, 3)
        top_color, bottom_color, output_color = colors
        
        taskvars = {
            'rows': rows,
            'columns': columns,
            'top_color': top_color,
            'bottom_color': bottom_color,
            'output_color': output_color
        }
        
        # Generate training and test examples
        num_train = random.randint(3, 6)
        num_test = 1
        
        train_examples = []
        for _ in range(num_train):
            input_grid = self.create_input(taskvars, {})
            output_grid = self.transform_input(input_grid, taskvars)
            train_examples.append({'input': input_grid, 'output': output_grid})
        
        test_examples = []
        for _ in range(num_test):
            input_grid = self.create_input(taskvars, {})
            output_grid = self.transform_input(input_grid, taskvars)
            test_examples.append({'input': input_grid, 'output': output_grid})
        
        train_test_data = {
            'train': train_examples,
            'test': test_examples
        }
        
        return taskvars, train_test_data

