from Framework.arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from Framework.input_library import random_cell_coloring
import numpy as np
import random
from typing import Dict, Any, Tuple, List

class Taskf2829549Generator(ARCTaskGenerator):
    
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['rows']} x {vars['columns']}.",
            "Each grid contains a central vertical column, consistently colored with {color('middle_color')}, effectively dividing the grid into left and right halves.",
            "On the right half a random number of cells are colored with {color('right_color')}.",
            "On the left half a random number of cells are colored with {color('left_color')}.",
            "The intersection of empty cells from both halves — based on row and relative column position — is guaranteed to be non-empty."
        ]
        
        transformation_reasoning_chain = [
            "Output grids are of size {vars['rows']} x {vars['columns']// 2}.",
            "The central vertical column in the input grid is identified, and the left and right halves are identified accordingly.",
            "The output grid is generated by taking the intersection of empty cells from both halves, based on row and relative column position.",
            "The cells in this intersection are colored with {color('output_color')} in the output grid."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_grids(self) -> Tuple[Dict[str, Any], TrainTestData]:
        # Generate task variables
        taskvars = {
            'rows': random.randint(5, 15),
            'columns': random.choice([5, 7, 9, 11, 13, 15, 17, 19, 21]),  # odd numbers
            'middle_color': random.randint(1, 9),
            'left_color': random.randint(1, 9),
            'right_color': random.randint(1, 9),
            'output_color': random.randint(1, 9)
        }
        
        # Ensure all colors are different
        colors = [taskvars['middle_color']]
        
        while taskvars['left_color'] in colors:
            taskvars['left_color'] = random.randint(1, 9)
        colors.append(taskvars['left_color'])
        
        while taskvars['right_color'] in colors:
            taskvars['right_color'] = random.randint(1, 9)
        colors.append(taskvars['right_color'])
        
        while taskvars['output_color'] in colors:
            taskvars['output_color'] = random.randint(1, 9)
        
        # Generate training and test examples
        num_train = random.randint(3, 6)
        
        def generate_valid_example():
            # Keep trying until we get a valid example with non-empty intersection
            max_attempts = 50
            for _ in range(max_attempts):
                input_grid = self.create_input(taskvars, {})
                output_grid = self.transform_input(input_grid, taskvars)
                
                # Check if intersection is non-empty (output has colored cells)
                if np.any(output_grid == taskvars['output_color']):
                    return {'input': input_grid, 'output': output_grid}
            
            # If we can't generate a valid example, create one with minimal coloring
            return self._create_minimal_valid_example(taskvars)
        
        train_examples = [generate_valid_example() for _ in range(num_train)]
        test_examples = [generate_valid_example()]
        
        return taskvars, {'train': train_examples, 'test': test_examples}
    
    def _create_minimal_valid_example(self, taskvars: Dict[str, Any]) -> Dict[str, np.ndarray]:
        """Create a minimal example that guarantees non-empty intersection."""
        rows = taskvars['rows']
        columns = taskvars['columns']
        middle_col = columns // 2
        half_width = middle_col
        
        # Create grid with middle column
        grid = np.zeros((rows, columns), dtype=int)
        grid[:, middle_col] = taskvars['middle_color']
        
        # Add minimal coloring that leaves some empty intersection
        # Color only a few cells on each side to ensure intersection exists
        left_cells_to_color = min(2, half_width * rows // 3)
        right_cells_to_color = min(2, half_width * rows // 3)
        
        # Randomly color some cells on left side
        left_positions = [(r, c) for r in range(rows) for c in range(half_width)]
        left_to_color = random.sample(left_positions, left_cells_to_color)
        for r, c in left_to_color:
            grid[r, c] = taskvars['left_color']
        
        # Randomly color some cells on right side
        right_positions = [(r, c) for r in range(rows) for c in range(middle_col + 1, columns)]
        right_to_color = random.sample(right_positions, right_cells_to_color)
        for r, c in right_to_color:
            grid[r, c] = taskvars['right_color']
        
        return {'input': grid, 'output': self.transform_input(grid, taskvars)}
    
    def create_input(self, taskvars: Dict[str, Any], gridvars: Dict[str, Any]) -> np.ndarray:
        rows = taskvars['rows']
        columns = taskvars['columns']
        middle_col = columns // 2
        
        # Create empty grid
        grid = np.zeros((rows, columns), dtype=int)
        
        # Add central vertical column
        grid[:, middle_col] = taskvars['middle_color']
        
        # Define left and right halves (excluding middle column)
        left_half = grid[:, :middle_col]
        right_half = grid[:, middle_col + 1:]
        
        # Randomly color cells in left half
        left_density = random.uniform(0.2, 0.7)
        random_cell_coloring(left_half, taskvars['left_color'], density=left_density)
        
        # Randomly color cells in right half  
        right_density = random.uniform(0.2, 0.7)
        random_cell_coloring(right_half, taskvars['right_color'], density=right_density)
        
        return grid
    
    def transform_input(self, grid: np.ndarray, taskvars: Dict[str, Any]) -> np.ndarray:
        rows, columns = grid.shape
        middle_col = columns // 2
        half_width = middle_col
        
        # Extract left and right halves
        left_half = grid[:, :middle_col]
        right_half = grid[:, middle_col + 1:]
        
        # Create output grid
        output_grid = np.zeros((rows, half_width), dtype=int)
        
        # Find intersection of empty cells
        for r in range(rows):
            for c in range(half_width):
                # Check if both corresponding positions are empty (background = 0)
                if left_half[r, c] == 0 and right_half[r, c] == 0:
                    output_grid[r, c] = taskvars['output_color']
        
        return output_grid

