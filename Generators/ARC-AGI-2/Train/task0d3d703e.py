from Framework.arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from Framework.input_library import retry
import numpy as np
import random
from typing import Dict, List, Any, Tuple

class Task0d3d703eGenerator(ARCTaskGenerator):
    
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['rows']} Ã— {vars['rows']}.",
            "Each grid is completely filled with single-colored vertical strips, with no empty (0) cells.",
            "Each vertical strip starts from the first row and goes down to the last row, made up of identical-colored cells.",
            "Colors change from one strip to the next.",
            "All vertical strips in a grid are of uniform width (1 column) and use one of eight possible colors.",
            "The eight colors used across the dataset are: {color('color1')}, {color('color2')}, {color('color3')}, {color('color4')}, {color('color5')}, {color('color6')}, {color('color7')}, and {color('color8')}.",
            "Across all input grids, the eight possible colors must be covered. Not all eight colors need to appear in every single grid, but collectively all eight colors are used in the different grids.",
            "The arrangement of colors in each input grid must be completely different from all others."
        ]
        
        transformation_reasoning_chain = [
            "Output grids are generated by copying the input grids and swapping the colors of the one-cell wide vertical strips according to a fixed mapping.",
            "The specific color transformations applied are; {color('color1')} becomes {color('color2')}, and {color('color2')} becomes {color('color1')}, {color('color3')} becomes {color('color4')}, and {color('color4')} becomes {color('color3')}, {color('color5')} becomes {color('color6')}, {color('color6')} becomes {color('color5')}, {color('color7')} becomes {color('color8')}, and {color('color8')} becomes {color('color7')}.",
            "These swaps are applied consistently to all vertical strips in the input grid to produce the final output grid."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_input(self, taskvars: Dict[str, Any], gridvars: Dict[str, Any]) -> np.ndarray:
        rows = taskvars['rows']
        cols = rows  # Square grid
        colors = [taskvars[f'color{i}'] for i in range(1, 9)]
        
        # Use the color pattern from gridvars if provided, otherwise generate one
        if 'color_pattern' in gridvars:
            color_pattern = gridvars['color_pattern']
        else:
            # Generate a random pattern with no consecutive identical colors
            color_pattern = self._generate_non_consecutive_pattern(colors, cols)
        
        # Create grid with vertical strips
        grid = np.zeros((rows, cols), dtype=int)
        for col in range(cols):
            grid[:, col] = color_pattern[col]
        
        return grid
    
    def _generate_non_consecutive_pattern(self, colors: List[int], length: int) -> List[int]:
        """Generate a color pattern where no two consecutive colors are the same."""
        if length == 0:
            return []
        
        pattern = []
        available_colors = colors.copy()
        
        # First color can be any color
        pattern.append(random.choice(available_colors))
        
        # For subsequent positions, exclude the previous color
        for i in range(1, length):
            available = [c for c in available_colors if c != pattern[i-1]]
            # If we somehow have no available colors (shouldn't happen with 8 colors), use any
            if not available:
                available = available_colors
            pattern.append(random.choice(available))
        
        return pattern
    
    def transform_input(self, grid: np.ndarray, taskvars: Dict[str, Any]) -> np.ndarray:
        # Create color mapping for swaps
        color_map = {
            taskvars['color1']: taskvars['color2'],
            taskvars['color2']: taskvars['color1'],
            taskvars['color3']: taskvars['color4'],
            taskvars['color4']: taskvars['color3'],
            taskvars['color5']: taskvars['color6'],
            taskvars['color6']: taskvars['color5'],
            taskvars['color7']: taskvars['color8'],
            taskvars['color8']: taskvars['color7']
        }
        
        # Apply color swaps
        output_grid = np.copy(grid)
        for old_color, new_color in color_map.items():
            output_grid[grid == old_color] = new_color
        
        return output_grid
    
    def create_grids(self) -> Tuple[Dict[str, Any], TrainTestData]:
        # Generate task variables
        taskvars = {
            'rows': random.randint(3, 15)  # Square grid, so only need rows
        }
        
        # Generate 8 different colors (excluding 0 which is background)
        available_colors = list(range(1, 10))
        selected_colors = random.sample(available_colors, 8)
        for i in range(8):
            taskvars[f'color{i+1}'] = selected_colors[i]
        
        colors = [taskvars[f'color{i}'] for i in range(1, 9)]
        
        # Generate 3-6 training examples plus 1 test
        num_train = random.randint(3, 6)
        total_grids = num_train + 1  # training + test
        
        # Keep track of used patterns to ensure uniqueness
        used_patterns = set()
        
        # Strategy: Ensure all 8 colors are distributed across all grids
        # First, determine which colors go to which grids
        colors_per_grid = self._distribute_colors_across_grids(colors, total_grids, taskvars['rows'])
        
        def generate_pattern_with_required_colors(required_colors):
            def pattern_generator():
                # Start with required colors, then fill remaining slots
                remaining_slots = taskvars['rows'] - len(required_colors)
                if remaining_slots > 0:
                    # Add random colors from the full set to fill remaining slots
                    additional_colors = random.choices(colors, k=remaining_slots)
                    pattern_colors = list(required_colors) + additional_colors
                else:
                    # If we have more required colors than slots, just use required colors
                    pattern_colors = list(required_colors)[:taskvars['rows']]
                
                # Shuffle and ensure no consecutive identical colors
                attempts = 0
                while attempts < 100:
                    random.shuffle(pattern_colors)
                    # Check if this arrangement has consecutive identical colors
                    has_consecutive = any(pattern_colors[i] == pattern_colors[i-1] 
                                        for i in range(1, len(pattern_colors)))
                    if not has_consecutive:
                        return tuple(pattern_colors)
                    attempts += 1
                
                # If shuffling failed, generate systematically
                return tuple(self._generate_non_consecutive_pattern(pattern_colors, len(pattern_colors)))
            
            def is_valid_pattern(pattern):
                # Check uniqueness and no consecutive identical colors
                if pattern in used_patterns:
                    return False
                for i in range(1, len(pattern)):
                    if pattern[i] == pattern[i-1]:
                        return False
                # Ensure all required colors are present
                return all(color in pattern for color in required_colors)
            
            return retry(pattern_generator, is_valid_pattern, max_attempts=200)
        
        # Generate training examples
        train_examples = []
        for i in range(num_train):
            required_colors = colors_per_grid[i]
            pattern = generate_pattern_with_required_colors(required_colors)
            used_patterns.add(pattern)
            
            gridvars = {'color_pattern': list(pattern)}
            input_grid = self.create_input(taskvars, gridvars)
            output_grid = self.transform_input(input_grid, taskvars)
            
            train_examples.append({
                'input': input_grid,
                'output': output_grid
            })
        
        # Generate test example
        test_required_colors = colors_per_grid[num_train]  # Last entry is for test
        test_pattern = generate_pattern_with_required_colors(test_required_colors)
        test_gridvars = {'color_pattern': list(test_pattern)}
        test_input = self.create_input(taskvars, test_gridvars)
        test_output = self.transform_input(test_input, taskvars)
        
        test_examples = [{
            'input': test_input,
            'output': test_output
        }]
        
        return taskvars, {
            'train': train_examples,
            'test': test_examples
        }
    
    def _distribute_colors_across_grids(self, colors: List[int], num_grids: int, grid_size: int) -> List[List[int]]:
        """Distribute all 8 colors across the grids, ensuring each grid gets at least some colors."""
        # Shuffle colors for random distribution
        shuffled_colors = colors.copy()
        random.shuffle(shuffled_colors)
        
        # Distribute colors across grids
        colors_per_grid = [[] for _ in range(num_grids)]
        
        # First, give each grid at least one color (round-robin)
        for i, color in enumerate(shuffled_colors):
            grid_idx = i % num_grids
            colors_per_grid[grid_idx].append(color)
        
        # Make sure each grid has at least 2 colors and no more than grid_size colors
        for i in range(num_grids):
            # Ensure minimum 2 colors per grid
            while len(colors_per_grid[i]) < 2:
                # Add a random color that's not already in this grid
                available = [c for c in colors if c not in colors_per_grid[i]]
                if available:
                    colors_per_grid[i].append(random.choice(available))
                else:
                    # If all colors are used, duplicate one
                    colors_per_grid[i].append(random.choice(colors))
            
            # Ensure not more colors than grid size
            if len(colors_per_grid[i]) > grid_size:
                colors_per_grid[i] = colors_per_grid[i][:grid_size]
        
        return colors_per_grid

