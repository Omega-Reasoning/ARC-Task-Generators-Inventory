
from arc_task_generator import ARCTaskGenerator, GridPair, TrainTestData
from transformation_library import find_connected_objects, GridObjects, GridObject
from input_library import retry
import numpy as np
import random
from typing import Dict, Any, Tuple, List

class Task11852cabGenerator(ARCTaskGenerator):
    def __init__(self):
        input_reasoning_chain = [
            "Input grids are of size {vars['grid_size']}x{vars['grid_size']}.",
            "Each grid contains multi-colored cells, 8-way connected to each other, forming a specific cell arrangement, with the remaining cells being empty (0).",
            "The arrangement always appears approximately in the center of the grid, occupying a {vars['grid_size']//2}x{vars['grid_size']//2} subgrid.",
            "The arrangement is generated by first creating a checkerboard pattern within the {vars['grid_size']//2}x{vars['grid_size']//2} subgrid, where colored cells and empty cells alternate across rows and columns in a specific way.",
            "The checkerboard pattern for a 5x5 subgrid is defined as:\\n [[a, 0, b, 0, a], [0, c, 0, c, 0], [b, 0, c, 0, b], [0, c, 0, c, 0], [a, 0, b, 0, a]]\\n where a, b, and c are colors. This pattern can sometimes vary, for example: a and b may occasionally be the same color, or the center cell may have a different color.\\nFor larger or smaller subgrids, the pattern expands or shrinks in the same way: each concentric layer follows the checkerboard structure, with each layer introducing its own pair of colors, which may sometimes be identical.",
            "As the grid size grows, each concentric layer follows the same checkerboard structure, with two distinct colors assigned to each layer.",
            "For the outermost (last) layer, either two distinct colors or a single color may be used.",
            "Once the full checkerboard pattern has been created, a post-processing step is applied: one layer is selected, one color from that layer is chosen, and all cells of that color in the selected layer are removed, except for one remaining cell. The center cell is never removed during this step."
        ]
        
        transformation_reasoning_chain = [
            "The output grid is constructed by copying the input grid and identifying the incomplete checkerboard pattern within the {vars['grid_size']//2}x{vars['grid_size']//2} central subgrid, where colored cells and empty cells alternate across rows and columns in a specific way.",
            "The checkerboard pattern for a 5x5 subgrid is defined as:\\n [[a, 0, b, 0, a], [0, c, 0, c, 0], [b, 0, c, 0, b], [0, c, 0, c, 0], [a, 0, b, 0, a]]\\n where a, b, and c are colors. This pattern may vary, e.g., a and b may sometimes be the same color, or the center cell may have a different color.",
            "The incomplete pattern is analyzed to identify all missing cells (empty positions that should contain colored cells according to the checkerboard structure).",
            "For each missing cell, the correct color is inferred based on the surrounding pattern and layer structure, and the missing cell is filled with that color."
        ]
        
        super().__init__(input_reasoning_chain, transformation_reasoning_chain)
    
    def create_grids(self) -> Tuple[Dict[str, Any], TrainTestData]:
        # Generate task variables - restricted grid sizes
        grid_sizes = [ 10, 14, 18]
        grid_size = random.choice(grid_sizes)
        
        taskvars = {
            'grid_size': grid_size
        }
        
        # Create training examples with specific constraints
        train_examples = []
        
        # Always create exactly 5 examples to ensure we can apply all constraints
        num_train = 5
        
        # Track constraints
        constraints_applied = {
            'same_ab_colors': False,
            'different_center': False,
            'same_center_different_outer': False,
            'same_center_and_first_layer': False  # New constraint
        }
        
        for i in range(num_train):
            # Set up grid variables for this example
            gridvars = self._create_gridvars(taskvars)
            
            # Apply constraints in order
            if i == 0 and not constraints_applied['same_ab_colors']:
                # Constraint 1: Force some layer to have the same colors for corners and non-corners
                layer_to_modify = random.choice([l for l in gridvars['layer_colors'].keys() if l > 0 and isinstance(gridvars['layer_colors'][l], dict)])
                if layer_to_modify:
                    corner_color = gridvars['layer_colors'][layer_to_modify]['corner_color']
                    gridvars['layer_colors'][layer_to_modify]['other_color'] = corner_color
                constraints_applied['same_ab_colors'] = True
                
            elif i == 1 and not constraints_applied['different_center']:
                # Constraint 2: Force center color to be different from other layers
                center_layer = 0
                other_colors = set()
                for layer, colors in gridvars['layer_colors'].items():
                    if layer != center_layer:
                        if isinstance(colors, dict):
                            other_colors.update(colors.values())
                        else:
                            other_colors.add(colors)
                
                available_colors = [c for c in range(1, 10) if c not in other_colors]
                if available_colors:
                    gridvars['layer_colors'][center_layer] = random.choice(available_colors)
                constraints_applied['different_center'] = True
                
            elif i == 2 and not constraints_applied['same_center_different_outer']:
                # Constraint 3: Center color same as some other layer, but final layer has two different colors
                center_layer = 0
                max_layer = max(gridvars['layer_colors'].keys())
                
                # Make center color same as one of the other layers
                other_layers = [l for l in gridvars['layer_colors'].keys() if l != center_layer and l != max_layer]
                if other_layers:
                    reference_layer = random.choice(other_layers)
                    if isinstance(gridvars['layer_colors'][reference_layer], dict):
                        # Pick one of the colors from the reference layer
                        reference_colors = list(gridvars['layer_colors'][reference_layer].values())
                        gridvars['layer_colors'][center_layer] = random.choice(reference_colors)
                    else:
                        gridvars['layer_colors'][center_layer] = gridvars['layer_colors'][reference_layer]
                
                # Ensure final layer has two different colors
                if max_layer in gridvars['layer_colors']:
                    available_colors = list(range(1, 10))
                    used_colors = set()
                    for layer, colors in gridvars['layer_colors'].items():
                        if isinstance(colors, dict):
                            used_colors.update(colors.values())
                        else:
                            used_colors.add(colors)
                    
                    available_colors = [c for c in available_colors if c not in used_colors]
                    if len(available_colors) >= 2:
                        gridvars['layer_colors'][max_layer] = {
                            'corner_color': available_colors[0],
                            'other_color': available_colors[1]
                        }
                    else:
                        # Fallback: use different colors even if they might overlap
                        gridvars['layer_colors'][max_layer] = {
                            'corner_color': 1,
                            'other_color': 2
                        }
                
                constraints_applied['same_center_different_outer'] = True
            
            elif i == 3 and not constraints_applied['same_center_and_first_layer']:
                # New Constraint 4: Same center cell and first layer (5 cells total), but all other layers have two different colors
                center_layer = 0
                first_layer = 1
                
                # Choose a color for center and first layer
                chosen_color = random.choice(range(1, 10))
                
                # Set center to this color
                gridvars['layer_colors'][center_layer] = chosen_color
                
                # Set first layer to use the same color for both corner and other positions
                gridvars['layer_colors'][first_layer] = {
                    'corner_color': chosen_color,
                    'other_color': chosen_color
                }
                
                # Ensure all other layers have two different colors
                used_colors = {chosen_color}
                available_colors = [c for c in range(1, 10) if c != chosen_color]
                
                for layer in gridvars['layer_colors'].keys():
                    if layer > 1:  # Skip center (0) and first layer (1)
                        if len(available_colors) >= 2:
                            # Pick two different colors
                            color1 = available_colors[0]
                            color2 = available_colors[1]
                            gridvars['layer_colors'][layer] = {
                                'corner_color': color1,
                                'other_color': color2
                            }
                            available_colors = available_colors[2:]  # Remove used colors
                        else:
                            # Fallback: use any two different colors
                            all_colors = list(range(1, 10))
                            color1 = random.choice([c for c in all_colors if c != chosen_color])
                            color2 = random.choice([c for c in all_colors if c != color1])
                            gridvars['layer_colors'][layer] = {
                                'corner_color': color1,
                                'other_color': color2
                            }
                
                constraints_applied['same_center_and_first_layer'] = True
            
            input_grid = self.create_input(taskvars, gridvars)
            output_grid = self.transform_input(input_grid, taskvars)
            
            train_examples.append({
                'input': input_grid,
                'output': output_grid
            })
        
        # Create test example
        test_gridvars = self._create_gridvars(taskvars)
        test_input = self.create_input(taskvars, test_gridvars)
        test_output = self.transform_input(test_input, taskvars)
        
        test_examples = [{
            'input': test_input,
            'output': test_output
        }]
        
        return taskvars, {
            'train': train_examples,
            'test': test_examples
        }
    
    def _create_gridvars(self, taskvars: Dict[str, Any]) -> Dict[str, Any]:
        """Create grid-specific variables for color assignment."""
        subgrid_size = taskvars['grid_size'] // 2
        max_layer = subgrid_size // 2
        
        available_colors = list(range(1, 10))
        random.shuffle(available_colors)
        
        layer_colors = {}
        color_idx = 0
        
        # Assign colors to each layer
        for layer in range(max_layer + 1):
            if layer == 0:  # Center layer (single cell)
                layer_colors[layer] = available_colors[color_idx]
                color_idx += 1
            elif layer == max_layer and random.choice([True, False]):
                # Outermost layer - sometimes use single color
                layer_colors[layer] = available_colors[color_idx]
                color_idx += 1
            else:
                # Regular layers - use two colors: one for corners, one for others
                corner_color = available_colors[color_idx % len(available_colors)]
                other_color = available_colors[(color_idx + 1) % len(available_colors)]
                layer_colors[layer] = {
                    'corner_color': corner_color,
                    'other_color': other_color
                }
                color_idx += 2
        
        return {
            'layer_colors': layer_colors
        }
    
    def create_input(self, taskvars: Dict[str, Any], gridvars: Dict[str, Any]) -> np.ndarray:
        grid_size = taskvars['grid_size']
        subgrid_size = grid_size // 2
        
        # Create empty grid
        grid = np.zeros((grid_size, grid_size), dtype=int)
        
        # Calculate center position for subgrid
        start_row = (grid_size - subgrid_size) // 2
        start_col = (grid_size - subgrid_size) // 2
        
        # Create complete checkerboard pattern
        complete_pattern = self._create_checkerboard_pattern(subgrid_size, gridvars)
        
        # Apply the pattern to the grid
        grid[start_row:start_row+subgrid_size, start_col:start_col+subgrid_size] = complete_pattern
        
        # Apply post-processing: remove cells from one layer
        grid = self._remove_cells_from_layer(grid, start_row, start_col, subgrid_size, gridvars)
        
        return grid
    
    def _is_corner_of_layer(self, r: int, c: int, center: int, layer: int) -> bool:
        """Check if position (r,c) is a corner of the given layer."""
        if layer == 0:
            return False  # Center has no corners
        
        # Calculate the bounding box of the layer
        min_r = center - layer
        max_r = center + layer
        min_c = center - layer
        max_c = center + layer
        
        # Check if it's a corner position
        return ((r == min_r or r == max_r) and (c == min_c or c == max_c))
    
    def _create_checkerboard_pattern(self, size: int, gridvars: Dict[str, Any]) -> np.ndarray:
        """Create a complete checkerboard pattern with proper layer colors."""
        pattern = np.zeros((size, size), dtype=int)
        layer_colors = gridvars['layer_colors']
        center = size // 2
        
        for r in range(size):
            for c in range(size):
                # Only fill positions that follow checkerboard pattern
                if (r + c) % 2 == 0:  # Even positions get colors
                    # Determine layer based on distance from center
                    layer = max(abs(r - center), abs(c - center))
                    
                    if layer in layer_colors:
                        layer_color_info = layer_colors[layer]
                        
                        if isinstance(layer_color_info, dict):
                            # Layer has corner and other colors
                            if self._is_corner_of_layer(r, c, center, layer):
                                pattern[r, c] = layer_color_info['corner_color']
                            else:
                                pattern[r, c] = layer_color_info['other_color']
                        else:
                            # Single color for this layer
                            pattern[r, c] = layer_color_info
                # Odd positions stay empty (0)
        
        return pattern
    
    def _remove_cells_from_layer(self, grid: np.ndarray, start_row: int, start_col: int, 
                                subgrid_size: int, gridvars: Dict[str, Any]) -> np.ndarray:
        """Remove cells from one layer, ensuring proper constraints for outer layer."""
        center = subgrid_size // 2
        center_row = start_row + center
        center_col = start_col + center
        max_layer = center  # Outermost layer
        
        # Find all non-empty cells in the subgrid grouped by layer and color
        cells_by_layer_and_color = {}
        corner_cells_by_layer_and_color = {}
        non_corner_cells_by_layer_and_color = {}
        
        for r in range(start_row, start_row + subgrid_size):
            for c in range(start_col, start_col + subgrid_size):
                if grid[r, c] != 0:
                    # Calculate layer
                    layer = max(abs(r - center_row), abs(c - center_col))
                    color = grid[r, c]
                    is_corner = self._is_corner_of_layer(r - start_row, c - start_col, center, layer)
                    
                    # Group all cells
                    if layer not in cells_by_layer_and_color:
                        cells_by_layer_and_color[layer] = {}
                    if color not in cells_by_layer_and_color[layer]:
                        cells_by_layer_and_color[layer][color] = []
                    cells_by_layer_and_color[layer][color].append((r, c))
                    
                    # Group corner cells
                    if is_corner:
                        if layer not in corner_cells_by_layer_and_color:
                            corner_cells_by_layer_and_color[layer] = {}
                        if color not in corner_cells_by_layer_and_color[layer]:
                            corner_cells_by_layer_and_color[layer][color] = []
                        corner_cells_by_layer_and_color[layer][color].append((r, c))
                    else:
                        # Group non-corner cells
                        if layer not in non_corner_cells_by_layer_and_color:
                            non_corner_cells_by_layer_and_color[layer] = {}
                        if color not in non_corner_cells_by_layer_and_color[layer]:
                            non_corner_cells_by_layer_and_color[layer][color] = []
                        non_corner_cells_by_layer_and_color[layer][color].append((r, c))
        
        # Select a layer and color to remove from (not layer 0 which is center)
        available_layers = [layer for layer in cells_by_layer_and_color.keys() if layer > 0]
        
        if available_layers:
            selected_layer = random.choice(available_layers)
            available_colors = list(cells_by_layer_and_color[selected_layer].keys())
            selected_color = random.choice(available_colors)
            
            # Get cells to remove
            cells_to_remove = cells_by_layer_and_color[selected_layer][selected_color]
            
            if len(cells_to_remove) > 1:
                # Determine which cells to keep
                cells_to_keep = []
                
                if selected_layer == max_layer:
                    # Special handling for outermost layer: keep at least one corner and one non-corner
                    corner_cells = corner_cells_by_layer_and_color.get(selected_layer, {}).get(selected_color, [])
                    non_corner_cells = non_corner_cells_by_layer_and_color.get(selected_layer, {}).get(selected_color, [])
                    
                    # Keep at least one corner cell if available
                    if corner_cells:
                        cells_to_keep.append(random.choice(corner_cells))
                    
                    # Keep at least one non-corner cell if available
                    if non_corner_cells:
                        cells_to_keep.append(random.choice(non_corner_cells))
                    
                    # If we couldn't keep both types, just keep one random cell
                    if not cells_to_keep:
                        cells_to_keep.append(random.choice(cells_to_remove))
                else:
                    # For non-outermost layers, keep just one cell
                    cells_to_keep.append(random.choice(cells_to_remove))
                
                # Remove cells that are not in the keep list
                for r, c in cells_to_remove:
                    if (r, c) not in cells_to_keep:
                        grid[r, c] = 0
        
        return grid
    
    def transform_input(self, grid: np.ndarray, taskvars: Dict[str, Any]) -> np.ndarray:
        """Transform input by completing the checkerboard pattern."""
        grid_size = taskvars['grid_size']
        subgrid_size = grid_size // 2
        output_grid = grid.copy()
        
        # Calculate center position for subgrid
        start_row = (grid_size - subgrid_size) // 2
        start_col = (grid_size - subgrid_size) // 2
        center_row = start_row + subgrid_size // 2
        center_col = start_col + subgrid_size // 2
        center = subgrid_size // 2
        
        # Analyze existing pattern to determine colors for each layer
        colors_by_layer_and_position = {}
        
        for r in range(start_row, start_row + subgrid_size):
            for c in range(start_col, start_col + subgrid_size):
                if output_grid[r, c] != 0:
                    layer = max(abs(r - center_row), abs(c - center_col))
                    is_corner = self._is_corner_of_layer(r - start_row, c - start_col, center, layer)
                    
                    if layer not in colors_by_layer_and_position:
                        colors_by_layer_and_position[layer] = {'corner': set(), 'other': set()}
                    
                    if is_corner:
                        colors_by_layer_and_position[layer]['corner'].add(output_grid[r, c])
                    else:
                        colors_by_layer_and_position[layer]['other'].add(output_grid[r, c])
        
        # Fill missing cells based on checkerboard pattern and layer structure
        for r in range(start_row, start_row + subgrid_size):
            for c in range(start_col, start_col + subgrid_size):
                if output_grid[r, c] == 0 and (r + c - start_row - start_col) % 2 == 0:  # Should be colored
                    layer = max(abs(r - center_row), abs(c - center_col))
                    is_corner = self._is_corner_of_layer(r - start_row, c - start_col, center, layer)
                    
                    if layer in colors_by_layer_and_position:
                        if is_corner and colors_by_layer_and_position[layer]['corner']:
                            # Use corner color
                            color = list(colors_by_layer_and_position[layer]['corner'])[0]
                            output_grid[r, c] = color
                        elif not is_corner and colors_by_layer_and_position[layer]['other']:
                            # Use other color
                            color = list(colors_by_layer_and_position[layer]['other'])[0]
                            output_grid[r, c] = color
                        else:
                            # Fallback: use any available color from this layer
                            all_colors = colors_by_layer_and_position[layer]['corner'] | colors_by_layer_and_position[layer]['other']
                            if all_colors:
                                output_grid[r, c] = list(all_colors)[0]
                    else:
                        # No existing colors in this layer - infer from adjacent layers
                        best_color = 1  # Default
                        min_layer_diff = float('inf')
                        
                        for existing_layer, layer_info in colors_by_layer_and_position.items():
                            layer_diff = abs(existing_layer - layer)
                            if layer_diff < min_layer_diff:
                                all_colors = layer_info['corner'] | layer_info['other']
                                if all_colors:
                                    min_layer_diff = layer_diff
                                    best_color = list(all_colors)[0]
                        
                        output_grid[r, c] = best_color
        
        return output_grid